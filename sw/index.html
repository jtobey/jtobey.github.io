<!doctype html>
<!--
Copyright 2025 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
  <style>/* style.css */
#game-container {
  display: flex;
  flex-direction: column;
}

#board-container {
  overflow: hidden;
  position: relative;
  touch-action: none;
  border: 1px solid #ccc;
  width: 601px;
  height: 601px;
}

#board-transformer {
  display: grid;
  transform-origin: 0 0;
  background-color: #ccc;
  width: 100%;
  height: 100%;
}

.square {
  box-sizing: border-box;
  position: relative;
  display: flex;
  background-color: #dda;
  border-bottom: 1px solid #ccc;
  border-right: 1px solid #ccc;
  justify-content: center;
  align-items:  center;
  width: auto;
  height: auto;
}

.bonus-text {
  color: #dda;
  font-family: sans-serif;
  font-size: .75em;
}

#controls-container {
  margin-top: 20px;
}

#buttons-container {
  display: flex;
  gap: 5px;
  width: 310px;
}

#buttons-container button {
  flex: 1;
  height: 30px;
}

#rack-container, #exchange-container {
  display: flex;
  flex-direction: row;
  gap: 5px;
  margin-bottom: 10px;
}

.tile, .tile-spot {
  box-sizing: border-box;
  cursor: pointer;
  position: relative;
  touch-action: none;
  background-color: #eee;
  border: 1px solid #999;
  width: 40px;
  height: 40px;
  font-size: 24px;
}

.letter {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.value {
  position: absolute;
  font-size: 50%;
  bottom: 2px;
  left: 4px;
}

.tile-spot {
  cursor: default;
  background-color: #dda;
  border-color: #ccc;
}

.tile-spot[data-row="exchange"] {
  display: flex;
  justify-content: center;
  align-items:  center;
}

.tile-spot[data-row="exchange"]:before {
  content: "♻";
  color: #bbb;
  font-size: 28px;
}

.placed {
  touch-action: none;
  background-color: #90ee90b3 !important;
}

.square.dl {
  background-color: #c99;
}

.square.tl {
  background-color: #bbb;
}

.square.dw {
  background-color: #ff3;
}

.square.tw {
  background-color: #f90;
}

.square.center {
  background-color: #f6f;
}

.tile.selected, .placed.selected {
  border: 2px solid #00f !important;
}

.square.selected {
  background-color: #f0f0c0 !important;
}

.drop-target {
  box-shadow: inset 0 0 5px 2px #0000ff80;
}

.tile:focus, .square:focus, .placed:focus {
  outline: 3px solid #333;
}

#center-panel {
  display: flex;
  flex-direction: column;
  align-items:  center;
}

#score-panel, #bag-tile-count-container {
  display: flex;
  flex-direction: row;
  justify-content: center;
  margin-bottom: 10px;
  font-size: 18px;
}

.player-score {
  margin: 0 10px;
}

.current-player {
  font-weight: bold;
}

.ghost-tile {
  position: fixed;
  pointer-events: none;
  z-index: 1000;
  transition: transform .1s ease-out;
  transform: translate(-50%, -50%);
  box-shadow: 0 4px 8px #0003;
}

.tile.dragging, .placed.dragging {
  opacity: .4;
}

.info-popup {
  position: absolute;
  z-index: 1001;
  background-color: #fff;
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 10px;
  box-shadow: 0 2px 10px #0003;
}

.info-popup h3 {
  margin-top: 0;
}

.info-popup ul {
  margin: 0;
  padding-left: 20px;
}

.info-popup li {
  margin-bottom: 5px;
}

@media (min-width: 1024px) {
  #game-container {
    flex-direction: row;
    align-items:  flex-start;
  }

  #controls-container {
    margin-top: 0;
    margin-left: 20px;
  }
}

@media (max-width: 601px) {
  #board-container, #buttons-container {
    width: 98vw;
  }

  #board-container {
    height: 98vw;
  }

  .square {
    width: auto;
    height: auto;
    font-size: 3.2vw;
  }

  .bonus-text {
    font-size: 2.4vw;
  }
}

dialog {
  border: 1px solid #ccc;
  border-radius: 5px;
  box-shadow: 0 2px 10px #0000001a;
}

#settings-dialog {
  background-color: #f9f9f9;
  border: 1px solid #ccc;
  border-radius: 5px;
  margin-top: 1em;
  padding: 1em;
}

.settings-group {
  margin-bottom: 1em;
}

.player-entry {
  display: flex;
  align-items:  center;
  margin-bottom: .5em;
}

.player-entry input {
  margin-right: .5em;
}

@media (prefers-color-scheme: dark) {
  #settings-dialog {
    color: #eee;
    background-color: #333;
  }
}

dialog::backdrop {
  background-color: #00000080;
}

dialog .buttons {
  display: flex;
  justify-content: flex-end;
  margin-top: 1em;
}

dialog button {
  margin-left: .5em;
}

.replay-link {
  margin-left: 1em;
}

.source-link {
  margin-top: 1em;
}

@media (prefers-color-scheme: dark) {
  body {
    color: #eee;
    background-color: #121212;
  }

  h1 {
    color: #eee;
  }

  #board-container {
    border-color: #444;
  }

  #board-transformer {
    background-color: #111;
  }

  .square {
    background-color: #332;
    border-bottom: 1px solid #444;
    border-right: 1px solid #444;
  }

  .tile, .tile-spot {
    background-color: #444;
    border: 1px solid #777;
  }

  .tile-spot {
    background-color: #332;
    border-color: #444;
  }

  .tile-spot[data-row="exchange"]:before {
    color: #444;
  }

  .placed {
    background-color: #228822b3 !important;
  }

  .square.dl {
    background-color: #533;
  }

  .square.tl {
    background-color: #555;
  }

  .square.dw {
    background-color: #660;
  }

  .square.tw {
    background-color: #840;
  }

  .square.center {
    background-color: #505;
  }

  .tile.selected, .placed.selected {
    border: 2px solid #add8e6 !important;
  }

  .square.selected {
    background-color: #404010 !important;
  }

  .bonus-text {
    color: #332;
  }

  dialog {
    color: #eee;
    background-color: #222;
    border-color: #555;
  }

  .info-popup {
    color: #eee;
    background-color: #333;
    border-color: #555;
  }
}
</style><script type="module">// game/validation.ts
function indicesOk(arrayLength, ...indices) {
  for (const index of indices) {
    if (index !== Math.floor(index) || index < 0 || index >= arrayLength)
      return false;
  }
  return true;
}
function checkIndices(arrayLength, ...indices) {
  for (const index of indices) {
    if (!indicesOk(arrayLength, index)) {
      throw new RangeError(`Index ${index} is out of range 0..${arrayLength - 1}.`);
    }
  }
}
function arraysEqual(a1, a2, warnIfNot = true) {
  if (a1.length === a2.length && a1.keys().every((k) => a1[k] === a2[k])) {
    return true;
  }
  if (warnIfNot)
    console.warn(`[${a1}] does not equal [${a2}]`);
  return false;
}

// game/bag_defaults.ts
var BAG_DEFAULTS = new Map([
  ["en", {
    name: "English",
    letterCounts: {
      A: 721,
      B: 187,
      C: 360,
      D: 363,
      E: 1122,
      F: 134,
      G: 293,
      H: 212,
      I: 813,
      J: 100,
      K: 100,
      L: 494,
      M: 260,
      N: 636,
      O: 573,
      P: 271,
      Q: 100,
      R: 683,
      S: 909,
      T: 600,
      U: 327,
      V: 100,
      W: 100,
      X: 100,
      Y: 142,
      Z: 100,
      "": 200
    },
    letterValues: {
      A: 1,
      B: 4,
      C: 4,
      D: 2,
      E: 1,
      F: 4,
      G: 3,
      H: 4,
      I: 1,
      J: 9,
      K: 5,
      L: 2,
      M: 3,
      N: 1,
      O: 1,
      P: 3,
      Q: 10,
      R: 1,
      S: 1,
      T: 1,
      U: 2,
      V: 5,
      W: 4,
      X: 8,
      Y: 4,
      Z: 8,
      "": 0
    }
  }],
  ["es", {
    name: "Español",
    letterCounts: {
      A: 1245,
      B: 158,
      C: 449,
      D: 397,
      E: 1046,
      F: 100,
      G: 156,
      H: 103,
      I: 721,
      J: 100,
      K: 100,
      L: 406,
      M: 306,
      N: 626,
      Ñ: 100,
      O: 816,
      P: 240,
      Qu: 100,
      R: 812,
      S: 662,
      T: 494,
      U: 244,
      V: 119,
      X: 100,
      Y: 100,
      Z: 100,
      "": 200
    },
    letterValues: {
      A: 1,
      B: 3,
      C: 2,
      D: 2,
      E: 1,
      F: 4,
      G: 4,
      H: 4,
      I: 1,
      J: 5,
      K: 9,
      L: 2,
      M: 2,
      N: 1,
      Ñ: 10,
      O: 1,
      P: 3,
      Qu: 6,
      R: 1,
      S: 1,
      T: 1,
      U: 2,
      V: 4,
      X: 8,
      Y: 5,
      Z: 5,
      "": 0
    }
  }]
]);
function getBagLanguages() {
  return BAG_DEFAULTS.entries().map(([key, value]) => ({
    code: key,
    name: value.name
  }));
}
function getBagDefaults(bagLanguage, tileCount) {
  if (bagLanguage === "") {
    return { letterCounts: new Map, letterValues: new Map };
  }
  const defaults = BAG_DEFAULTS.get(bagLanguage);
  if (!defaults)
    return null;
  const letterCounts = new Map(Object.entries(defaults.letterCounts));
  if (tileCount !== undefined) {
    const defaultTileCount = [...letterCounts.values()].reduce((a, b) => a + b, 0);
    if (defaultTileCount > 0) {
      const newLetterCounts = new Map;
      for (const letter of letterCounts.keys()) {
        newLetterCounts.set(letter, 0);
      }
      const letterSegments = [];
      let currentEnd = 0;
      const sortedLetters = [...letterCounts.keys()].sort();
      for (const letter of sortedLetters) {
        const count = letterCounts.get(letter);
        currentEnd += count / defaultTileCount;
        letterSegments.push({ letter, end: currentEnd });
      }
      if (letterSegments.length > 0) {
        letterSegments[letterSegments.length - 1].end = 1;
      }
      for (let i = 0;i < tileCount; i++) {
        const value = (i + 0.5) / tileCount;
        const segment = letterSegments.find((s) => value < s.end);
        newLetterCounts.set(segment.letter, newLetterCounts.get(segment.letter) + 1);
      }
      return {
        letterCounts: newLetterCounts,
        letterValues: new Map(Object.entries(defaults.letterValues))
      };
    }
  }
  return {
    letterCounts,
    letterValues: new Map(Object.entries(defaults.letterValues))
  };
}
function hasBagDefaults(bagLanguage) {
  return BAG_DEFAULTS.has(bagLanguage);
}

// game/player.ts
class Player {
  id;
  name;
  constructor({ id, name = `Player ${id}` }) {
    this.id = id;
    this.name = name;
  }
  equals(other) {
    return other instanceof Player && other.id === this.id && other.name === this.name;
  }
  toJSON() {
    return {
      id: this.id,
      name: this.name
    };
  }
  static fromJSON(json) {
    if (!(typeof json === "object" && typeof json.id === "string" && typeof json.name === "string")) {
      throw new TypeError(`Invalid Player serialization: ${JSON.stringify(json)}`);
    }
    return new Player(json);
  }
}

// game/version.ts
var toProtocolVersion = (v) => v;
var _PROTOCOL_VERSIONS = Object.create(null);
var v = (vStr) => _PROTOCOL_VERSIONS[vStr] = toProtocolVersion(vStr);
var PROTOCOL_VERSIONS = _PROTOCOL_VERSIONS;
var PROTOCOL_VERSION_0 = v("0");
var PROTOCOL_VERSION_1 = v("1");
var PROTOCOL_VERSION = PROTOCOL_VERSION_1;

// game/settings.ts
function toGameId(gameIdStr) {
  return gameIdStr;
}
function fromGameId(gameId) {
  return gameId;
}
function makeGameId(now = Date.now()) {
  const ALPHABET = "123456789BCDFGHJKLMNPQRSTVWXYZbcdfghjkmnpqrstvwxyz";
  const base = BigInt(ALPHABET.length);
  let n = BigInt(Math.floor(now));
  let id = "";
  while (id.length < 7) {
    id = ALPHABET[Number(n % base)] + id;
    n /= base;
  }
  return toGameId(id);
}
var DEFAULT_BOARD_LAYOUT = [
  "D..d..T......T.",
  ".D...D...t.t..T",
  "..D.....t...t..",
  "d..D...t.....t.",
  "....D.t...D....",
  ".D...t.d.....t.",
  "T...d...d...t..",
  "...d.t...d.t...",
  "..d...t...t...T",
  ".d.....t.d...D.",
  "....D...d.D....",
  ".d.....d...D..d",
  "..d...d.....D..",
  "T..d.d...D...D.",
  ".T......T..d..D"
];
var DEFAULT_BINGO_BONUS = 42;
var DEFAULT_RACK_CAPACITY = 7;

class Settings {
  letterCounts;
  letterValues;
  gameId;
  baseUrl = "http://nonet/";
  version = PROTOCOL_VERSION;
  players = ["1", "2"].map((id) => new Player({ id }));
  maxPlayerNameLength = 50;
  boardLayout = [...DEFAULT_BOARD_LAYOUT];
  bingoBonus = DEFAULT_BINGO_BONUS;
  rackCapacity = DEFAULT_RACK_CAPACITY;
  tileSystemType = "honor";
  tileSystemSettings = { seed: "1" };
  dictionaryType = "permissive";
  dictionarySettings = null;
  constructor(bagDefaults, letterCounts = bagDefaults.letterCounts, letterValues = bagDefaults.letterValues) {
    this.letterCounts = letterCounts;
    this.letterValues = letterValues;
  }
  static forLanguage(bagLanguage) {
    const boardSize = DEFAULT_BOARD_LAYOUT.reduce((acc, row) => acc + row.length, 0);
    const tileCount = Math.round(boardSize / (15 * 15) * 100);
    const defaults = getBagDefaults(bagLanguage, tileCount);
    return defaults && new Settings(defaults);
  }
  toJSON() {
    return {
      version: this.version,
      players: this.players.map((p) => p.toJSON()),
      letterCounts: mapToJSON(this.letterCounts),
      letterValues: mapToJSON(this.letterValues),
      boardLayout: this.boardLayout,
      bingoBonus: this.bingoBonus,
      rackCapacity: this.rackCapacity,
      tileSystemType: this.tileSystemType,
      tileSystemSettings: this.tileSystemSettings,
      dictionaryType: this.dictionaryType,
      dictionarySettings: this.dictionarySettings
    };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in Settings serialization: ${JSON.stringify(json)}`);
    }
    if (typeof json !== "object")
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], [
      "version",
      "players",
      "letterCounts",
      "letterValues",
      "boardLayout",
      "bingoBonus",
      "rackCapacity",
      "tileSystemType",
      "tileSystemSettings",
      "dictionaryType",
      "dictionarySettings"
    ]))
      fail("Wrong keys or key order");
    const protocolVersion = PROTOCOL_VERSIONS[json.version];
    if (!protocolVersion)
      fail(`Unsupported protocol version "${json.version}"`);
    if (!Array.isArray(json.players))
      fail("`players` is not an array");
    if (!Array.isArray(json.boardLayout))
      fail("`boardLayout` is not an array");
    if (!json.boardLayout.every((s) => typeof s === "string"))
      fail("`boardLayout` contains a non-string");
    if (typeof json.bingoBonus !== "number")
      fail("`bingoBonus` is not a number");
    if (typeof json.rackCapacity !== "number")
      fail("`rackCapacity` is not a number");
    if (json.tileSystemType !== "honor")
      fail(`Unsupported tile system type "${json.tileSystemType}"`);
    if (typeof json.tileSystemSettings !== "object")
      fail("`tileSystemSettings` is not an object");
    if (json.tileSystemSettings === null)
      fail("`tileSystemSettings` is null");
    if (typeof json.tileSystemSettings.seed !== "string")
      fail("`tileSystemSettings.seed` is not a string");
    const dictionaryType = json.dictionaryType === "custom" ? "wordlist" : json.dictionaryType;
    if (!["permissive", "consensus", "wordlist", "freeapi"].includes(dictionaryType)) {
      fail(`Unsupported dictionary type "${dictionaryType}"`);
    }
    const settings = Settings.forLanguage("");
    settings.version = PROTOCOL_VERSION;
    settings.players = json.players.map(Player.fromJSON);
    settings.letterCounts = checkLetterToNumberMap("letterCounts", json.letterCounts);
    settings.letterValues = checkLetterToNumberMap("letterValues", json.letterValues);
    settings.boardLayout = json.boardLayout;
    settings.bingoBonus = json.bingoBonus;
    settings.rackCapacity = json.rackCapacity;
    settings.tileSystemType = json.tileSystemType;
    settings.tileSystemSettings = json.tileSystemSettings;
    settings.dictionaryType = dictionaryType;
    settings.dictionarySettings = json.dictionarySettings;
    return settings;
  }
}
function checkLetterToNumberMap(name, json) {
  function fail(msg) {
    throw new TypeError(`Invalid Settings.${name} serialization: ${msg}`);
  }
  if (!Array.isArray(json)) {
    if (typeof json !== "object")
      fail(`Type is "${typeof json}", not "object" as expected.`);
    json = [...Object.entries(json)];
  }
  json.forEach(([k, v2]) => {
    if (typeof k !== "string")
      fail(`Letter ${k} has type "${typeof k}", not "string" as expected.`);
    if (typeof v2 !== "number")
      fail(`Letter ${k} has value ${v2}, not a number as expected.`);
  });
  return new Map(json);
}
function mapToJSON(map) {
  if (!(map instanceof Map))
    return Object.entries(map);
  return [...map.entries()];
}

// game/tiles_state.ts
function checkIndicesForExchange(length, ...indices) {
  if ([...new Set(indices)].length !== indices.length) {
    throw new Error(`exchangeTileIndices contains duplicates: ${indices}`);
  }
  checkIndices(length, ...indices);
  return [...indices];
}

// game/turn.ts
function toTurnNumber(n) {
  return n;
}
function fromTurnNumber(turnNumber) {
  return turnNumber;
}
function nextTurnNumber(turnNumber) {
  return toTurnNumber(1 + fromTurnNumber(turnNumber));
}

class Turn {
  playerId;
  turnNumber;
  move;
  mainWord;
  row;
  col;
  vertical;
  blanks;
  extraParams;
  constructor(playerId, turnNumber, move) {
    this.playerId = playerId;
    this.turnNumber = turnNumber;
    this.move = move;
    if ("playTiles" in move && "exchangeTileIndices" in move) {
      throw new Error(`Can't exchange and play tiles on the same turn. Turn number is ${turnNumber}.`);
    }
  }
}
function getPlayerForTurnNumber(players, turnNumber) {
  return players[(fromTurnNumber(turnNumber) - 1) % players.length];
}
function updateTurnHistory({
  history,
  nextTurnNumber: nextTurnNumber2,
  finalTurnNumber,
  turns
}) {
  for (const turn of turns) {
    if (fromTurnNumber(turn.turnNumber) >= nextTurnNumber2) {
      break;
    }
    if (history.length) {
      const latestTurnNumber = fromTurnNumber(history.slice(-1)[0].turnNumber);
      if (fromTurnNumber(turn.turnNumber) <= latestTurnNumber)
        continue;
    }
    const params = new URLSearchParams;
    const addExtra = () => {
      if (turn.extraParams) {
        for (const [key, value] of turn.extraParams) {
          params.set(key, value);
        }
      }
    };
    if ("playTiles" in turn.move) {
      params.set("wl", `${turn.row}.${turn.col}`);
      addExtra();
      if (turn.blanks?.length)
        params.set("bt", turn.blanks.join("."));
      params.set(turn.vertical ? "wv" : "wh", turn.mainWord);
    } else if ("exchangeTileIndices" in turn.move) {
      params.set("ex", turn.move.exchangeTileIndices.join("."));
      addExtra();
    }
    history.push({ turnNumber: turn.turnNumber, paramsStr: String(params) });
    if (turn.turnNumber === finalTurnNumber)
      break;
  }
}

// game/tile.ts
var MIN_TILE_VALUE = 0;
var MAX_TILE_VALUE = 999999;

class Tile {
  letter;
  value;
  constructor({ letter, value }) {
    if (value !== Math.floor(value) || value < MIN_TILE_VALUE || value > MAX_TILE_VALUE) {
      throw new RangeError(`Invalid Tile value: ${value}`);
    }
    this.letter = letter;
    this.value = value;
  }
  get isBlank() {
    return this.letter === "";
  }
  equals(other) {
    return this.letter === other.letter && this.value === other.value;
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    return `${this.letter}:${this.value}`;
  }
  static fromJSON(json) {
    if (typeof json === "string") {
      const match = json.match(/(.*):([0-9]+)$/s);
      if (match) {
        const letter = match[1];
        const value = parseInt(match[2]);
        return new Tile({ letter, value });
      }
    }
    throw new TypeError(`invalid Tile serialization: ${JSON.stringify(json)}`);
  }
}
function isBoardPlacementRow(row) {
  return typeof row === "number";
}
function isBoardPlacement(tilePlacement) {
  return isBoardPlacementRow(tilePlacement.row);
}
function makeTiles({ letterCounts, letterValues }) {
  const tiles = [];
  for (const [letter, count] of letterCounts) {
    tiles.push(...Array(count).fill(new Tile({ letter, value: letterValues.get(letter) || 0 })));
  }
  return tiles;
}

// game/serializable.ts
function toJSON(s) {
  if (s && typeof s === "object" && "toJSON" in s)
    return s.toJSON();
  return s;
}

// game/bag.ts
class Bag {
  randomGenerator;
  tiles;
  constructor([...tiles], randomGenerator, shuffle = true) {
    this.randomGenerator = randomGenerator;
    this.tiles = tiles;
    if (shuffle)
      this.shuffle(0);
  }
  get size() {
    return this.tiles.length;
  }
  draw(numberOfTiles) {
    this.checkEnoughTiles(numberOfTiles);
    return this.tiles.splice(-numberOfTiles);
  }
  exchange(tilesToExchange) {
    const numberOfTiles = tilesToExchange.length;
    this.checkEnoughTiles(numberOfTiles);
    const drawnTiles = this.tiles.splice(-numberOfTiles, numberOfTiles, ...tilesToExchange);
    this.shuffle(this.size - numberOfTiles);
    return drawnTiles;
  }
  checkEnoughTiles(numberOfTilesNeeded) {
    if (numberOfTilesNeeded > this.size) {
      throw new RangeError(`Not enough tiles in bag: ${this.size} < ${numberOfTilesNeeded}`);
    }
  }
  shuffle(indexOfFirstNewTile) {
    for (let i = Math.max(1, indexOfFirstNewTile);i <= this.size; ++i) {
      const j = Math.floor(this.randomGenerator.random() * i);
      [this.tiles[i - 1], this.tiles[j]] = [this.tiles[j], this.tiles[i - 1]];
    }
  }
  toJSON() {
    return {
      tiles: this.tiles.map(toJSON),
      prng: this.randomGenerator.toJSON()
    };
  }
}

// game/mulberry32_prng.ts
class Mulberry32Prng {
  seed;
  constructor(seed) {
    this.seed = Number(BigInt(seed) & 0xFFFFFFFFn);
  }
  random() {
    this.seed = this.seed + 1831565813 >>> 0;
    let t = this.seed;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  toJSON() {
    return this.seed;
  }
  static fromJSON(json) {
    if (typeof json !== "number") {
      throw new TypeError(`Invalid serialized Mulberry32Prng: ${JSON.stringify(json)}`);
    }
    return new Mulberry32Prng(json);
  }
}

// game/honor_system_bag.ts
class HonorSystemBag extends Bag {
  constructor(randomSeed, tiles, shuffle = true, randomGenerator = new Mulberry32Prng(BigInt(randomSeed))) {
    super(tiles, randomGenerator, shuffle);
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in HonorSystemBag serialization: ${JSON.stringify(json)}`);
    }
    if (typeof json !== "object")
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], ["tiles", "prng"]))
      fail("Wrong keys or key order");
    if (!Array.isArray(json.tiles))
      fail("Tiles are not an array.");
    return new HonorSystemBag("", json.tiles.map(Tile.fromJSON), false, Mulberry32Prng.fromJSON(json.prng));
  }
}

// game/events.ts
class BagEvent extends CustomEvent {
}

class TileEvent extends CustomEvent {
}

class GameEvent extends CustomEvent {
}

class BoardEvent extends CustomEvent {
}

// game/honor_system_tiles_state.ts
class HonorSystemTilesState extends EventTarget {
  rackCapacity;
  numberOfTurnsPlayed;
  racks;
  bag;
  isGameOver;
  constructor(players, tileSystemSettings, tiles, rackCapacity, numberOfTurnsPlayed = 0, racks = new Map(players.map((player) => [player.id, []])), bag = new HonorSystemBag(tileSystemSettings.seed, tiles), isGameOver = false, init = true) {
    super();
    this.rackCapacity = rackCapacity;
    this.numberOfTurnsPlayed = numberOfTurnsPlayed;
    this.racks = racks;
    this.bag = bag;
    this.isGameOver = isGameOver;
    if (this.racks.size < players.length) {
      throw new Error(`The player IDs are not unique: ${players.map((player) => player.id)}`);
    }
    if (init)
      this.initRacks();
  }
  copyFrom(other) {
    if (!(other instanceof HonorSystemTilesState))
      throw new TypeError;
    this.numberOfTurnsPlayed = other.numberOfTurnsPlayed;
    this.racks = other.racks;
    this.bag = other.bag;
    this.isGameOver = other.isGameOver;
  }
  get numberOfTilesInBag() {
    return this.bag.size;
  }
  get stateId() {
    return this.numberOfTurnsPlayed;
  }
  countTiles(playerId) {
    return this.getRack(playerId).length;
  }
  getTiles(playerId) {
    return Promise.resolve([...this.getRack(playerId)]);
  }
  playTurns(...turnsToPlay) {
    for (const turn of turnsToPlay) {
      this.playOneTurn(turn);
      if (this.isGameOver)
        return Promise.resolve(toTurnNumber(this.numberOfTurnsPlayed));
    }
    return Promise.resolve(null);
  }
  playOneTurn(turn) {
    const rack = this.getRack(turn.playerId);
    const rackCopy = [...rack];
    if ("playTiles" in turn.move) {
      for (const tileToPlay of turn.move.playTiles) {
        const index = rackCopy.findIndex((rackTile) => rackTile.equals(tileToPlay.tile));
        if (index === -1) {
          throw new Error(`Player ${turn.playerId} does not hold tile ${tileToPlay.tile.toString()}`);
        }
        rackCopy.splice(index, 1);
      }
      const numberOfTilesToDraw = Math.min(rack.length - rackCopy.length, this.bag.size);
      const drawnTiles = this.bag.draw(numberOfTilesToDraw);
      for (const tile of drawnTiles) {
        this.dispatchEvent(new BagEvent("tiledraw", { detail: { playerId: turn.playerId, tile } }));
      }
      rackCopy.push(...drawnTiles);
      if (rackCopy.length === 0)
        this.isGameOver = true;
    } else if ("exchangeTileIndices" in turn.move) {
      const indicesOfTilesToExchange = checkIndicesForExchange(rackCopy.length, ...turn.move.exchangeTileIndices);
      indicesOfTilesToExchange.sort((a, b) => b - a);
      const tilesToExchange = [];
      for (const indexOfTileToExchange of indicesOfTilesToExchange) {
        tilesToExchange.push(...rackCopy.splice(indexOfTileToExchange, 1));
      }
      const newTiles = this.bag.exchange(tilesToExchange);
      for (const tile of tilesToExchange) {
        this.dispatchEvent(new BagEvent("tilereturn", { detail: { playerId: turn.playerId, tile } }));
      }
      for (const tile of newTiles) {
        this.dispatchEvent(new BagEvent("tiledraw", { detail: { playerId: turn.playerId, tile } }));
      }
      rackCopy.push(...newTiles);
    }
    rack.splice(0, rack.length, ...rackCopy);
    this.numberOfTurnsPlayed += 1;
  }
  getRack(playerId) {
    const rack = this.racks.get(playerId);
    if (rack === undefined) {
      throw new Error(`Unknown playerId: ${playerId}`);
    }
    return rack;
  }
  initRacks() {
    for (const [playerId, rack] of this.racks.entries()) {
      const drawnTiles = this.bag.draw(this.rackCapacity);
      for (const tile of drawnTiles) {
        this.dispatchEvent(new BagEvent("tiledraw", { detail: { playerId, tile } }));
      }
      rack.push(...drawnTiles);
    }
  }
  toJSON() {
    const racks = [...this.racks.entries().map(([playerId, rack]) => [playerId, rack.map((tile) => tile.toJSON())])];
    return {
      rackCapacity: this.rackCapacity,
      numberOfTurnsPlayed: this.numberOfTurnsPlayed,
      bag: this.bag.toJSON(),
      racks
    };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in HonorSystemTileState serialization: ${JSON.stringify(json)}`);
    }
    if (!(typeof json === "object"))
      fail("Not an object");
    if (typeof json.rackCapacity !== "number")
      fail("rackCapacity is not a number");
    if (typeof json.numberOfTurnsPlayed !== "number")
      fail("numberOfTurnsPlayed is not a number");
    if (!Array.isArray(json.racks))
      fail("Racks are not in an array.");
    const bag = HonorSystemBag.fromJSON(json.bag);
    const racks = new Map;
    let isGameOver = false;
    for (const racksEntry of json.racks) {
      if (!Array.isArray(racksEntry))
        fail("Rack list entry is not an array");
      if (racksEntry.length !== 2)
        fail("Rack list entry length is not 2");
      const [playerId, rackJson] = racksEntry;
      if (typeof playerId !== "string")
        fail("Rack list playerId is not a string");
      if (!Array.isArray(rackJson))
        fail("Rack is not an array");
      if (rackJson.length > json.rackCapacity)
        fail("Rack length is over capacity");
      if (rackJson.length === 0)
        isGameOver = true;
      racks.set(playerId, rackJson.map(Tile.fromJSON));
    }
    return new HonorSystemTilesState([], { seed: "" }, [], json.rackCapacity, json.numberOfTurnsPlayed, racks, bag, isGameOver, false);
  }
}

// i18n.ts
var {readFileSync} = (() => ({}));
// i18n/en.json
var en_default = {
  error: {
    word_placement: {
      no_tiles: "Drag some tiles onto the board, and try again.",
      blank_tiles_must_be_assigned_letters: "Blank tiles must be assigned letters.",
      non_blank_tiles_cannot_be_assigned_letters: "Non-blank tiles cannot be assigned letters.",
      tiles_not_in_line: "Tiles are not in a line.",
      square_occupied: "Square ${row},${col} is occupied.",
      line_with_gaps: "Tiles form a line with gaps between them.",
      no_single_letter_words: "No single-letter words accepted.",
      must_connect_to_existing: "Tiles must connect to existing words or cover the center square."
    },
    play_rejected: {
      not_words_in_dictionary: "Not words in ${dictionaryName}: ${invalidWords}.",
      play_rejected: "${message} Play rejected.",
      word_not_in_dictionary: 'Word "${word}" ${status} in ${dictionaryName}.',
      status: {
        not_found: "not found",
        has_no_definition: "has no definition"
      }
    },
    url: {
      protocol_not_supported: "Protocol version not supported: ${version}",
      no_random_seed: "No random seed in URL.",
      unknown_dictionary_type: 'Unknown dictionary type: "${type}".',
      custom_dictionary_requires_url: "Custom dictionary requires a URL.",
      invalid_tile_distribution: "Invalid tile distribution specifier: ${specifier}",
      duplicate_letter_config: 'Duplicate configuration for letter "${letter}".',
      tn_not_a_number: '"tn" param is not a turn number: "${param}"',
      both_word_and_exchange: "Found both word and exchange data for turn ${turnNumber}.",
      invalid_bt_component: 'Invalid "bt" parameter component: "${component}"',
      duplicate_bt_index: "Duplicate blank tile assignment index: bt=${param}",
      bt_index_out_of_range: 'Blank tile assignment index out of range: no "${word}"[${index}].',
      invalid_wl_param: 'Invalid "wl" parameter: "${param}"',
      word_out_of_bounds: "Attempted to play a word out of bounds: ${row},${col}.",
      wrong_letter: 'Word requires "${requiredLetter}" at ${row},${col}, but "${actualLetter}" is there.',
      invalid_letter: 'Attempt to play an invalid letter: "${letter}"',
      bt_index_range: '"bt" parameter has index ${index} out of range 0-${maxIndex}.',
      incomplete_turn_data: "Incomplete data for turn ${turnNumber}: wl=${wl} ${direction}=${word} bt=${bt}",
      invalid_exchange_index: 'Invalid exchange tile index: "${index}"',
      invalid_player_id: 'Invalid turn URL: Player ID "${id}" should be in 1-${maxId}.',
      duplicate_bt_param: 'Duplicate "bt" parameter for turn ${turnNumber}.',
      duplicate_word_params: "Duplicate word parameters for turn ${turnNumber}.",
      unrecognized_param: 'Unrecognized parameter name: "${param}"'
    }
  },
  ui: {
    title: "Sharewords",
    buttons: {
      play_word: "Play Word",
      pass_turn: "Pass Turn",
      exchange_count: "Exchange ${count}",
      recall_tiles: "Recall Tiles",
      game_setup: "Game Setup",
      add_player: "Add Player",
      remove_player: "-",
      start_game_with_settings: "Start Game with Settings",
      cancel_settings: "Cancel",
      ok: "OK"
    },
    settings: {
      players: "Players",
      dictionary: "Dictionary",
      dictionary_options: {
        permissive: "Anything is a word",
        freeapi: "Free Dictionary API",
        wordlist: "SWDICT word list"
      },
      dictionary_url_label: "URL:",
      tile_distribution: "Tile Distribution",
      tile_distribution_options: {
        custom: "Custom"
      },
      bingo_bonus: "Bingo Bonus",
      random_seed: "Random Seed",
      random_seed_random_label: "Random?",
      player_placeholder: "Player ${index}"
    },
    bag_tile_count: "Tiles in bag: ${count}",
    dialog: {
      copy_turn_url: "Copy turn URL to clipboard",
      confirm_title: "Confirm",
      play_word_title: "Play word?",
      play_word_details: "${word} for ${score} points"
    },
    game: {
      join_link: "join"
    }
  }
};

// i18n.ts
var [DEFAULT_LANG, DEFAULT_TRANSLATIONS] = ["en", en_default];
var translations = {};
async function loadTranslations(...languages) {
  for (const lang of languages) {
    if (lang === DEFAULT_LANG) {
      translations = DEFAULT_TRANSLATIONS;
      return;
    }
    try {
      if (typeof window !== "undefined" && typeof window.fetch === "function") {
        const response = await fetch(`i18n/${lang}.json`);
        if (!response.ok) {
          console.warn(`Language '${lang}' not supported.`);
        } else {
          translations = await response.json();
          return;
        }
      } else {
        const path = `i18n/${lang}.json`;
        try {
          const data = readFileSync(path, "utf-8");
          translations = JSON.parse(data);
          return;
        } catch (error) {
          console.warn(`Language '${lang}' not supported.`);
        }
      }
    } catch (error) {
      console.error(error);
    }
  }
  console.warn(`Configured languages not supported. Falling back to ${DEFAULT_LANG}.`);
  translations = DEFAULT_TRANSLATIONS;
}
function t(key, params) {
  const keys = key.split(".");
  let value = translations;
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      return key;
    }
  }
  if (typeof value === "string") {
    if (params) {
      return value.replace(/\$\{(\w+)\}/g, (_, placeholder) => {
        return params[placeholder] !== undefined ? String(params[placeholder]) : `{${placeholder}}`;
      });
    }
    return value;
  }
  return key;
}

// game/game_params.ts
class UrlError extends Error {
  constructor(message) {
    super(message);
    this.name = "UrlError";
  }
}
function getBagParam(settings) {
  let bagParam = [...settings.letterCounts.entries()].map(([letter, count]) => `${letter}-${count}-${settings.letterValues.get(letter) ?? 0}`).join(".");
  const boardSize = settings.boardLayout.reduce((acc, row) => acc + row.length, 0);
  const tileCount = Math.round(boardSize / (15 * 15) * 100);
  for (const { code: bagLanguage } of getBagLanguages()) {
    const defaults = getBagDefaults(bagLanguage, tileCount);
    const settingsLetters = new Set(settings.letterCounts.keys());
    const defaultLetters = new Set(defaults.letterCounts.keys());
    const diffParts = [];
    for (const letter of settingsLetters) {
      if (!defaultLetters.has(letter)) {
        const count = settings.letterCounts.get(letter);
        const value = settings.letterValues.get(letter) ?? 0;
        diffParts.push(`${letter}-${count}-${value}`);
      }
    }
    for (const letter of defaultLetters) {
      const settingsHasLetter = settingsLetters.has(letter);
      const count = settings.letterCounts.get(letter);
      const value = settings.letterValues.get(letter);
      const defaultCount = defaults.letterCounts.get(letter);
      const defaultValue = defaults.letterValues.get(letter);
      if (settingsHasLetter && count === defaultCount && value === defaultValue) {
        continue;
      }
      if (!settingsHasLetter) {
        diffParts.push(`${letter}-`);
        continue;
      }
      let part = letter;
      const countIsDefault = count === defaultCount;
      const valueIsDefault = value === defaultValue;
      if (!countIsDefault && !valueIsDefault) {
        part += `-${count}-${value}`;
      } else if (!countIsDefault) {
        part += `-${count}`;
      } else if (count !== 0) {
        part += `--${value}`;
      }
      diffParts.push(part);
    }
    diffParts.sort();
    const abbreviatedBagParam = [bagLanguage, ...diffParts].join(".");
    if (abbreviatedBagParam.length < bagParam.length) {
      bagParam = abbreviatedBagParam;
    }
  }
  return bagParam;
}
function gameParamsFromSettings(settings) {
  const params = new URLSearchParams;
  const defaults = Settings.forLanguage("");
  params.set("v", settings.version);
  if (!playersEqual(settings.players, defaults.players)) {
    settings.players.forEach((p, index) => {
      params.set(`p${index + 1}n`, p.name);
    });
  }
  if (!arraysEqual(settings.boardLayout, defaults.boardLayout, false)) {
    params.set("board", settings.boardLayout.join("-"));
  }
  if (settings.bingoBonus !== defaults.bingoBonus) {
    params.set("bingo", String(settings.bingoBonus));
  }
  const bagParam = getBagParam(settings);
  if (bagParam) {
    params.set("bag", bagParam);
  }
  if (settings.rackCapacity !== defaults.rackCapacity) {
    params.set("racksize", String(settings.rackCapacity));
  }
  if (settings.tileSystemType === "honor") {
    params.set("seed", settings.tileSystemSettings.seed);
  }
  if (settings.dictionaryType !== defaults.dictionaryType) {
    params.set("dt", settings.dictionaryType);
  }
  if (typeof settings.dictionarySettings === "string") {
    params.set("ds", settings.dictionarySettings);
  }
  return params;
}
function parseBagParam(bagParam, boardLayout) {
  const boardSize = boardLayout.reduce((acc, row) => acc + row.length, 0);
  const tileCount = Math.round(boardSize / (15 * 15) * 100);
  const bagSettings = getBagDefaults("");
  const lettersSeen = new Set;
  function mergeLetterConfig(letter, count, value) {
    if (count === undefined && value === undefined) {
      bagSettings.letterCounts.delete(letter);
      bagSettings.letterValues.delete(letter);
    } else {
      const oldCount = bagSettings.letterCounts.get(letter);
      const oldValue = bagSettings.letterValues.get(letter);
      bagSettings.letterCounts.set(letter, count ?? oldCount ?? 1);
      bagSettings.letterValues.set(letter, value ?? oldValue ?? 1);
    }
  }
  for (const config of bagParam.split(".")) {
    if (config.match(/^[a-z]/)) {
      const bagLanguage = config;
      const defaults = getBagDefaults(bagLanguage, tileCount);
      if (!defaults) {
        throw new UrlError(t("error.url.invalid_tile_distribution", { specifier: bagLanguage }));
      }
      defaults.letterCounts.entries().forEach(([letter, count]) => {
        mergeLetterConfig(letter, count, defaults.letterValues.get(letter));
      });
    } else {
      const match = config.match(/^(?<letter>.*?)(?:-(?<count>(?:\d+$|\d*))(?:-(?<value>\d+))?)?$/u);
      if (!match) {
        throw new Error(`Letter config pattern does not match "${config}".`);
      }
      const g = match.groups;
      const letter = g.letter;
      if (lettersSeen.has(letter)) {
        throw new UrlError(t("error.url.duplicate_letter_config", { letter }));
      }
      lettersSeen.add(letter);
      const count = g.count === "" || g.count === undefined ? undefined : parseInt(g.count, 10);
      const value = g.value === "" || g.value === undefined ? undefined : parseInt(g.value, 10);
      mergeLetterConfig(letter, count, value);
    }
  }
  return bagSettings;
}
function parseGameParams(allParams) {
  const gameParams = new URLSearchParams;
  const turnParams = new URLSearchParams;
  for (const [name, value] of allParams) {
    if (turnParams.size || name === "tn") {
      turnParams.append(name, value);
    } else {
      gameParams.append(name, value);
    }
  }
  const settings = Settings.forLanguage("");
  const vParam = gameParams.get("v");
  if (vParam && vParam !== settings.version) {
    throw new UrlError(t("error.url.protocol_not_supported", { version: vParam }));
  }
  const gidParam = gameParams.get("gid");
  if (gidParam)
    settings.gameId = toGameId(gidParam);
  const newPlayers = [];
  for (let playerNumber = 1;; ++playerNumber) {
    const pnParam = gameParams.get(`p${playerNumber}n`);
    if (!pnParam)
      break;
    newPlayers.push(new Player({ id: String(playerNumber), name: pnParam.slice(0, settings.maxPlayerNameLength) }));
  }
  if (newPlayers.length)
    settings.players = newPlayers;
  const boardParam = gameParams.get("board");
  if (boardParam)
    settings.boardLayout = boardParam.split("-");
  const bagParam = gameParams.get("bag");
  if (bagParam) {
    const parsed = parseBagParam(bagParam, settings.boardLayout);
    settings.letterCounts = parsed.letterCounts;
    settings.letterValues = parsed.letterValues;
  }
  const bingoParam = gameParams.get("bingo");
  if (bingoParam)
    settings.bingoBonus = parseInt(bingoParam, 10);
  const racksizeParam = gameParams.get("racksize");
  if (racksizeParam)
    settings.rackCapacity = parseInt(racksizeParam, 10);
  const seedParam = gameParams.get("seed");
  if (!seedParam)
    throw new UrlError(t("error.url.no_random_seed"));
  settings.tileSystemSettings = { seed: seedParam };
  const dtParam = gameParams.get("dt");
  if (dtParam === "permissive" || dtParam === "freeapi" || dtParam === "wordlist") {
    settings.dictionaryType = dtParam;
  } else if (dtParam) {
    throw new UrlError(t("error.url.unknown_dictionary_type", { type: dtParam }));
  }
  const dsParam = gameParams.get("ds");
  if (dsParam)
    settings.dictionarySettings = dsParam;
  else if (settings.dictionaryType === "wordlist") {
    throw new UrlError(t("error.url.custom_dictionary_requires_url"));
  }
  let playerId = gameParams.get("pid") ?? undefined;
  if (!playerId) {
    const urlTurnNumber = parseInt(turnParams.get("tn"), 10) || 1;
    const turnNumber = toTurnNumber(urlTurnNumber + turnParams.getAll("wl").length + turnParams.getAll("ex").length);
    playerId = getPlayerForTurnNumber(settings.players, turnNumber).id;
    console.log(`Joining as Player ${playerId}.`);
  }
  return { settings, playerId, turnParams };
}
function playersEqual(ps1, ps2) {
  if (ps1.length !== ps2.length)
    return false;
  for (const index in ps1) {
    if (!ps1[index].equals(ps2[index]))
      return false;
  }
  return true;
}

// game/board.ts
class Square {
  row;
  col;
  letterBonus;
  wordBonus;
  tile;
  assignedLetter;
  constructor({ row, col, letterBonus, wordBonus }) {
    this.row = row;
    this.col = col;
    this.letterBonus = letterBonus;
    this.wordBonus = wordBonus;
  }
  get letter() {
    return this.assignedLetter || this.tile?.letter;
  }
  get value() {
    return this.tile?.value;
  }
}
var CHAR_TO_BONUS = new Map([
  [".", [1, 1]],
  ["d", [2, 1]],
  ["t", [3, 1]],
  ["D", [1, 2]],
  ["T", [1, 3]]
]);

class InvalidBonusSquareLayout extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidBonusSquareLayout";
  }
}
function parseRowStrings(rowStrings) {
  const firstRowString = rowStrings[0];
  if (!firstRowString || !rowStrings.every((s) => s.length === firstRowString.length)) {
    throw new InvalidBonusSquareLayout(`Row strings do not form a rectangle: ${rowStrings.join(`
`)}.`);
  }
  return rowStrings.map((rowString, row) => rowString.split("").map((character, col) => {
    const bonus = CHAR_TO_BONUS.get(character);
    if (!bonus)
      throw new InvalidBonusSquareLayout(`Unrecognized square type: ${character}`);
    const [letterBonus, wordBonus] = bonus;
    return new Square({ row, col, letterBonus, wordBonus });
  }));
}
function generateRowStrings(squares) {
  return squares.map((row) => row.map((square) => {
    const pair = [square.letterBonus, square.wordBonus];
    const entry = CHAR_TO_BONUS.entries().find(([char, bonus]) => bonus[0] === pair[0] && bonus[1] === pair[1]);
    if (entry === undefined)
      throw new Error(`Unrecognized bonus multiplier pair: ${pair}`);
    return entry[0];
  }).join(""));
}

class WordPlacementError extends Error {
  constructor(message) {
    super(message);
    this.name = "WordPlacementError";
  }
}

class Board extends EventTarget {
  squares;
  scores = new Map;
  centerSquare;
  constructor(...rowStrings) {
    super();
    this.squares = parseRowStrings(rowStrings);
    const centerRow = this.squares[this.squares.length >> 1];
    const centerSquare = centerRow?.[centerRow.length >> 1];
    if (!centerSquare)
      throw new Error(`Board lacks a center square: ${rowStrings}`);
    this.centerSquare = centerSquare;
  }
  copyFrom(other) {
    this.squares.forEach((rowSquares, row) => {
      rowSquares.forEach((square, col) => {
        const otherSquare = other.squares[row][col];
        square.tile = otherSquare.tile;
        square.assignedLetter = otherSquare.assignedLetter;
      });
    });
    this.scores = other.scores;
  }
  checkWordPlacement(...placements) {
    const anyPlacement = placements[0];
    if (!anyPlacement)
      throw new WordPlacementError(t("error.word_placement.no_tiles"));
    for (const placement of placements) {
      if (placement.tile.isBlank && !placement.assignedLetter) {
        throw new WordPlacementError(t("error.word_placement.blank_tiles_must_be_assigned_letters"));
      }
      if (!placement.tile.isBlank && placement.assignedLetter) {
        throw new WordPlacementError(t("error.word_placement.non_blank_tiles_cannot_be_assigned_letters"));
      }
    }
    const mainDir = { x: 0, y: 0 };
    const tilesInOneRow = placements.every((tile) => tile.row === anyPlacement.row);
    if (tilesInOneRow && (placements.length > 1 || this.squares[anyPlacement.row]?.[anyPlacement.col - 1]?.tile || this.squares[anyPlacement.row]?.[anyPlacement.col + 1]?.tile)) {
      mainDir.x = 1;
      placements.sort((a, b) => a.col - b.col);
    } else if (placements.every((tile) => tile.col === anyPlacement.col)) {
      mainDir.y = 1;
      placements.sort((a, b) => a.row - b.row);
    } else {
      throw new WordPlacementError(t("error.word_placement.tiles_not_in_line"));
    }
    const crossDir = { x: mainDir.y, y: mainDir.x };
    const firstPlacement = placements[0];
    if (!firstPlacement)
      throw new Error("Lost a tile.");
    let { row: mainRow, col: mainCol } = firstPlacement;
    while (this.squares[mainRow - mainDir.y]?.[mainCol - mainDir.x]?.tile) {
      mainRow -= mainDir.y;
      mainCol -= mainDir.x;
    }
    const mainStartRow = mainRow;
    const mainStartCol = mainCol;
    const mainWordTileContent = [];
    const crossWords = [];
    const blanks = [];
    let placementIndex = 0;
    let mainWordMultiplier = 1, mainWordScore = 0, crossWordsScore = 0;
    while (true) {
      const mainSquare = this.squares[mainRow]?.[mainCol];
      if (!mainSquare)
        break;
      let mainLetter, mainValue, wordMultiplier;
      const placement = placements[placementIndex];
      if (placement && placement.row === mainRow && placement.col === mainCol) {
        if (mainSquare.tile) {
          throw new WordPlacementError(t("error.word_placement.square_occupied", { row: mainRow, col: mainCol }));
        }
        placementIndex += 1;
        if (placement.assignedLetter) {
          blanks.push(mainWordTileContent.length);
          mainLetter = placement.assignedLetter;
        } else {
          mainLetter = placement.tile.letter;
        }
        mainValue = mainSquare.letterBonus * placement.tile.value;
        wordMultiplier = mainSquare.wordBonus;
        mainWordMultiplier *= wordMultiplier;
        let crossRow = mainRow, crossCol = mainCol;
        while (this.squares[crossRow - crossDir.y]?.[crossCol - crossDir.x]?.tile) {
          crossRow -= crossDir.y;
          crossCol -= crossDir.x;
        }
        const crossWordTileContent = [];
        let crossWordScore = 0;
        while (true) {
          const crossSquare = this.squares[crossRow]?.[crossCol];
          if (crossRow === mainRow && crossCol === mainCol) {
            crossWordTileContent.push(mainLetter);
            crossWordScore += mainValue;
          } else if (crossSquare?.tile) {
            crossWordTileContent.push(crossSquare.letter);
            crossWordScore += crossSquare.tile.value;
          } else {
            break;
          }
          crossRow += crossDir.y;
          crossCol += crossDir.x;
        }
        if (crossWordTileContent.length > 1) {
          crossWords.push(crossWordTileContent.join(""));
          crossWordsScore += crossWordScore * wordMultiplier;
        }
      } else if (mainSquare.tile) {
        mainLetter = mainSquare.assignedLetter || mainSquare.tile.letter;
        mainValue = mainSquare.tile.value;
        wordMultiplier = 1;
      } else {
        break;
      }
      mainWordTileContent.push(mainLetter);
      mainWordScore += mainValue;
      mainRow += mainDir.y;
      mainCol += mainDir.x;
    }
    mainWordScore *= mainWordMultiplier;
    if (placementIndex < placements.length) {
      throw new WordPlacementError(t("error.word_placement.line_with_gaps"));
    }
    if (mainWordTileContent.length === 1) {
      throw new WordPlacementError(t("error.word_placement.no_single_letter_words"));
    }
    if (!crossWords.length && mainWordTileContent.length === placements.length) {
      if (!placements.some((tile) => tile.row === this.centerSquare.row && tile.col === this.centerSquare.col)) {
        throw new WordPlacementError(t("error.word_placement.must_connect_to_existing"));
      }
    }
    const mainWordForValidation = mainWordTileContent.join("");
    const mainWordForUrl = mainWordTileContent.every((tc) => [...tc].length === 1) ? mainWordForValidation : mainWordTileContent.join(".");
    return {
      wordsFormed: [mainWordForValidation, ...crossWords],
      score: mainWordScore + crossWordsScore,
      mainWordForUrl,
      row: mainStartRow,
      col: mainStartCol,
      vertical: Boolean(mainDir.y),
      blanks
    };
  }
  getWordsAt(row, col) {
    const words = [];
    const square = this.squares[row]?.[col];
    if (!square?.tile) {
      return [];
    }
    let startCol = col;
    while (this.squares[row]?.[startCol - 1]?.tile) {
      startCol--;
    }
    let endCol = col;
    while (this.squares[row]?.[endCol + 1]?.tile) {
      endCol++;
    }
    if (startCol !== endCol) {
      let word = "";
      for (let c = startCol;c <= endCol; c++) {
        word += this.squares[row][c].letter;
      }
      words.push(word);
    }
    let startRow = row;
    while (this.squares[startRow - 1]?.[col]?.tile) {
      startRow--;
    }
    let endRow = row;
    while (this.squares[endRow + 1]?.[col]?.tile) {
      endRow++;
    }
    if (startRow !== endRow) {
      let word = "";
      for (let r = startRow;r <= endRow; r++) {
        word += this.squares[r][col].letter;
      }
      words.push(word);
    }
    return words;
  }
  placeTiles(...placements) {
    for (const placement of placements) {
      const square = this.squares[placement.row]?.[placement.col];
      if (!square)
        throw new Error(`Invalid board coordinates: ${placement.row},${placement.col}.`);
      if (square.tile)
        throw new Error(`Square ${placement.row}, ${placement.col} is occupied.`);
    }
    for (const placement of placements) {
      const square = this.squares[placement.row]?.[placement.col];
      if (square) {
        square.tile = placement.tile;
        square.assignedLetter = placement.assignedLetter;
        this.dispatchEvent(new BoardEvent("tileplaced", { detail: { placement } }));
      }
    }
  }
  toJSON() {
    const rows = generateRowStrings(this.squares);
    const tiles = [];
    this.squares.forEach((row) => row.forEach((square) => {
      if (square.tile) {
        const result = [square.row, square.col, square.tile.toJSON()];
        if (square.assignedLetter)
          result.push(square.assignedLetter);
        tiles.push(result);
      }
    }));
    const scores = [...this.scores.entries()];
    return { rows, tiles, scores };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in Board serialization: ${JSON.stringify(json)}`);
    }
    if (!(typeof json === "object"))
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], ["rows", "tiles", "scores"]))
      fail("Wrong keys or key order");
    if (!Array.isArray(json.rows))
      fail("Rows are not an array");
    if (!json.rows.every((row) => typeof row === "string"))
      fail("Row element is not a string");
    if (!Array.isArray(json.tiles))
      fail("Tiles are not an array");
    if (!Array.isArray(json.scores))
      fail("Scores are not an array");
    try {
      const board = new Board(...json.rows);
      for (const tile of json.tiles) {
        if (!Array.isArray(tile))
          fail("Tile is not an array");
        if (tile.length > 4)
          fail("Wrong size array for tile");
        const [row, col, tileJson, assignedLetter] = tile;
        if (!(typeof row === "number"))
          fail("Tile row is not a number");
        if (!(typeof col === "number"))
          fail("Tile col is not a number");
        const square = board.squares[row]?.[col];
        if (!square)
          fail("Tile coordinates are off the board");
        square.tile = Tile.fromJSON(tileJson);
        if (assignedLetter)
          square.assignedLetter = assignedLetter;
      }
      for (const element of json.scores) {
        if (!Array.isArray(element))
          fail("Score is not an array");
        if (element.length !== 2)
          fail("Wrong size array for score");
        const [playerId, score] = element;
        if (!(typeof playerId === "string"))
          fail("Player ID is not a string");
        if (!(typeof score === "number"))
          fail("Score is not a number");
        if (board.scores.has(playerId))
          fail("Duplicate Player ID in scores array");
        board.scores.set(playerId, score);
      }
      return board;
    } catch (e) {
      if (e instanceof InvalidBonusSquareLayout)
        fail("Invalid board layout");
      throw e;
    }
  }
}

// dict/code_point_compare.ts
function codePointCompare(left, right) {
  const leftIter = left[Symbol.iterator]();
  const rightIter = right[Symbol.iterator]();
  for (;; ) {
    const { value: leftChar } = leftIter.next();
    const { value: rightChar } = rightIter.next();
    if (leftChar === undefined && rightChar === undefined) {
      return 0;
    } else if (leftChar === undefined) {
      return -1;
    } else if (rightChar === undefined) {
      return 1;
    }
    const leftCodepoint = leftChar.codePointAt(0);
    const rightCodepoint = rightChar.codePointAt(0);
    if (leftCodepoint < rightCodepoint)
      return -1;
    if (leftCodepoint > rightCodepoint)
      return 1;
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0;shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3;shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0;i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3;i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  let bits = newBits(lo, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate(bits.lo, bits.hi);
  }
  const result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0;i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5;(b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
var protoInt64 = /* @__PURE__ */ makeInt64Support();
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808");
    const MAX = BigInt("9223372036854775807");
    const UMIN = BigInt("0");
    const UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`invalid int64: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`invalid uint64: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
function assertInt64String(value) {
  if (!/^-?[0-9]+$/.test(value)) {
    throw new Error("invalid int64: " + value);
  }
}
function assertUInt64String(value) {
  if (!/^[0-9]+$/.test(value)) {
    throw new Error("invalid uint64: " + value);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js
var symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
function getTextEncoding() {
  if (globalThis[symbol] == undefined) {
    const te = new globalThis.TextEncoder;
    const td = new globalThis.TextDecoder;
    globalThis[symbol] = {
      encodeUtf8(text) {
        return te.encode(text);
      },
      decodeUtf8(bytes) {
        return td.decode(bytes);
      },
      checkUtf8(text) {
        try {
          encodeURIComponent(text);
          return true;
        } catch (_) {
          return false;
        }
      }
    };
  }
  return globalThis[symbol];
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var FLOAT32_MAX = 340282346638528860000000000000000000000;
var FLOAT32_MIN = -340282346638528860000000000000000000000;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;

class BinaryWriter {
  constructor(encodeUtf8 = getTextEncoding().encodeUtf8) {
    this.encodeUtf8 = encodeUtf8;
    this.stack = [];
    this.chunks = [];
    this.buf = [];
  }
  finish() {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    let len = 0;
    for (let i = 0;i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0;i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  string(value) {
    let chunk = this.encodeUtf8(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  int64(value) {
    let tc = protoInt64.enc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
  sint64(value) {
    const tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
    varint64write(lo, hi, this.buf);
    return this;
  }
  uint64(value) {
    const tc = protoInt64.uEnc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
}

class BinaryReader {
  constructor(buf, decodeUtf8 = getTextEncoding().decodeUtf8) {
    this.decodeUtf8 = decodeUtf8;
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {}
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        for (;; ) {
          const [fn, wt] = this.tag();
          if (wt === WireType.EndGroup) {
            if (fieldNo !== undefined && fn !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  int32() {
    return this.uint32() | 0;
  }
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return protoInt64.dec(lo, hi);
  }
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function assertInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid int32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid uint32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg == "string") {
    const o = arg;
    arg = Number(arg);
    if (Number.isNaN(arg) && o !== "NaN") {
      throw new Error("invalid float32: " + o);
    }
  } else if (typeof arg != "number") {
    throw new Error("invalid float32: " + typeof arg);
  }
  if (Number.isFinite(arg) && (arg > FLOAT32_MAX || arg < FLOAT32_MIN))
    throw new Error("invalid float32: " + arg);
}

// dict/swdict.ts
function createBaseMacro() {
  return { clear: undefined, subword: undefined, backup: undefined, subroutine: undefined };
}
var Macro = {
  encode(message, writer = new BinaryWriter) {
    if (message.clear !== undefined) {
      Macro_Clear.encode(message.clear, writer.uint32(10).fork()).join();
    }
    if (message.subword !== undefined) {
      writer.uint32(18).string(message.subword);
    }
    if (message.backup !== undefined) {
      writer.uint32(24).uint64(message.backup);
    }
    if (message.subroutine !== undefined) {
      Macro_Subroutine.encode(message.subroutine, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMacro();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.clear = Macro_Clear.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.subword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.backup = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.subroutine = Macro_Subroutine.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      clear: isSet(object.clear) ? Macro_Clear.fromJSON(object.clear) : undefined,
      subword: isSet(object.subword) ? globalThis.String(object.subword) : undefined,
      backup: isSet(object.backup) ? globalThis.Number(object.backup) : undefined,
      subroutine: isSet(object.subroutine) ? Macro_Subroutine.fromJSON(object.subroutine) : undefined
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.clear !== undefined) {
      obj.clear = Macro_Clear.toJSON(message.clear);
    }
    if (message.subword !== undefined) {
      obj.subword = message.subword;
    }
    if (message.backup !== undefined) {
      obj.backup = Math.round(message.backup);
    }
    if (message.subroutine !== undefined) {
      obj.subroutine = Macro_Subroutine.toJSON(message.subroutine);
    }
    return obj;
  },
  create(base) {
    return Macro.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMacro();
    message.clear = object.clear !== undefined && object.clear !== null ? Macro_Clear.fromPartial(object.clear) : undefined;
    message.subword = object.subword ?? undefined;
    message.backup = object.backup ?? undefined;
    message.subroutine = object.subroutine !== undefined && object.subroutine !== null ? Macro_Subroutine.fromPartial(object.subroutine) : undefined;
    return message;
  }
};
function createBaseMacro_Clear() {
  return {};
}
var Macro_Clear = {
  encode(_, writer = new BinaryWriter) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMacro_Clear();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return Macro_Clear.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseMacro_Clear();
    return message;
  }
};
function createBaseMacro_Subroutine() {
  return { instructions: [] };
}
var Macro_Subroutine = {
  encode(message, writer = new BinaryWriter) {
    writer.uint32(10).fork();
    for (const v2 of message.instructions) {
      writer.uint64(v2);
    }
    writer.join();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMacro_Subroutine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.instructions.push(longToNumber(reader.uint64()));
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.instructions.push(longToNumber(reader.uint64()));
            }
            continue;
          }
          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      instructions: globalThis.Array.isArray(object?.instructions) ? object.instructions.map((e) => globalThis.Number(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => Math.round(e));
    }
    return obj;
  },
  create(base) {
    return Macro_Subroutine.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMacro_Subroutine();
    message.instructions = object.instructions?.map((e) => e) || [];
    return message;
  }
};
function createBaseMetadata() {
  return {
    name: "",
    description: "",
    clearInterval: 0,
    macros: [],
    subwordFrequencies: new Map,
    languageCodes: [],
    wordCount: 0
  };
}
var Metadata = {
  encode(message, writer = new BinaryWriter) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.clearInterval !== 0) {
      writer.uint32(24).uint64(message.clearInterval);
    }
    for (const v2 of message.macros) {
      Macro.encode(v2, writer.uint32(34).fork()).join();
    }
    message.subwordFrequencies.forEach((value, key) => {
      Metadata_SubwordFrequenciesEntry.encode({ key, value }, writer.uint32(42).fork()).join();
    });
    for (const v2 of message.languageCodes) {
      writer.uint32(50).string(v2);
    }
    if (message.wordCount !== 0) {
      writer.uint32(56).uint64(message.wordCount);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.clearInterval = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.macros.push(Macro.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          const entry5 = Metadata_SubwordFrequenciesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.subwordFrequencies.set(entry5.key, entry5.value);
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.languageCodes.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.wordCount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      clearInterval: isSet(object.clearInterval) ? globalThis.Number(object.clearInterval) : 0,
      macros: globalThis.Array.isArray(object?.macros) ? object.macros.map((e) => Macro.fromJSON(e)) : [],
      subwordFrequencies: isObject(object.subwordFrequencies) ? Object.entries(object.subwordFrequencies).reduce((acc, [key, value]) => {
        acc.set(key, Number(value));
        return acc;
      }, new Map) : new Map,
      languageCodes: globalThis.Array.isArray(object?.languageCodes) ? object.languageCodes.map((e) => globalThis.String(e)) : [],
      wordCount: isSet(object.wordCount) ? globalThis.Number(object.wordCount) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.clearInterval !== 0) {
      obj.clearInterval = Math.round(message.clearInterval);
    }
    if (message.macros?.length) {
      obj.macros = message.macros.map((e) => Macro.toJSON(e));
    }
    if (message.subwordFrequencies?.size) {
      obj.subwordFrequencies = {};
      message.subwordFrequencies.forEach((v2, k) => {
        obj.subwordFrequencies[k] = Math.round(v2);
      });
    }
    if (message.languageCodes?.length) {
      obj.languageCodes = message.languageCodes;
    }
    if (message.wordCount !== 0) {
      obj.wordCount = Math.round(message.wordCount);
    }
    return obj;
  },
  create(base) {
    return Metadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMetadata();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.clearInterval = object.clearInterval ?? 0;
    message.macros = object.macros?.map((e) => Macro.fromPartial(e)) || [];
    message.subwordFrequencies = (() => {
      const m = new Map;
      (object.subwordFrequencies ?? new Map).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.Number(value));
        }
      });
      return m;
    })();
    message.languageCodes = object.languageCodes?.map((e) => e) || [];
    message.wordCount = object.wordCount ?? 0;
    return message;
  }
};
function createBaseMetadata_SubwordFrequenciesEntry() {
  return { key: "", value: 0 };
}
var Metadata_SubwordFrequenciesEntry = {
  encode(message, writer = new BinaryWriter) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint64(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata_SubwordFrequenciesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },
  create(base) {
    return Metadata_SubwordFrequenciesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMetadata_SubwordFrequenciesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  }
};
function longToNumber(int64) {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isSet(value) {
  return value !== null && value !== undefined;
}

// dict/pointer.ts
class Pointer {
  uint8Array;
  _offset;
  constructor(uint8Array, _offset = 0) {
    this.uint8Array = uint8Array;
    this._offset = _offset;
    this.checkOffset(_offset);
  }
  get offset() {
    return this._offset;
  }
  get atEnd() {
    return this._offset >= this.uint8Array.length;
  }
  checkOffset(offset) {
    if (offset < 0 || offset !== Math.floor(offset)) {
      throw new Error(`Invalid Pointer offset: ${offset}`);
    }
    if (offset > this.uint8Array.length) {
      throw new RangeError(`Offset ${offset} is past the end of array of length ${this.uint8Array.length}`);
    }
  }
  checkEnd(bytes) {
    if (this._offset + bytes > this.uint8Array.length) {
      throw new RangeError(`Attempted to read past end of Uint8Array of length ${this.uint8Array.length}`);
    }
  }
  byte() {
    this.checkEnd(1);
    return this.uint8Array[this._offset++];
  }
  varintBigInt() {
    let ret = 0n, shift = 0n;
    while (true) {
      const byte = this.byte();
      ret += BigInt(byte & 127) << shift;
      if (!(byte & 128))
        return ret;
      shift += 7n;
    }
  }
  skipToVarint() {
    while (!this.atEnd) {
      if (!(this.uint8Array[this._offset] & 128))
        return;
      ++this._offset;
    }
  }
  skip(numberOfBytes) {
    const offset = this._offset + Number(numberOfBytes);
    this.checkOffset(offset);
    this._offset = offset;
  }
  view(numberOfBytes) {
    numberOfBytes = Number(numberOfBytes);
    const result = this.uint8Array.subarray(this._offset, this._offset + numberOfBytes);
    this.skip(numberOfBytes);
    return result;
  }
}

// dict/word_list.ts
var METADATA_FIELD_NUMBER = 1n;
var INSTRUCTIONS_FIELD_NUMBER = 2n;

class InvalidLexiconError extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidLexiconError";
  }
}

class WordListEntry extends String {
  elements;
  constructor(macros, elements) {
    super(elements.map((elt) => macros[Number(elt[elt.length - 1])].subword).join(""));
    this.elements = elements;
  }
}
function* toBigInts(numbers) {
  for (const n of numbers)
    yield BigInt(n);
}

class WordList {
  _metadata;
  instructions;
  constructor(lexiconMessage) {
    const lexiconMessageArray = new Uint8Array(lexiconMessage);
    const pointer = new Pointer(lexiconMessageArray);
    let insns = null;
    let metadata = null;
    while (!pointer.atEnd) {
      const tag = pointer.varintBigInt();
      const fieldNumber = tag >> 3n;
      const wireType = tag & 7n;
      if (wireType === 0n)
        pointer.varintBigInt();
      else if (wireType === 1n)
        pointer.skip(8);
      else if (wireType === 5n)
        pointer.skip(4);
      else if (wireType === 2n) {
        const len = pointer.varintBigInt();
        if (fieldNumber === METADATA_FIELD_NUMBER) {
          metadata = Metadata.decode(pointer.view(len));
        } else if (fieldNumber === INSTRUCTIONS_FIELD_NUMBER) {
          insns = pointer.view(len);
        }
      } else {
        throw new InvalidLexiconError(`Unsupported wireType ${wireType}.`);
      }
    }
    if (!insns)
      throw new InvalidLexiconError("No `instructions` field.");
    if (!metadata)
      throw new InvalidLexiconError("No `metadata` field.");
    this._metadata = metadata;
    this.instructions = insns;
    this._checkForRecursion();
  }
  get metadata() {
    return this._metadata;
  }
  get macros() {
    return this._metadata.macros;
  }
  _checkForRecursion() {
    const visiting = new Set;
    const visited = new Set;
    for (let i = 0;i < this.macros.length; ++i) {
      if (visited.has(i))
        continue;
      this._dfs(i, visiting, visited);
    }
  }
  _dfs(macroIndex, visiting, visited) {
    visiting.add(macroIndex);
    const macro = this.macros[macroIndex];
    if (macro?.subroutine) {
      for (const subMacroIndex of macro.subroutine.instructions) {
        if (visiting.has(subMacroIndex)) {
          throw new InvalidLexiconError("Recursive subroutine detected.");
        }
        if (!visited.has(subMacroIndex)) {
          this._dfs(subMacroIndex, visiting, visited);
        }
      }
    }
    visiting.delete(macroIndex);
    visited.add(macroIndex);
  }
  *scanFrom(ip) {
    const wordBuffer = [[]];
    const stack = [this.readInstructions(ip)];
    while (stack.length > 0) {
      const it = stack[stack.length - 1];
      const next = it.next();
      if (next.done) {
        stack.pop();
        continue;
      }
      const instruction = next.value;
      wordBuffer[wordBuffer.length - 1].push(instruction);
      const macro = this.macros[Number(instruction)];
      if (macro) {
        if (macro.subroutine) {
          stack.push(toBigInts(macro.subroutine.instructions));
          continue;
        }
        if (macro.clear || macro.backup !== undefined) {
          yield new WordListEntry(this.macros, wordBuffer.slice(0, -1));
          if (macro.clear) {
            wordBuffer.length = 0;
          } else {
            wordBuffer.length -= macro.backup + 1;
          }
        } else if (macro.subword === undefined) {
          continue;
        }
        wordBuffer.push([]);
      }
    }
    if (wordBuffer[0].length) {
      yield new WordListEntry(this.macros, wordBuffer.slice(0, -1));
    }
  }
  *readInstructions(ip) {
    while (!ip.atEnd) {
      yield ip.varintBigInt();
    }
  }
  [Symbol.iterator]() {
    return this.scanFrom(new Pointer(this.instructions));
  }
  has(possibleWord) {
    let iterator = this[Symbol.iterator]();
    const blockSize = this._metadata.clearInterval;
    if (blockSize > 0) {
      let loBlock = 0, hiBlock = Math.ceil(this.instructions.length / blockSize);
      while (true) {
        const midBlock = Math.floor((loBlock + hiBlock) / 2);
        if (midBlock === loBlock)
          break;
        const probe = new Pointer(this.instructions, midBlock * blockSize);
        probe.skipToVarint();
        while (!probe.atEnd) {
          if (this.macros[Number(probe.varintBigInt())]?.clear)
            break;
        }
        if (probe.atEnd || probe.offset >= hiBlock * blockSize)
          break;
        const midIterator = this.scanFrom(probe);
        const midWord = midIterator.next().value;
        switch (codePointCompare(possibleWord, midWord)) {
          case 0:
            return true;
          case -1:
            hiBlock = midBlock;
            continue;
          case 1:
            loBlock = midBlock;
            iterator = midIterator;
            continue;
        }
      }
    }
    for (const word of iterator) {
      switch (codePointCompare(possibleWord, word)) {
        case 0:
          return true;
        case 1:
          continue;
        case -1:
          return false;
      }
    }
    return false;
  }
}

// game/dictionary.ts
var SWDICT_SUFFIX = ".swdict";

class PlayRejectedError extends Error {
  constructor(message) {
    super(t("error.play_rejected.play_rejected", { message }));
    this.name = "PlayRejected";
  }
}
function makeDictionary(settings) {
  if (settings.dictionaryType === "permissive")
    return async (...words) => null;
  if (settings.dictionaryType === "wordlist")
    return makeListDictionary(settings);
  if (settings.dictionaryType === "freeapi") {
    let urlTemplate, dictionaryName;
    if (settings.dictionarySettings) {
      if (typeof settings.dictionarySettings !== "string") {
        throw new Error(`Dictionary type "${settings.dictionaryType}" requires setting a URL template.`);
      }
      urlTemplate = settings.dictionarySettings;
      dictionaryName = settings.dictionarySettings;
    } else {
      urlTemplate = "https://api.dictionaryapi.dev/api/v2/entries/en/{lower}";
      dictionaryName = "Free Dictionary API";
    }
    return makeUrlTemplateDictionary(urlTemplate, dictionaryName);
  }
  throw new Error(`dictionaryType ${settings.dictionaryType} is not supported.`);
}

class WordNotInDictionaryError extends PlayRejectedError {
  word;
  dictionaryName;
  status;
  constructor(word, dictionaryName, status) {
    super(t("error.play_rejected.word_not_in_dictionary", { word, status, dictionaryName }));
    this.word = word;
    this.dictionaryName = dictionaryName;
    this.status = status;
    this.name = "WordNotInDictionaryError";
  }
}

class WordNotFoundError extends WordNotInDictionaryError {
  constructor(word, dictionaryName) {
    super(word, dictionaryName, t("error.play_rejected.status.not_found"));
    this.name = "WordNotFoundError";
  }
}

class NoDefinitionError extends WordNotInDictionaryError {
  constructor(word, dictionaryName) {
    super(word, dictionaryName, t("error.play_rejected.status.has_no_definition"));
    this.name = "NoDefinitionError";
  }
}
function makeUrlTemplateDictionary(urlTemplate, dictionaryName) {
  return async (...words) => {
    const promises = words.map((word) => {
      const url = urlTemplate.replace("{lower}", word.toLowerCase());
      return checkWordUsingUrl(word, url, dictionaryName);
    });
    const results = await Promise.all(promises);
    const errors = results.filter((r) => r);
    if (errors.length === 0)
      return;
    if (errors.length === 1)
      throw errors[0];
    const invalidWords = errors.map((wnidError) => wnidError.word);
    throw new PlayRejectedError(t("error.play_rejected.not_words_in_dictionary", { dictionaryName: errors[0].dictionaryName, invalidWords: invalidWords.join(", ") }));
  };
}
async function checkWordUsingUrl(wordToCheck, url, dictionaryName) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      if (response.status === 404) {
        return new WordNotFoundError(wordToCheck, dictionaryName);
      } else {
        throw new Error(`Error validating word "${wordToCheck}" with ${dictionaryName} (Status: ${response.status} ${response.statusText}).`);
      }
    }
    const data = await response.json();
    if (!Array.isArray(data) || data.length === 0 || data[0] && data[0].title === "No Definitions Found") {
      return new NoDefinitionError(wordToCheck, dictionaryName);
    }
    console.log(`Word "${wordToCheck}" is valid according to ${dictionaryName}.`);
    return null;
  } catch (error) {
    console.error(`Network or other error validating word "${wordToCheck}":`, error);
    throw new Error(`Could not reach ${dictionaryName} to validate "${wordToCheck}". Check connection or API status.`);
  }
}
function makeListDictionary(settings) {
  const dictionarySettings = settings.dictionarySettings;
  if (typeof dictionarySettings !== "string") {
    throw new TypeError(`Word list requires a string URL, not ${dictionarySettings}.`);
  }
  let wordListPromise = null;
  const getWordList = () => {
    if (!wordListPromise) {
      let dictionaryUrl;
      try {
        dictionaryUrl = new URL(dictionarySettings).href;
      } catch (e) {
        if (!(e instanceof TypeError))
          throw e;
        const maybeSuffix = dictionarySettings.slice(-SWDICT_SUFFIX.length) === SWDICT_SUFFIX ? "" : SWDICT_SUFFIX;
        const relativeUrl = dictionarySettings + maybeSuffix;
        dictionaryUrl = new URL(relativeUrl, new URL("dict/", settings.baseUrl)).href;
      }
      wordListPromise = (async () => {
        const response = await fetch(dictionaryUrl);
        if (!response.ok) {
          throw new Error(`Failed to fetch word list from ${dictionaryUrl}: ${response.statusText}`);
        }
        const buffer = await response.arrayBuffer();
        return new WordList(new Uint8Array(buffer));
      })();
    }
    return wordListPromise;
  };
  return async (...words) => {
    const wordList = await getWordList();
    const dictionaryName = wordList.metadata?.name || dictionarySettings;
    const errors = words.map((word) => {
      if (!wordList.has(word.toLowerCase())) {
        return new WordNotFoundError(word, dictionaryName);
      }
      return null;
    }).filter((r) => r !== null);
    if (errors.length === 0)
      return;
    if (errors.length === 1)
      throw errors[0];
    const invalidWords = errors.map((e) => e.word);
    throw new PlayRejectedError(t("error.play_rejected.not_words_in_dictionary", { dictionaryName, invalidWords: invalidWords.join(", ") }));
  };
}

// game/shared_state.ts
class SharedState {
  settings;
  gameId;
  board;
  tilesState;
  nextTurnNumber;
  checkWords;
  gameParams;
  constructor(settings, gameId = settings.gameId ?? makeGameId(), board = new Board(...settings.boardLayout), tilesState = makeTilesState(settings), nextTurnNumber2 = toTurnNumber(1), checkWords = makeDictionary(settings), gameParams = gameParamsFromSettings(settings)) {
    this.settings = settings;
    this.gameId = gameId;
    this.board = board;
    this.tilesState = tilesState;
    this.nextTurnNumber = nextTurnNumber2;
    this.checkWords = checkWords;
    this.gameParams = gameParams;
    this.settings.players.forEach((player, index) => {
      const expected = String(index + 1);
      if (player.id !== expected) {
        throw new Error(`players[${index}] should have ID "${expected}", not "${player.id}".`);
      }
    });
  }
  copyFrom(other) {
    this.board.copyFrom(other.board);
    this.tilesState.copyFrom(other.tilesState);
    this.nextTurnNumber = other.nextTurnNumber;
    this.players.forEach((player, index) => {
      player.name = other.players[index].name;
    });
  }
  get players() {
    return this.settings.players;
  }
  get isGameOver() {
    return this.tilesState.isGameOver;
  }
  getPlayerForTurnNumber(turnNumber) {
    return getPlayerForTurnNumber(this.players, turnNumber);
  }
  getTurnUrlParams(turnHistory) {
    const entries = [["gid", fromGameId(this.gameId)]];
    const firstHistoryTurnNumber = turnHistory[0]?.turnNumber;
    if (firstHistoryTurnNumber === undefined || firstHistoryTurnNumber === toTurnNumber(1)) {
      entries.push(...this.gameParams);
    }
    if (turnHistory.length) {
      entries.push(["tn", String(firstHistoryTurnNumber)]);
      turnHistory.forEach((turnData) => {
        entries.push(...new URLSearchParams(turnData.paramsStr));
      });
    } else {
      entries.push(["tn", "1"]);
    }
    return new URLSearchParams(entries);
  }
  async playTurns(...turns) {
    const seen = [];
    for (const turn of turns) {
      if (turn.turnNumber < this.nextTurnNumber) {
        console.log(`Ignoring old turn number ${turn.turnNumber}`);
      } else if (turn.turnNumber in seen) {
        throw new Error(`playTurns received duplicate turn number ${turn.turnNumber}.`);
      } else {
        seen[turn.turnNumber] = turn;
      }
    }
    const turnsToPlayNow = [];
    const boardChanges = [];
    const wordsToCheck = new Set;
    let turnNumber = this.nextTurnNumber;
    for (const turn of seen.filter((t2) => t2)) {
      if (turn.turnNumber !== turnNumber) {
        console.warn(`Ignoring out-of-order turn number ${turn.turnNumber}; expected ${turnNumber}.`);
        break;
      }
      const playerId = this.getPlayerForTurnNumber(turnNumber).id;
      if (turn.playerId !== playerId) {
        throw new Error(`Turn number ${turn.turnNumber} belongs to player "${playerId}", not "${turn.playerId}".`);
      }
      if ("playTiles" in turn.move) {
        const { wordsFormed, score, mainWordForUrl, row, col, vertical, blanks } = this.board.checkWordPlacement(...turn.move.playTiles);
        wordsFormed.forEach((w) => wordsToCheck.add(w));
        const bingoBonus = turn.move.playTiles.length === this.tilesState.rackCapacity ? this.settings.bingoBonus : 0;
        boardChanges.push({ playerId, score: score + bingoBonus, placements: turn.move.playTiles });
        turn.mainWord = mainWordForUrl;
        turn.row = row;
        turn.col = col;
        turn.vertical = vertical;
        turn.blanks = blanks;
        console.log(`Player ${playerId} plays ${wordsFormed[0]} for ${score}`);
      } else if ("exchangeTileIndices" in turn.move) {
        checkIndicesForExchange(this.tilesState.countTiles(playerId), ...turn.move.exchangeTileIndices);
        const numAttempted = turn.move.exchangeTileIndices.length;
        const numInBag = this.tilesState.numberOfTilesInBag;
        if (numAttempted > numInBag) {
          throw new Error(`Player ${playerId} attempted to exchange ${numAttempted} but the bag holds only ${numInBag}.`);
        }
        if (numAttempted) {
          console.log(`Player ${playerId} exchanges ${numAttempted} tiles.`);
        } else {
          console.log(`Player ${playerId} passes.`);
        }
      } else {
        throw new Error(`Turn number ${turn.turnNumber} is not a play or exchange.`);
      }
      turnsToPlayNow.push(turn);
      turnNumber = nextTurnNumber(turnNumber);
    }
    if (wordsToCheck.size)
      await this.checkWords(...wordsToCheck);
    if (turnsToPlayNow.length === 0)
      return turnsToPlayNow;
    console.debug(`Turn validation success.`);
    for (const { playerId, score, placements } of boardChanges) {
      this.board.placeTiles(...placements);
      this.board.scores.set(playerId, (this.board.scores.get(playerId) ?? 0) + score);
    }
    this.nextTurnNumber = turnNumber;
    return turnsToPlayNow;
  }
  *turnsFromParams(params, turnNumber) {
    let wordLocationStr = null;
    let blankTileIndicesStr = null;
    let direction = null;
    let wordPlayed = null;
    let exchangeIndicesStr = null;
    function* processPendingMoveIfAny() {
      const playerId = this.getPlayerForTurnNumber(turnNumber).id;
      if (wordPlayed && direction && wordLocationStr) {
        if (exchangeIndicesStr) {
          throw new UrlError(t("error.url.both_word_and_exchange", { turnNumber }));
        }
        const blankTileAssignments = [];
        if (blankTileIndicesStr) {
          blankTileIndicesStr.split(".").forEach((s) => {
            const match2 = s.match(/^(\d+)$/);
            if (!match2) {
              throw new UrlError(t("error.url.invalid_bt_component", { component: s }));
            }
            const index = parseInt(match2[1], 10);
            if (index in blankTileAssignments) {
              throw new UrlError(t("error.url.duplicate_bt_index", { param: blankTileIndicesStr }));
            }
            const assignedLetter = wordPlayed[index];
            if (!assignedLetter) {
              throw new UrlError(t("error.url.bt_index_out_of_range", { word: wordPlayed, index }));
            }
            blankTileAssignments[index] = assignedLetter;
          });
        }
        const match = wordLocationStr.match(/^(\d+)\.(\d+)$/);
        if (!match) {
          throw new UrlError(t("error.url.invalid_wl_param", { param: wordLocationStr }));
        }
        let row = parseInt(match[1], 10);
        let col = parseInt(match[2], 10);
        const placements = [];
        const lettersPlayed = wordPlayed.indexOf(".") === -1 ? [...wordPlayed] : wordPlayed.split(".");
        lettersPlayed.map((letter, letterIndex) => {
          const square = this.board.squares[row]?.[col];
          if (!square)
            throw new UrlError(t("error.url.word_out_of_bounds", { row, col }));
          if (!square.tile) {
            const assignedLetter = blankTileAssignments[letterIndex] ?? "";
            if (assignedLetter) {
              placements.push({ tile: new Tile({ letter: "", value: 0 }), row, col, assignedLetter });
            } else {
              const value = this.settings.letterValues.get(letter);
              if (value === undefined)
                throw new UrlError(t("error.url.invalid_letter", { letter }));
              placements.push({ tile: new Tile({ letter, value }), row, col });
            }
          } else if (square.letter !== letter) {
            throw new UrlError(t("error.url.wrong_letter", { requiredLetter: letter, row, col, actualLetter: square.letter }));
          }
          if (direction === "wv") {
            row += 1;
          } else {
            col += 1;
          }
        });
        if (blankTileAssignments.length > wordPlayed.length) {
          throw new UrlError(t("error.url.bt_index_range", { index: blankTileAssignments.length - 1, maxIndex: wordPlayed.length - 1 }));
        }
        yield new Turn(playerId, turnNumber, { playTiles: placements });
      } else if (exchangeIndicesStr != null) {
        if (wordPlayed || direction || wordLocationStr || blankTileIndicesStr) {
          throw new UrlError(t("error.url.incomplete_turn_data", { turnNumber, wl: wordLocationStr, direction, word: wordPlayed, bt: blankTileIndicesStr }));
        }
        const exchangeIndexStrs = exchangeIndicesStr ? exchangeIndicesStr.split(".") : [];
        const numberOfTilesInRack = this.tilesState.countTiles(playerId);
        const exchangeTileIndices = [];
        exchangeIndexStrs.forEach((s) => {
          const index = parseInt(s, 10);
          if (isNaN(index) || index < 0 || index >= numberOfTilesInRack) {
            throw new UrlError(t("error.url.invalid_exchange_index", { index: s }));
          }
          exchangeTileIndices.push(index);
        });
        yield new Turn(playerId, turnNumber, { exchangeTileIndices });
      } else {
        return;
      }
      turnNumber = nextTurnNumber(turnNumber);
      wordLocationStr = null;
      blankTileIndicesStr = null;
      direction = null;
      wordPlayed = null;
      exchangeIndicesStr = null;
    }
    for (const [key, value] of params) {
      const pnMatch = key.match(/^p(\d+)n$/);
      if (pnMatch) {
        const playerIndex = parseInt(pnMatch[1], 10) - 1;
        const player = this.players[playerIndex];
        if (player) {
          player.name = value;
        } else {
          throw new UrlError(t("error.url.invalid_player_id", { id: pnMatch[1], maxId: this.players.length }));
        }
      } else if (key === "wl") {
        yield* processPendingMoveIfAny.call(this);
        wordLocationStr = value;
      } else if (key === "ex") {
        yield* processPendingMoveIfAny.call(this);
        exchangeIndicesStr = value;
      } else if (key === "bt") {
        if (blankTileIndicesStr) {
          throw new UrlError(t("error.url.duplicate_bt_param", { turnNumber }));
        }
        blankTileIndicesStr = value;
      } else if (key === "wv" || key === "wh") {
        if (direction) {
          throw new UrlError(t("error.url.duplicate_word_params", { turnNumber }));
        }
        direction = key;
        wordPlayed = value;
      } else {
        throw new UrlError(t("error.url.unrecognized_param", { param: key }));
      }
    }
    yield* processPendingMoveIfAny.call(this);
  }
  toJSON() {
    return {
      gameId: this.gameId,
      nextTurnNumber: this.nextTurnNumber,
      settings: this.settings.toJSON(),
      board: this.board.toJSON(),
      tilesState: this.tilesState.toJSON()
    };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in SharedState serialization: ${JSON.stringify(json)}`);
    }
    if (typeof json !== "object")
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], [
      "gameId",
      "nextTurnNumber",
      "settings",
      "board",
      "tilesState"
    ]))
      fail("Wrong keys or key order");
    if (typeof json.gameId !== "string")
      fail("Game ID is not a string");
    if (typeof json.nextTurnNumber !== "number")
      fail("Next turn number is not a number");
    const settings = Settings.fromJSON(json.settings);
    return new SharedState(settings, json.gameId, Board.fromJSON(json.board), rehydrateTilesState(settings.tileSystemType, json.tilesState), toTurnNumber(json.nextTurnNumber));
  }
}
function makeTilesState(settings) {
  if (settings.tileSystemType === "honor") {
    return new HonorSystemTilesState(settings.players, settings.tileSystemSettings, makeTiles(settings), settings.rackCapacity);
  }
  throw new Error(`Unsupported tileSystemType: ${settings.tileSystemType}`);
}
function rehydrateTilesState(tileSystemType, tilesStateJson) {
  if (tileSystemType === "honor")
    return HonorSystemTilesState.fromJSON(tilesStateJson);
  throw new TypeError(`Unknown tileSystemType: ${tileSystemType}`);
}

// game/game_state.ts
function makeStorageKey(gameId) {
  return "sharewords_" + gameId;
}
function isTurnPreviewSuccess(result) {
  return result.error === null;
}

class GameState extends EventTarget {
  playerId;
  keepAllHistory;
  tilesHeld;
  history;
  pendingExtraParams;
  shared;
  inPlayTurns = false;
  storage = null;
  constructor(playerId, settings, keepAllHistory = true, shared, tilesHeld = [], history = [], pendingExtraParams = new URLSearchParams) {
    super();
    this.playerId = playerId;
    this.keepAllHistory = keepAllHistory;
    this.tilesHeld = tilesHeld;
    this.history = history;
    this.pendingExtraParams = pendingExtraParams;
    if (!shared) {
      if (!settings) {
        throw new Error("New GameState requires either a Settings or a SharedState.");
      }
      shared = new SharedState(settings);
    }
    this.shared = shared;
    if (!this.shared.settings.players.some((p) => p.id === playerId)) {
      throw new Error(`Player ID "${playerId}" is not listed in settings.`);
    }
    this.board.addEventListener("tileplaced", (evt) => {
      const { placement } = evt.detail;
      const myTile = this.tilesHeld.find((p) => p.row === placement.row && p.col === placement.col);
      if (myTile && myTile.tile !== placement.tile) {
        console.debug(`My tile at ${placement.row},${placement.col} is displaced. Moving it to rack.`);
        this.moveTile(myTile.row, myTile.col, "rack", 0);
      }
    });
    this.tilesState.addEventListener("tiledraw", this.tiledraw.bind(this));
    this.tilesState.addEventListener("tilereturn", this.tilereturn.bind(this));
  }
  copyFrom(other) {
    this.shared.copyFrom(other.shared);
    this.keepAllHistory = other.keepAllHistory;
    this.tilesHeld.splice(0, this.tilesHeld.length, ...other.tilesHeld);
    this.history.splice(0, this.history.length, ...other.history);
    this.pendingExtraParams = other.pendingExtraParams;
  }
  save() {
    const gid = this.gameId;
    if (gid && this.storage) {
      const game = this.toJSON();
      const ver = this.settings.version;
      const ts = Date.now();
      const key = makeStorageKey(gid);
      const value = JSON.stringify({ game, ts, ver });
      this.storage.setItem(key, value);
    }
  }
  async init() {
    const tiles = await this.tilesState.getTiles(this.playerId);
    this.tilesHeld.splice(0, this.tilesHeld.length, ...tiles.map((tile, index) => {
      return {
        tile,
        row: "rack",
        col: index
      };
    }));
    this.tilesHeld.forEach((p) => {
      this.dispatchEvent(new TileEvent("tilemove", { detail: { placement: p } }));
    });
  }
  get gameId() {
    return this.shared.gameId;
  }
  get settings() {
    return this.shared.settings;
  }
  get nextTurnNumber() {
    return this.shared.nextTurnNumber;
  }
  get players() {
    return this.shared.players;
  }
  get board() {
    return this.shared.board;
  }
  get tilesState() {
    return this.shared.tilesState;
  }
  get numberOfTilesInBag() {
    return this.tilesState.numberOfTilesInBag;
  }
  get isGameOver() {
    return this.tilesState.isGameOver;
  }
  get exchangeTilesCount() {
    return this.tilesHeld.filter((p) => p.row === "exchange").length;
  }
  async getTiles(playerId) {
    return await this.tilesState.getTiles(playerId);
  }
  get turnUrlParams() {
    return this.shared.getTurnUrlParams(this.history.slice(1 - this.players.length));
  }
  getHistoryUrlParamsForPlayer(playerId) {
    return new URLSearchParams([["pid", playerId], ...this.shared.getTurnUrlParams(this.history)]);
  }
  get playerWhoseTurnItIs() {
    if (this.isGameOver)
      return null;
    return this.getPlayerForTurnNumber(this.nextTurnNumber);
  }
  getPlayerForTurnNumber(turnNumber) {
    return this.shared.getPlayerForTurnNumber(turnNumber);
  }
  tiledraw(evt) {
    if (evt.detail.playerId === this.playerId) {
      console.debug(`I drew "${evt.detail.tile.letter}".`);
      const occupiedIndices = new Set(this.tilesHeld.filter((p) => p.row === "rack").map((p) => p.col));
      for (let col = 0;col < this.settings.rackCapacity; ++col) {
        if (!occupiedIndices.has(col)) {
          this.tilesHeld.push({ row: "rack", col, tile: evt.detail.tile });
          return;
        }
      }
      throw new Error(`No room for drawn tile! ${JSON.stringify(this.tilesHeld)}`);
    }
  }
  tilereturn(evt) {
    if (evt.detail.playerId === this.playerId) {
      let index = this.tilesHeld.findIndex((p) => p.row === "exchange" && p.tile.equals(evt.detail.tile));
      if (index === -1)
        index = this.tilesHeld.findIndex((p) => p.tile.equals(evt.detail.tile));
      if (index === -1) {
        console.error(`Tile not found for exchange: ${JSON.stringify(evt.detail.tile)}`);
      } else {
        this.tilesHeld.splice(index, 1);
      }
    }
  }
  moveTile(fromRow, fromCol, toRow, toCol, assignedLetter) {
    const preparation = this.prepareTileMove(fromRow, fromCol, toRow, toCol);
    if (!preparation.success)
      throw new RangeError(preparation.message);
    for (const pushed of preparation.toPush) {
      const pushedFromCol = pushed.col;
      pushed.col = pushedFromCol + preparation.pushDirection;
      this.dispatchEvent(new TileEvent("tilemove", { detail: { fromRow, fromCol: pushedFromCol, placement: pushed } }));
    }
    preparation.placement.row = preparation.toRow;
    preparation.placement.col = preparation.toCol;
    preparation.placement.assignedLetter = assignedLetter;
    if (!isBoardPlacementRow(preparation.toRow)) {
      delete preparation.placement.assignedLetter;
    }
    this.dispatchEvent(new TileEvent("tilemove", { detail: { fromRow, fromCol, placement: preparation.placement } }));
  }
  prepareTileMove(fromRow, fromCol, toRow, toCol) {
    const placement = this.tilesHeld.find((p) => p.row === fromRow && p.col === fromCol);
    if (placement === undefined)
      return { success: false, message: `No tile at ${fromRow},${fromCol}.` };
    let pushDirection = toRow !== fromRow || toCol < fromCol ? 1 : -1;
    let toPush = [];
    const occupant = fromRow === toRow && fromCol === toCol ? undefined : this.tilesHeld.find((p) => p.row === toRow && p.col === toCol);
    if (toRow === "rack" || toRow === "exchange") {
      const capacity = this.settings.rackCapacity;
      if (!indicesOk(capacity, toCol))
        return { success: false, message: `Invalid toCol: ${toCol}` };
      if (occupant) {
        let tryPush = function() {
          const newToPush2 = [];
          for (let col = toCol;; col += pushDirection) {
            if (col < 0 || col >= capacity)
              return null;
            const rowmate = newRowmates.get(col);
            if (rowmate)
              newToPush2.unshift(rowmate);
            else
              return newToPush2;
          }
        };
        const newRowmates = new Map(this.tilesHeld.filter((p) => p.row === toRow && !(p.row === fromRow && p.col === fromCol)).map((p) => [p.col, p]));
        if (toRow === fromRow && toCol > fromCol) {
          pushDirection = -1;
        } else {
          pushDirection = 1;
        }
        let newToPush = tryPush();
        if (!newToPush) {
          pushDirection = -pushDirection;
          newToPush = tryPush();
          if (!newToPush)
            return {
              success: false,
              message: `${toRow === "rack" ? "Rack" : "Exchange area"} is full.`
            };
        }
        toPush = newToPush;
      }
    } else {
      const square = this.board.squares[toRow]?.[toCol];
      if (!square)
        return { success: false, message: `Tile destination ${toRow},${toCol} is off the board.` };
      if (occupant || square.tile) {
        for (const [deltaRow, deltaCol] of [[0, 1], [1, 0], [-1, 0], [0, -1]]) {
          const [row, col] = [toRow + deltaRow, toCol + deltaCol];
          const nearbySquare = this.board.squares[row]?.[col];
          if (!nearbySquare)
            continue;
          if (nearbySquare.tile)
            continue;
          if (this.tilesHeld.some((p) => p.row === row && p.col === col))
            continue;
          return { success: true, placement, toRow: row, toCol: col, pushDirection, toPush };
        }
        return { success: false, message: `Square ${toRow},${toCol} is occupied` };
      }
    }
    return { success: true, placement, toRow, toCol, pushDirection, toPush };
  }
  recallTiles() {
    const placedTiles = this.tilesHeld.filter((p) => p.row !== "rack");
    const occupiedRackSpots = new Set(this.tilesHeld.filter((p) => p.row === "rack").map((p) => p.col));
    let nextFreeSpot = 0;
    for (const placement of placedTiles) {
      while (occupiedRackSpots.has(nextFreeSpot)) {
        ++nextFreeSpot;
      }
      if (nextFreeSpot >= this.settings.rackCapacity) {
        console.error("No space in rack to recall tile.");
        break;
      }
      this.moveTile(placement.row, placement.col, "rack", nextFreeSpot);
      ++nextFreeSpot;
    }
  }
  getTurnPreview() {
    const placements = this.tilesHeld.filter(isBoardPlacement);
    try {
      const result = this.board.checkWordPlacement(...placements);
      const bingoBonus = placements.length === this.settings.rackCapacity ? this.settings.bingoBonus : 0;
      return {
        ...result,
        score: result.score + bingoBonus,
        error: null
      };
    } catch (e) {
      return { error: e.message };
    }
  }
  async playWord() {
    const placements = this.tilesHeld.filter(isBoardPlacement);
    const turn = new Turn(this.playerId, this.nextTurnNumber, { playTiles: placements });
    turn.extraParams = this.pendingExtraParams;
    this.pendingExtraParams = new URLSearchParams;
    await this.playTurns([turn]);
  }
  async passOrExchange() {
    const placements = this.tilesHeld.map((p, index) => ({ p, index })).filter(({ p }) => p.row === "exchange");
    const exchangeTileIndices = placements.map(({ index }) => index);
    const turn = new Turn(this.playerId, this.nextTurnNumber, { exchangeTileIndices });
    turn.extraParams = this.pendingExtraParams;
    this.pendingExtraParams = new URLSearchParams;
    await this.playTurns([turn]);
  }
  async playTurns(turns) {
    if (this.isGameOver) {
      throw new Error("Game Over.");
    }
    if (this.inPlayTurns)
      throw new Error(`playTurns: recursion detected.`);
    const json = this.toJSON();
    const oldNextTurnNumber = this.nextTurnNumber;
    let ok = false;
    try {
      this.inPlayTurns = true;
      await this.doPlayTurns(turns);
      this.save();
      ok = true;
    } finally {
      this.inPlayTurns = false;
      if (!ok) {
        console.log("Rolling back game state.");
        this.copyFrom(GameState.fromJSON(json));
        this.dispatchEvent(new GameEvent("turnchange"));
      }
    }
    if (this.nextTurnNumber !== oldNextTurnNumber) {
      this.dispatchEvent(new GameEvent("turnchange"));
    }
  }
  async doPlayTurns(turns) {
    const newTurns = [];
    let finalTurnNumber = null;
    for (const turn of turns) {
      for (const newTurn of await this.shared.playTurns(turn)) {
        if (newTurn.playerId === this.playerId && "playTiles" in newTurn.move) {
          for (const placement of newTurn.move.playTiles) {
            let index = this.tilesHeld.findIndex((p) => p.row === placement.row && p.col === placement.col && p.tile.equals(placement.tile));
            if (index === -1)
              index = this.tilesHeld.findIndex((p) => p.tile.equals(placement.tile));
            if (index === -1)
              index = this.tilesHeld.findIndex((p) => p.tile.isBlank);
            if (index === -1)
              throw new Error(`Could not find tile to place: ${JSON.stringify(placement)}`);
            this.tilesHeld.splice(index, 1);
          }
        }
        finalTurnNumber = await this.tilesState.playTurns(turn);
        newTurns.push(turn);
        if (finalTurnNumber !== null)
          break;
      }
    }
    updateTurnHistory({
      history: this.history,
      nextTurnNumber: this.nextTurnNumber,
      finalTurnNumber,
      turns: newTurns
    });
    if (finalTurnNumber !== null) {
      const finalTurnPlayerId = this.getPlayerForTurnNumber(finalTurnNumber).id;
      console.log(`Player ${finalTurnPlayerId} ends game after turn ${finalTurnNumber}.`);
      let allTilesSum = 0;
      for (const player of this.players) {
        if (player.id !== finalTurnPlayerId) {
          const playerTiles = await this.getTiles(player.id);
          const tilesSum = playerTiles.reduce((sum, curr) => sum + curr.value, 0);
          this.board.scores.set(player.id, (this.board.scores.get(player.id) ?? 0) - tilesSum);
          console.log(`Transfering ${tilesSum} from Player ${player.id}.`);
          allTilesSum += tilesSum;
        }
      }
      console.log(`Transfering ${allTilesSum} to Player ${finalTurnPlayerId}.`);
      this.board.scores.set(finalTurnPlayerId, (this.board.scores.get(finalTurnPlayerId) ?? 0) + allTilesSum);
    }
    if (!this.keepAllHistory) {
      const turnsToKeep = this.players.length - 1;
      if (turnsToKeep > 0 && this.history.length > turnsToKeep) {
        this.history.splice(0, this.history.length - turnsToKeep);
      }
    }
  }
  changePlayerName(playerId, name) {
    const playerIndex = this.players.findIndex((p) => p.id === playerId);
    if (playerIndex === -1) {
      throw new Error(`Player with ID ${playerId} not found.`);
    }
    const player = this.players[playerIndex];
    if (player.name !== name) {
      player.name = name;
      this.pendingExtraParams.set(`p${playerIndex + 1}n`, name);
      this.dispatchEvent(new GameEvent("turnchange"));
    }
  }
  async applyTurnParams(params) {
    if (this.isGameOver)
      return;
    const iterator = params[Symbol.iterator]();
    let urlTurnNumberStr;
    for (const [key, value] of iterator) {
      if (key !== "tn")
        continue;
      urlTurnNumberStr = value;
      break;
    }
    if (!urlTurnNumberStr) {
      console.info("applyTurnParams: no turn number found.");
      return;
    }
    const turnNumber = toTurnNumber(parseInt(urlTurnNumberStr));
    if (isNaN(turnNumber)) {
      throw new UrlError(t("error.url.tn_not_a_number", { param: urlTurnNumberStr }));
    }
    await this.playTurns(this.shared.turnsFromParams(iterator, turnNumber));
  }
  getWordsAt(row, col) {
    const board = this.board;
    const tempBoard = new board.constructor(...board.toJSON().rows);
    tempBoard.copyFrom(board);
    for (const placement of this.tilesHeld) {
      if (isBoardPlacement(placement)) {
        const square = tempBoard.squares[placement.row]?.[placement.col];
        if (square) {
          square.tile = placement.tile;
          square.assignedLetter = placement.assignedLetter;
        }
      }
    }
    return tempBoard.getWordsAt(row, col);
  }
  static async fromParams(params, baseUrl = "http://localhost/") {
    const { settings, playerId, turnParams } = parseGameParams(params);
    settings.baseUrl = baseUrl;
    const gameState = new GameState(playerId, settings);
    await gameState.init();
    await gameState.applyTurnParams(turnParams);
    return gameState;
  }
  toJSON() {
    return {
      shared: this.shared.toJSON(),
      playerId: this.playerId,
      keepAllHistory: this.keepAllHistory,
      tilesHeld: this.tilesHeld.map((placement) => {
        const json = {
          tile: placement.tile.toJSON(),
          row: placement.row,
          col: placement.col
        };
        if (placement.assignedLetter)
          json.assignedLetter = placement.assignedLetter;
        return json;
      }),
      history: this.history.map((turnData) => {
        return { turnNumber: turnData.turnNumber, params: turnData.paramsStr };
      }),
      pendingExtraParams: this.pendingExtraParams.toString()
    };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in GameState serialization: ${JSON.stringify(json)}`);
    }
    if (typeof json !== "object")
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], ["shared", "playerId", "keepAllHistory", "tilesHeld", "history", "pendingExtraParams"])) {
      fail("Wrong keys or key order");
    }
    if (typeof json.playerId !== "string")
      fail("Player ID is not a string");
    if (typeof json.keepAllHistory !== "boolean")
      fail("keepAllHistory is not a boolean");
    if (!Array.isArray(json.tilesHeld))
      fail("tilesHeld is not an array");
    if (!Array.isArray(json.history))
      fail("History is not an array");
    if (typeof json.pendingExtraParams !== "string")
      fail("pendingExtraParams is not a string");
    const tilesHeld = json.tilesHeld.map((tileJson) => {
      if (typeof tileJson !== "object")
        fail("tilesHeld element is not an object");
      if (!arraysEqual([...Object.keys({ ...tileJson, assignedLetter: "x" })], ["tile", "row", "col", "assignedLetter"])) {
        fail("Wrong tilesHeld element keys or key order");
      }
      if (typeof tileJson.row !== "number" && tileJson.row !== "rack" && tileJson.row !== "exchange") {
        fail("Invalid tilesHeld[].row");
      }
      if (typeof tileJson.col !== "number")
        fail("Invalid tilesHeld[].col");
      if (tileJson.assignedLetter !== undefined && typeof tileJson.assignedLetter !== "string") {
        fail("Invalid tilesHeld[].assignedLetter");
      }
      const tile = Tile.fromJSON(tileJson.tile);
      if (tile.letter && tileJson.assignedLetter)
        fail("Non-blank tile with an assigned letter");
      const result = {
        tile,
        row: tileJson.row,
        col: tileJson.col
      };
      if (tileJson.assignedLetter)
        result.assignedLetter = tileJson.assignedLetter;
      return result;
    });
    const history = json.history.map((turnDataJson) => {
      if (!arraysEqual([...Object.keys(turnDataJson)], ["turnNumber", "params"])) {
        fail("Wrong history element keys or key order");
      }
      if (typeof turnDataJson.turnNumber !== "number")
        fail("turnNumber is not a number");
      if (typeof turnDataJson.params !== "string")
        fail("params is not a string");
      return { turnNumber: toTurnNumber(turnDataJson.turnNumber), paramsStr: turnDataJson.params };
    });
    const gameState = new GameState(json.playerId, undefined, json.keepAllHistory, SharedState.fromJSON(json.shared), tilesHeld, history, new URLSearchParams(json.pendingExtraParams));
    return gameState;
  }
}

// view/dialog.ts
class Dialog {
  title;
  content;
  buttons;
  dialogElement;
  contentElement;
  promiseResolve = () => {};
  doc;
  constructor(doc, title, content, buttons) {
    this.title = title;
    this.content = content;
    this.buttons = buttons;
    this.doc = doc;
    this.dialogElement = this.doc.createElement("dialog");
    this.dialogElement.innerHTML = `
      <form method="dialog">
        <h2>${this.title}</h2>
        <div class="content"></div>
        <div class="buttons"></div>
      </form>
    `;
    this.contentElement = this.dialogElement.querySelector(".content");
    this.contentElement.appendChild(this.content);
    const buttonsContainer = this.dialogElement.querySelector(".buttons");
    for (const label of this.buttons) {
      const button = this.doc.createElement("button");
      button.textContent = label;
      button.value = label;
      buttonsContainer.appendChild(button);
    }
    this.doc.body.appendChild(this.dialogElement);
    this.dialogElement.addEventListener("close", () => {
      this.promiseResolve(this.dialogElement.returnValue);
      this.dialogElement.remove();
    });
  }
  show() {
    this.dialogElement.showModal();
    return new Promise((resolve) => {
      this.promiseResolve = resolve;
    });
  }
  close() {
    this.dialogElement.close();
  }
}

// view/game_setup.ts
class GameSetup {
  gameState;
  browser;
  doc;
  settingsDialog;
  playerList;
  addPlayerButton;
  dictionaryType;
  dictionaryUrlContainer;
  dictionaryUrl;
  tileDistribution;
  bingoBonus;
  randomSeed;
  randomSeedCheckbox;
  startGameButton;
  cancelSettingsButton;
  constructor(gameState, browser) {
    this.gameState = gameState;
    this.browser = browser;
    this.doc = browser.getDocument();
    this.settingsDialog = this.doc.getElementById("settings-dialog");
    this.playerList = this.doc.getElementById("player-list");
    this.addPlayerButton = this.doc.getElementById("add-player-button");
    this.dictionaryType = this.doc.getElementById("dictionary-type");
    this.dictionaryUrlContainer = this.doc.getElementById("dictionary-url-container");
    this.dictionaryUrl = this.doc.getElementById("dictionary-url");
    this.tileDistribution = this.doc.getElementById("tile-distribution");
    this.bingoBonus = this.doc.getElementById("bingo-bonus");
    this.randomSeed = this.doc.getElementById("random-seed");
    this.randomSeedCheckbox = this.doc.getElementById("random-seed-checkbox");
    this.startGameButton = this.doc.getElementById("start-game-with-settings");
    this.cancelSettingsButton = this.doc.getElementById("cancel-settings");
    this._bindSettingsDialogEvents();
  }
  _bindSettingsDialogEvents() {
    this.addPlayerButton.addEventListener("click", () => {
      const currentPlayers = Array.from(this.playerList.querySelectorAll("input")).map((i) => ({ name: i.value }));
      currentPlayers.push({ name: "" });
      this._updatePlayerList(currentPlayers);
    });
    this.dictionaryType.addEventListener("change", () => this._handleDictChange());
    this.randomSeedCheckbox.addEventListener("change", () => {
      this.randomSeed.disabled = this.randomSeedCheckbox.checked;
    });
    this.startGameButton.addEventListener("click", () => {
      const settings = Settings.fromJSON(this.gameState.settings.toJSON());
      const playerInputs = Array.from(this.playerList.querySelectorAll("input"));
      const playerNames = playerInputs.map((input) => input.value).filter((name) => name.trim() !== "");
      settings.players = playerNames.map((name, i) => new Player({ id: String(i + 1), name }));
      const dictionaryValue = this.dictionaryType.value;
      if (dictionaryValue === "permissive") {
        settings.dictionaryType = "permissive";
        settings.dictionarySettings = null;
      } else if (dictionaryValue === "freeapi" || dictionaryValue === "wordlist") {
        settings.dictionaryType = dictionaryValue;
        settings.dictionarySettings = this.dictionaryUrl.value || null;
      } else {
        settings.dictionaryType = "wordlist";
        settings.dictionarySettings = dictionaryValue;
      }
      const bagLanguage = this.tileDistribution.value;
      if (hasBagDefaults(bagLanguage)) {
        const boardSize = settings.boardLayout.reduce((acc, row) => acc + row.length, 0);
        const tileCount = Math.round(boardSize / (15 * 15) * 100);
        const defaults = getBagDefaults(bagLanguage, tileCount);
        settings.letterCounts = defaults.letterCounts;
        settings.letterValues = defaults.letterValues;
      }
      settings.bingoBonus = parseInt(this.bingoBonus.value, 10);
      settings.tileSystemSettings = {
        seed: this.randomSeedCheckbox.checked ? "" : this.randomSeed.value
      };
      const params = gameParamsFromSettings(settings);
      this.browser.setHash(params.toString());
      this.browser.reload();
    });
    this.cancelSettingsButton.addEventListener("click", () => {
      this.settingsDialog.hidden = true;
    });
  }
  _updatePlayerList(players) {
    this.playerList.innerHTML = "";
    players.forEach((player, index) => {
      const playerEntry = this.doc.createElement("div");
      playerEntry.className = "player-entry";
      const input = this.doc.createElement("input");
      input.type = "text";
      input.value = player.name;
      input.placeholder = t("ui.settings.player_placeholder", { index: index + 1 });
      playerEntry.appendChild(input);
      const removeButton = this.doc.createElement("button");
      removeButton.textContent = t("ui.buttons.remove_player");
      removeButton.onclick = () => {
        const currentPlayers = Array.from(this.playerList.querySelectorAll("input")).map((i) => ({ name: i.value }));
        currentPlayers.splice(index, 1);
        this._updatePlayerList(currentPlayers);
      };
      playerEntry.appendChild(removeButton);
      if (this.gameState.keepAllHistory && player.id !== undefined) {
        const historyParams = this.gameState.getHistoryUrlParamsForPlayer(player.id);
        const replayLink = this.doc.createElement("a");
        replayLink.className = "replay-link";
        const gameUrl = this.browser.getHref().replace(this.browser.getHash(), "");
        replayLink.href = gameUrl + "#" + historyParams;
        const linkText = this.doc.createTextNode(t("ui.game.join_link"));
        replayLink.appendChild(linkText);
        playerEntry.appendChild(replayLink);
      }
      this.playerList.appendChild(playerEntry);
    });
  }
  _handleDictChange() {
    const selectedValue = this.dictionaryType.value;
    if (selectedValue === "freeapi" || selectedValue === "wordlist") {
      this.dictionaryUrlContainer.hidden = false;
      this.dictionaryUrl.required = selectedValue === "wordlist";
    } else {
      this.dictionaryUrlContainer.hidden = true;
    }
    if (selectedValue !== "wordlist" && selectedValue !== "freeapi") {
      this.dictionaryUrl.value = "";
    }
  }
  _populateSettingsDialog() {
    const players = this.gameState.players;
    const localPlayerIndex = players.findIndex((p) => p.id === this.gameState.playerId);
    if (localPlayerIndex > 0) {
      const rotatedPlayers = [
        ...players.slice(localPlayerIndex),
        ...players.slice(0, localPlayerIndex)
      ];
      this._updatePlayerList(rotatedPlayers);
    } else {
      this._updatePlayerList(players);
    }
    this.dictionaryType.value = this.gameState.settings.dictionaryType;
    if (this.gameState.settings.dictionaryType === "wordlist" && typeof this.gameState.settings.dictionarySettings === "string" && this.dictionaryType.querySelector(`option[value="${this.gameState.settings.dictionarySettings}"]`)) {
      this.dictionaryType.value = this.gameState.settings.dictionarySettings;
    }
    this._handleDictChange();
    if (typeof this.gameState.settings.dictionarySettings === "string") {
      this.dictionaryUrl.value = this.gameState.settings.dictionarySettings;
    } else {
      this.dictionaryUrl.value = "";
    }
    this.bingoBonus.value = String(this.gameState.settings.bingoBonus);
    this.randomSeed.value = this.gameState.settings.tileSystemSettings.seed;
    this.randomSeedCheckbox.checked = true;
    this.randomSeed.disabled = true;
    this._populateTileDistributionDropdown();
  }
  _populateTileDistributionDropdown() {
    this.tileDistribution.innerHTML = "";
    for (const lang of getBagLanguages()) {
      const option = this.doc.createElement("option");
      option.value = lang.code;
      option.textContent = lang.name;
      this.tileDistribution.appendChild(option);
    }
    const bagParam = getBagParam(this.gameState.settings) ?? "";
    const langMatch = bagParam.match(/^([a-z][^.]+)$/);
    if (langMatch && hasBagDefaults(langMatch[1])) {
      this.tileDistribution.value = langMatch[1];
    } else {
      const option = this.doc.createElement("option");
      option.value = "wordlist";
      option.textContent = t("ui.settings.tile_distribution_options.custom");
      this.tileDistribution.appendChild(option);
      this.tileDistribution.value = "custom";
    }
  }
  showSettingsDialog() {
    if (this.settingsDialog.hidden) {
      this._populateSettingsDialog();
      this.settingsDialog.hidden = false;
      if (this.startGameButton) {
        this.startGameButton.focus();
      }
    } else {
      this.settingsDialog.hidden = true;
    }
  }
  debugContainer;
  initDebugDisplay(bufferedLogs) {
    const buttons = this.settingsDialog.querySelector(".buttons");
    if (!buttons)
      return;
    this.debugContainer = this.doc.createElement("div");
    this.debugContainer.id = "debug-console";
    this.debugContainer.style.height = "150px";
    this.debugContainer.style.overflowY = "scroll";
    this.debugContainer.style.border = "1px solid #ccc";
    this.debugContainer.style.padding = "5px";
    this.debugContainer.style.marginTop = "10px";
    buttons.after(this.debugContainer);
    for (const message of bufferedLogs) {
      this.addDebugMessage(message);
    }
  }
  addDebugMessage(message) {
    if (!this.debugContainer)
      return;
    const p = this.doc.createElement("pre");
    p.style.margin = "0";
    p.style.fontFamily = "monospace";
    p.textContent = message;
    this.debugContainer.appendChild(p);
    this.debugContainer.scrollTop = this.debugContainer.scrollHeight;
  }
}

// view/view.ts
class View {
  gameContainer;
  boardContainer;
  boardTransformer;
  rackContainer;
  exchangeContainer;
  scorePanel;
  bagTileCountContainer;
  gameState;
  gameSetup;
  dropTargetMap = new Map;
  doc;
  constructor(gameState, browser) {
    this.gameState = gameState;
    this.doc = browser.getDocument();
    this.gameContainer = this.doc.getElementById("game-container");
    this.boardContainer = this.gameContainer.querySelector("#board-container");
    this.boardTransformer = this.doc.createElement("div");
    this.boardTransformer.id = "board-transformer";
    this.boardContainer.appendChild(this.boardTransformer);
    this.rackContainer = this.gameContainer.querySelector("#rack-container");
    this.exchangeContainer = this.gameContainer.querySelector("#exchange-container");
    this.scorePanel = this.gameContainer.querySelector("#score-panel");
    this.bagTileCountContainer = this.gameContainer.querySelector("#bag-tile-count-container");
    this.gameSetup = new GameSetup(gameState, browser);
    this.gameState.addEventListener("turnchange", () => this.renderScores());
  }
  addTileToElement(element, tile, assignedLetter) {
    element.textContent = "";
    const letterDiv = this.doc.createElement("div");
    letterDiv.className = "letter";
    letterDiv.textContent = assignedLetter || tile.letter || "?";
    element.appendChild(letterDiv);
    if (!tile.isBlank) {
      const valueDiv = this.doc.createElement("div");
      valueDiv.className = "value";
      valueDiv.textContent = String(tile.value);
      element.appendChild(valueDiv);
    }
  }
  addBonusTextToSquare(squareDiv, square) {
    const bonusSpan = this.doc.createElement("span");
    bonusSpan.className = "bonus-text";
    if (square.letterBonus === 2)
      bonusSpan.textContent = "2L";
    if (square.letterBonus === 3)
      bonusSpan.textContent = "3L";
    if (square.wordBonus === 2)
      bonusSpan.textContent = "2W";
    if (square.wordBonus === 3)
      bonusSpan.textContent = "3W";
    if (bonusSpan.textContent)
      squareDiv.appendChild(bonusSpan);
  }
  renderSquare(row, col, squareDiv = this.getElementByLocation(row, col)) {
    if (!squareDiv)
      return;
    squareDiv.innerHTML = "";
    squareDiv.classList.remove("placed");
    const square = this.gameState.board.squares[row][col];
    if (square.tile) {
      this.addTileToElement(squareDiv, square.tile, square.assignedLetter);
    } else {
      const placedTile = this.gameState.tilesHeld.find((p) => p.row === row && p.col === col);
      if (placedTile) {
        this.addTileToElement(squareDiv, placedTile.tile, placedTile.assignedLetter);
        squareDiv.classList.add("placed");
        squareDiv.tabIndex = 0;
      } else {
        this.addBonusTextToSquare(squareDiv, square);
      }
    }
  }
  renderBoard() {
    this.boardTransformer.innerHTML = "";
    const dimension = this.gameState.board.squares.length;
    this.boardTransformer.style.gridTemplateColumns = `repeat(${dimension}, 1fr)`;
    this.boardTransformer.style.gridTemplateRows = `repeat(${dimension}, 1fr)`;
    const baseSquareSize = 40;
    const baseFontSize = 24;
    const squareSize = 601 / dimension;
    const fontSize = squareSize / baseSquareSize * baseFontSize;
    this.boardTransformer.style.fontSize = `${fontSize}px`;
    const centerSquare = this.gameState.board.centerSquare;
    for (let r = 0;r < this.gameState.board.squares.length; r++) {
      const row = this.gameState.board.squares[r];
      if (!row)
        throw new Error(`Invalid board: Row ${r} is missing.`);
      for (let c = 0;c < row.length; c++) {
        const square = row[c];
        if (!square)
          throw new Error(`Invalid board: Square ${r},${c} is missing.`);
        const squareDiv = this.doc.createElement("div");
        squareDiv.className = "square";
        if (square.letterBonus === 2)
          squareDiv.classList.add("dl");
        if (square.letterBonus === 3)
          squareDiv.classList.add("tl");
        if (square.wordBonus === 2)
          squareDiv.classList.add("dw");
        if (square.wordBonus === 3)
          squareDiv.classList.add("tw");
        if (r === centerSquare.row && c === centerSquare.col)
          squareDiv.classList.add("center");
        squareDiv.dataset.row = String(r);
        squareDiv.dataset.col = String(c);
        this.boardTransformer.appendChild(squareDiv);
        this.renderSquare(r, c, squareDiv);
      }
    }
  }
  renderScores() {
    this.scorePanel.innerHTML = "";
    const currentPlayer = this.gameState.playerWhoseTurnItIs;
    let maxScore = -Infinity;
    if (this.gameState.isGameOver) {
      const scores = [...this.gameState.board.scores.values()];
      if (scores.length > 0) {
        maxScore = Math.max(...scores);
      }
    }
    for (const player of this.gameState.players) {
      const score = this.gameState.board.scores.get(player.id) ?? 0;
      const scoreDiv = this.doc.createElement("div");
      scoreDiv.className = "player-score";
      if (player.id === currentPlayer?.id) {
        scoreDiv.classList.add("current-player");
      }
      const nameSpan = this.doc.createElement("span");
      nameSpan.textContent = player.name;
      const scoreSpan = this.doc.createElement("span");
      scoreSpan.textContent = `: ${score}`;
      if (this.gameState.isGameOver && score === maxScore) {
        scoreSpan.textContent += " \uD83C\uDF89";
      }
      const editButton = this.doc.createElement("span");
      editButton.textContent = " ✏️";
      editButton.className = "edit-button";
      editButton.style.cursor = "pointer";
      editButton.addEventListener("click", () => {
        const input = this.doc.createElement("input");
        input.type = "text";
        input.value = player.name;
        scoreDiv.replaceChild(input, nameSpan);
        input.focus();
        const save = () => {
          if (input.value && input.value !== player.name) {
            this.gameState.changePlayerName(player.id, input.value);
          }
        };
        const cancel = () => {
          scoreDiv.replaceChild(nameSpan, input);
        };
        input.addEventListener("blur", save);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            save();
          } else if (e.key === "Escape") {
            cancel();
          }
        });
      });
      if (player.id === this.gameState.playerId) {
        scoreDiv.appendChild(editButton);
      }
      scoreDiv.appendChild(nameSpan);
      scoreDiv.appendChild(scoreSpan);
      this.scorePanel.appendChild(scoreDiv);
    }
  }
  renderRackSpot(rackName, col) {
    const spotElement = this.getElementByLocation(rackName, col);
    if (!spotElement)
      return;
    spotElement.innerHTML = "";
    spotElement.removeAttribute("tabIndex");
    spotElement.className = "";
    const tilePlacement = this.gameState.tilesHeld.find((p) => p.row === rackName && p.col === col);
    if (tilePlacement) {
      spotElement.className = "tile";
      this.addTileToElement(spotElement, tilePlacement.tile, tilePlacement.assignedLetter);
      spotElement.tabIndex = 0;
    } else {
      spotElement.className = "tile-spot";
    }
  }
  renderRacklike(container, name) {
    container.innerHTML = "";
    for (let i = 0;i < this.gameState.settings.rackCapacity; i++) {
      const spotDiv = this.doc.createElement("div");
      spotDiv.dataset.row = name;
      spotDiv.dataset.col = String(i);
      container.appendChild(spotDiv);
      this.renderRackSpot(name, i);
    }
  }
  renderRack() {
    this.renderRacklike(this.rackContainer, "rack");
    this.renderRacklike(this.exchangeContainer, "exchange");
  }
  renderTileSpot(row, col) {
    if (isBoardPlacementRow(row)) {
      this.renderSquare(row, col);
    } else {
      this.renderRackSpot(row, col);
    }
  }
  renderBagTileCount() {
    this.bagTileCountContainer.textContent = t("ui.bag_tile_count", { count: this.gameState.numberOfTilesInBag });
  }
  renderActionButtons() {
    const passExchangeButton = this.doc.getElementById("pass-exchange");
    const playWordButton = this.doc.getElementById("play-word");
    const isLocalPlayerTurn = this.gameState.playerWhoseTurnItIs?.id === this.gameState.playerId;
    passExchangeButton.disabled = !isLocalPlayerTurn;
    playWordButton.disabled = !isLocalPlayerTurn;
    const count = this.gameState.exchangeTilesCount;
    if (count === 0) {
      passExchangeButton.title = t("ui.buttons.pass_turn");
    } else {
      passExchangeButton.title = t("ui.buttons.exchange_count", { count });
    }
  }
  getElementByLocation(row, col) {
    const selector = `[data-row="${row}"][data-col="${col}"]`;
    if (typeof row === "number") {
      return this.boardTransformer.querySelector(selector);
    }
    return this.doc.querySelector(selector);
  }
  clearDropTarget(dropTargetId) {
    const dropTarget = this.dropTargetMap.get(dropTargetId);
    if (dropTarget) {
      this.dropTargetMap.delete(dropTargetId);
      if (!this.dropTargetMap.values().find((v2) => v2.row === dropTarget.row && v2.col === dropTarget.col)) {
        const el = this.getElementByLocation(dropTarget.row, dropTarget.col);
        el?.classList.remove("drop-target");
      }
    }
  }
  setDropTarget(dropTargetId, row, col) {
    this.clearDropTarget(dropTargetId);
    const el = this.getElementByLocation(row, col);
    if (el) {
      el.classList.add("drop-target");
      this.dropTargetMap.set(dropTargetId, { row, col });
    }
  }
  getDropTarget(dropTargetId) {
    return this.dropTargetMap.get(dropTargetId);
  }
  deselect(dropTargetId, selectedTile) {
    const prevSelected = this.getElementByLocation(selectedTile.row, selectedTile.col);
    prevSelected?.classList.remove("selected");
    this.clearDropTarget(dropTargetId);
  }
  select(row, col) {
    const element = this.getElementByLocation(row, col);
    element?.classList.add("selected");
  }
  createGhostTile(originalTileElement) {
    const ghostTile = originalTileElement.cloneNode(true);
    ghostTile.classList.remove("selected");
    ghostTile.classList.add("ghost-tile");
    this.doc.body.appendChild(ghostTile);
    return ghostTile;
  }
  removeGhostTile(ghostTileElement) {
    if (ghostTileElement && ghostTileElement.parentNode) {
      ghostTileElement.parentNode.removeChild(ghostTileElement);
    }
  }
  async showConfirmationDialog(title, showCopyCheckbox, preview) {
    const content = this.doc.createElement("div");
    if (preview) {
      const details = this.doc.createElement("div");
      details.textContent = t("ui.dialog.play_word_details", {
        word: preview.mainWordForUrl,
        score: preview.score
      });
      content.appendChild(details);
    }
    let copyUrlCheckbox;
    if (showCopyCheckbox) {
      const copyUrlContainer = this.doc.createElement("div");
      const label = this.doc.createElement("label");
      const checkbox = this.doc.createElement("input");
      checkbox.type = "checkbox";
      checkbox.id = "copy-url-checkbox";
      checkbox.checked = true;
      label.appendChild(checkbox);
      label.appendChild(this.doc.createTextNode(t("ui.dialog.copy_turn_url")));
      copyUrlContainer.appendChild(label);
      copyUrlCheckbox = checkbox;
      content.appendChild(copyUrlContainer);
    }
    const okButtonText = t("ui.buttons.ok");
    const dialog = new Dialog(this.doc, title, content, [okButtonText, t("ui.buttons.cancel_settings")]);
    const result = await dialog.show();
    return {
      confirmed: result === okButtonText,
      copyUrl: result === okButtonText && (copyUrlCheckbox?.checked ?? false)
    };
  }
  showSettingsDialog() {
    this.gameSetup.showSettingsDialog();
  }
  setBoardTransform(scale, x, y) {
    this.boardTransformer.style.transform = `scale(${scale}) translate(${x}px, ${y}px)`;
  }
  getBoardContainer() {
    return this.boardContainer;
  }
  showInfoPopup(words, targetElement) {
    const popup = this.doc.createElement("div");
    popup.className = "info-popup";
    const title = this.doc.createElement("h3");
    title.textContent = "Word Definitions";
    popup.appendChild(title);
    const list = this.doc.createElement("ul");
    words.forEach((word) => {
      const item = this.doc.createElement("li");
      const link = this.doc.createElement("a");
      link.href = `https://en.wiktionary.org/wiki/${word.toLowerCase()}`;
      link.textContent = word;
      link.target = "_blank";
      item.appendChild(link);
      list.appendChild(item);
    });
    popup.appendChild(list);
    const close = () => {
      if (popup.parentNode) {
        popup.parentNode.removeChild(popup);
      }
      this.doc.removeEventListener("pointerdown", pointerdown);
      this.boardContainer.removeEventListener("pointerdown", pointerdown);
      this.doc.removeEventListener("keydown", keydown);
    };
    const pointerdown = (e) => {
      if (!popup.contains(e.target)) {
        close();
      }
    };
    const keydown = (e) => {
      if (e.key === "Escape") {
        close();
      }
    };
    this.doc.body.appendChild(popup);
    const rect = targetElement.getBoundingClientRect();
    popup.style.left = `${rect.left}px`;
    popup.style.top = `${rect.bottom}px`;
    this.doc.addEventListener("pointerdown", pointerdown);
    this.boardContainer.addEventListener("pointerdown", pointerdown);
    this.doc.addEventListener("keydown", keydown);
  }
}

// controller/key_handler.ts
class KeyHandler {
  gameState;
  view;
  selectedTile = null;
  constructor(gameState, view) {
    this.gameState = gameState;
    this.view = view;
  }
  select(row, col) {
    this.deselect();
    this.selectedTile = { row, col };
    this.view.select(row, col);
    this.view.setDropTarget("keyboard", row, col);
  }
  deselect() {
    if (!this.selectedTile)
      return;
    this.view.deselect("keyboard", this.selectedTile);
    this.selectedTile = null;
  }
  keydown(evt) {
    const target = evt.target;
    if (!target.dataset.col || !target.dataset.row)
      return;
    const col = parseInt(target.dataset.col, 10);
    const rowStr = target.dataset.row;
    const row = rowStr === "rack" ? "rack" : rowStr === "exchange" ? "exchange" : parseInt(rowStr, 10);
    switch (evt.key) {
      case " ":
      case "Enter": {
        evt.preventDefault();
        if (this.selectedTile) {
          const dropTarget = this.view.getDropTarget("keyboard");
          if (!dropTarget)
            return;
          const { row: toRow, col: toCol } = dropTarget;
          if (isBoardPlacementRow(toRow)) {
            if (this.gameState.board.squares[toRow]?.[toCol]?.tile)
              return;
            if (this.gameState.tilesHeld.find((p) => p.row === toRow && p.col === toCol))
              return;
          }
          try {
            const selectedPlacement = this.gameState.tilesHeld.find((p) => p.row === this.selectedTile.row && p.col === this.selectedTile.col);
            let assignedLetter;
            if (selectedPlacement?.tile.isBlank && isBoardPlacementRow(toRow)) {
              const letter = prompt("Enter a letter for the blank tile:");
              if (!letter || letter.length !== 1 || !/^[a-zA-Z]$/.test(letter)) {
                alert("Invalid letter. Please enter a single letter.");
                return;
              }
              assignedLetter = letter.toUpperCase();
            }
            this.gameState.moveTile(this.selectedTile.row, this.selectedTile.col, toRow, toCol, assignedLetter);
            this.deselect();
          } catch (e) {
            alert(e);
          }
        } else {
          this.select(row, col);
          this.view.setDropTarget("keyboard", row, col);
        }
        break;
      }
      case "Escape": {
        evt.preventDefault();
        if (this.selectedTile) {
          const previouslySelected = this.view.getElementByLocation(this.selectedTile.row, this.selectedTile.col);
          this.deselect();
          previouslySelected?.focus();
        }
        break;
      }
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight": {
        evt.preventDefault();
        this.moveDropTarget(evt.key);
        break;
      }
    }
  }
  moveDropTarget(key) {
    const dropTarget = this.view.getDropTarget("keyboard");
    if (!this.selectedTile || !dropTarget)
      return;
    let { row: r, col: c } = dropTarget;
    const rackCapacity = this.gameState.settings.rackCapacity;
    const boardCenterCol = this.gameState.board.centerSquare.col;
    const rackCenter = Math.ceil((rackCapacity - 1) / 2);
    const boardCenterRow = this.gameState.board.centerSquare.row;
    const boardWidth = this.gameState.board.squares[boardCenterRow].length;
    const boardHeight = this.gameState.board.squares.length;
    switch (key) {
      case "ArrowUp":
        if (r === "exchange") {
          r = "rack";
        } else if (r === "rack") {
          const offset = c - rackCenter;
          c = boardCenterCol + offset;
          c = Math.max(0, Math.min(boardWidth - 1, c));
          r = boardHeight - 1;
        } else if (r > 0) {
          r--;
        }
        break;
      case "ArrowDown":
        if (r === "rack") {
          r = "exchange";
        } else if (r !== "exchange") {
          if (r === boardHeight - 1) {
            const offset = c - boardCenterCol;
            c = rackCenter + offset;
            c = Math.max(0, Math.min(rackCapacity - 1, c));
            r = "rack";
          } else if (r < boardHeight - 1) {
            r++;
          }
        }
        break;
      case "ArrowLeft":
        if (r === "rack" && c === 0 && boardWidth > 0) {
          r = boardCenterRow;
          c = boardWidth - 1;
        } else if (c > 0) {
          c--;
        }
        break;
      case "ArrowRight":
        if (r === "rack" || r === "exchange") {
          if (c < rackCapacity - 1) {
            c++;
          }
        } else {
          if (c === boardWidth - 1) {
            r = "rack";
            c = 0;
          } else {
            c++;
          }
        }
        break;
    }
    this.view.setDropTarget("keyboard", r, c);
  }
}

// controller/pointer_handler.ts
class PointerHandler {
  gameState;
  view;
  pointerInfoMap = new Map;
  scale = 1;
  panX = 0;
  panY = 0;
  lastTap = 0;
  longTapTimeout = 500;
  longTapInfo = null;
  currentTapTarget = null;
  longTapPoppedUp = false;
  constructor(gameState, view) {
    this.gameState = gameState;
    this.view = view;
  }
  scrollWindowBy(dx, dy) {
    window.scrollBy(dx, dy);
  }
  handleLongTap() {
    if (!this.longTapInfo || !this.currentTapTarget)
      return;
    const { row, col, element } = this.currentTapTarget;
    let popupShown = false;
    if (isBoardPlacementRow(row)) {
      const words = this.gameState.getWordsAt(row, col);
      if (words.length > 0) {
        this.view.showInfoPopup(words, element);
        popupShown = true;
      }
    }
    this.pointerInfoMap.delete(this.longTapInfo.pointerId);
    if (popupShown) {
      this.longTapPoppedUp = true;
    }
    this.longTapInfo = null;
  }
  findNearestRackOrExchangeSpot(container, clientX, clientY) {
    let bestSpot = null;
    let minDistance = Infinity;
    const spots = Array.from(container.querySelectorAll(".tile-spot, .tile, .placed"));
    for (const spot of spots) {
      if (!(spot instanceof HTMLElement))
        continue;
      const rect = spot.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const distance = Math.hypot(clientX - centerX, clientY - centerY);
      if (distance < minDistance) {
        minDistance = distance;
        const rowStr = spot.dataset.row;
        const row = rowStr === "rack" ? "rack" : rowStr === "exchange" ? "exchange" : parseInt(rowStr, 10);
        const col = parseInt(spot.dataset.col, 10);
        bestSpot = { row, col };
      }
    }
    return bestSpot;
  }
  updateTransform() {
    this.scale = Math.max(1, Math.min(4, this.scale));
    const boardRect = this.view.getBoardContainer().getBoundingClientRect();
    const maxPanX = (this.scale * boardRect.width - boardRect.width) / this.scale;
    const maxPanY = (this.scale * boardRect.height - boardRect.height) / this.scale;
    const oldPanX = this.panX;
    const oldPanY = this.panY;
    this.panX = Math.max(-maxPanX, Math.min(0, this.panX));
    this.panY = Math.max(-maxPanY, Math.min(0, this.panY));
    this.view.setBoardTransform(this.scale, this.panX, this.panY);
    return {
      overshootX: oldPanX - this.panX,
      overshootY: oldPanY - this.panY
    };
  }
  pointerCancel(evt) {
    if (this.longTapInfo?.pointerId === evt.pointerId) {
      window.clearTimeout(this.longTapInfo.timer);
      this.longTapInfo = null;
    }
    this.currentTapTarget = null;
    const info = this.pointerInfoMap.get(evt.pointerId);
    if (info)
      console.debug(`Pointer cancel: ${evt.pointerId} (${info.x.toFixed(2)},${info.y.toFixed(2)})`);
    this.pointerInfoMap.delete(evt.pointerId);
    this.view.clearDropTarget(evt.pointerId);
  }
  pointerDown(evt) {
    if (evt.button !== 0)
      return;
    const target = evt.target;
    const tapInfo = {
      downX: evt.clientX,
      downY: evt.clientY,
      x: evt.clientX,
      y: evt.clientY,
      pointerMoved: false
    };
    let tileTarget = target.closest(".tile, .placed");
    if (!tileTarget) {
      const square = target.closest(".square");
      if (square?.querySelector(".letter")) {
        tileTarget = square;
      }
    }
    if (tileTarget instanceof HTMLElement) {
      evt.preventDefault();
      evt.stopPropagation();
      const col = parseInt(tileTarget.dataset.col, 10);
      const rowStr = tileTarget.dataset.row;
      const row = rowStr === "rack" ? "rack" : rowStr === "exchange" ? "exchange" : parseInt(rowStr, 10);
      this.currentTapTarget = { row, col, element: tileTarget };
      const dragInfo = {
        ...tapInfo,
        draggingTile: { row, col, element: tileTarget },
        ghostTile: null
      };
      this.pointerInfoMap.set(evt.pointerId, dragInfo);
      if (this.longTapInfo) {
        window.clearTimeout(this.longTapInfo.timer);
      }
      this.longTapInfo = {
        timer: window.setTimeout(() => this.handleLongTap(), this.longTapTimeout),
        pointerId: evt.pointerId
      };
    } else if (target.closest("#board-container")) {
      evt.preventDefault();
      evt.stopPropagation();
      this.currentTapTarget = null;
      const panInfo = {
        ...tapInfo,
        draggingTile: null
      };
      this.pointerInfoMap.set(evt.pointerId, panInfo);
    }
  }
  pointerMove(evt) {
    const info = this.pointerInfoMap.get(evt.pointerId);
    if (!info)
      return;
    evt.preventDefault();
    if (!info.pointerMoved && Math.hypot(evt.clientX - info.downX, evt.clientY - info.downY) > 5) {
      info.pointerMoved = true;
      if (this.longTapInfo?.pointerId === evt.pointerId) {
        window.clearTimeout(this.longTapInfo.timer);
        this.longTapInfo = null;
      }
    }
    if (!info.draggingTile) {
      const panningPointerInfos = [...this.pointerInfoMap.values().filter((anyInfo) => !anyInfo.draggingTile)];
      const panningPointerCount = panningPointerInfos.length;
      const midpointBefore = panningPointerInfos.reduce((sum, curr) => {
        return {
          x: sum.x + curr.x / panningPointerCount,
          y: sum.y + curr.y / panningPointerCount
        };
      }, { x: 0, y: 0 });
      const getMaxDistance = (midpoint, points) => {
        return Math.max(...points.map((p) => Math.hypot(midpoint.x - p.x, midpoint.y - p.y)));
      };
      const maxDistanceBefore = getMaxDistance(midpointBefore, panningPointerInfos);
      const midpointAfter = {
        x: midpointBefore.x + (evt.clientX - info.x) / panningPointerCount,
        y: midpointBefore.y + (evt.clientY - info.y) / panningPointerCount
      };
      const pointsAfter = [
        { x: evt.clientX, y: evt.clientY },
        ...panningPointerInfos.filter((anyInfo) => anyInfo !== info)
      ];
      const maxDistanceAfter = getMaxDistance(midpointAfter, pointsAfter);
      if (maxDistanceBefore > 0 && maxDistanceAfter > 0) {
        const multiplier = maxDistanceAfter / maxDistanceBefore;
        const boardRect = this.view.getBoardContainer().getBoundingClientRect();
        const boardX = midpointBefore.x - boardRect.left;
        const boardY = midpointBefore.y - boardRect.top;
        this.panX -= boardX * (multiplier - 1) / this.scale;
        this.panY -= boardY * (multiplier - 1) / this.scale;
        this.scale *= multiplier;
      }
      this.panX += (midpointAfter.x - midpointBefore.x) / this.scale;
      this.panY += (midpointAfter.y - midpointBefore.y) / this.scale;
      const { overshootX, overshootY } = this.updateTransform();
      if (panningPointerCount === 1) {
        this.scrollWindowBy(-overshootX * this.scale, -overshootY * this.scale);
      }
    } else if (info.draggingTile && info.pointerMoved) {
      if (!info.ghostTile) {
        info.ghostTile = this.view.createGhostTile(info.draggingTile.element);
        info.draggingTile.element.classList.add("dragging");
      }
      info.ghostTile.style.left = `${evt.clientX}px`;
      info.ghostTile.style.top = `${evt.clientY}px`;
      info.ghostTile.style.display = "none";
      const targetElement = document.elementFromPoint(evt.clientX, evt.clientY);
      info.ghostTile.style.display = "";
      if (targetElement) {
        const dropTarget = targetElement.closest(".square, .tile-spot, .tile, .placed");
        if (dropTarget instanceof HTMLElement && dropTarget.dataset.row && dropTarget.dataset.col) {
          const toRowStr = dropTarget.dataset.row;
          const toRow = toRowStr === "rack" ? "rack" : toRowStr === "exchange" ? "exchange" : parseInt(toRowStr, 10);
          const toCol = parseInt(dropTarget.dataset.col, 10);
          this.view.setDropTarget(evt.pointerId, toRow, toCol);
        } else {
          const rackOrExchange = targetElement.closest("#rack-container, #exchange-container");
          if (rackOrExchange instanceof HTMLElement) {
            const nearestSpot = this.findNearestRackOrExchangeSpot(rackOrExchange, evt.clientX, evt.clientY);
            if (nearestSpot) {
              this.view.setDropTarget(evt.pointerId, nearestSpot.row, nearestSpot.col);
            } else {
              this.view.clearDropTarget(evt.pointerId);
            }
          } else {
            this.view.clearDropTarget(evt.pointerId);
          }
        }
      }
    }
    info.x = evt.clientX;
    info.y = evt.clientY;
  }
  pointerUp(evt) {
    if (this.longTapPoppedUp) {
      this.longTapPoppedUp = false;
      return;
    }
    if (this.longTapInfo?.pointerId === evt.pointerId) {
      window.clearTimeout(this.longTapInfo.timer);
      this.longTapInfo = null;
    }
    this.currentTapTarget = null;
    const info = this.pointerInfoMap.get(evt.pointerId);
    if (!info)
      return;
    if (info.draggingTile && info.ghostTile) {
      const dropTarget = this.view.getDropTarget(evt.pointerId);
      if (dropTarget) {
        try {
          const fromRow = info.draggingTile.row;
          const fromCol = info.draggingTile.col;
          const toRow = dropTarget.row;
          const toCol = dropTarget.col;
          const selectedPlacement = this.gameState.tilesHeld.find((p) => p.row === fromRow && p.col === fromCol);
          if (selectedPlacement?.tile.isBlank && isBoardPlacementRow(toRow)) {
            const letter = prompt("Enter a letter for the blank tile:");
            if (letter && /^[a-zA-Z]$/.test(letter)) {
              this.gameState.moveTile(fromRow, fromCol, toRow, toCol, letter.toUpperCase());
            } else if (letter !== null) {
              alert("Invalid letter. Please enter a single letter.");
            }
          } else {
            this.gameState.moveTile(fromRow, fromCol, toRow, toCol);
          }
        } catch (e) {
          alert(e);
        }
      }
      this.view.removeGhostTile(info.ghostTile);
      info.draggingTile.element.classList.remove("dragging");
    } else if (evt.target.closest("#board-container") && !info.pointerMoved) {
      const now = Date.now();
      if (now - this.lastTap < 300) {
        if (this.scale > 1) {
          this.scale = 1;
          this.panX = 0;
          this.panY = 0;
        } else {
          let toBoardCoordinate = function(evtCoordinate, boardLo, boardHi, squareLength) {
            const boardCoordinate = evtCoordinate - boardLo;
            const boardLength = boardHi - boardLo;
            if (boardCoordinate < squareLength)
              return 0;
            if (boardCoordinate + squareLength > boardLength)
              return boardLength;
            return boardCoordinate;
          };
          this.scale = 1.8;
          const boardRect = this.view.getBoardContainer().getBoundingClientRect();
          const square = evt.target.closest(".square")?.getBoundingClientRect();
          const boardX = toBoardCoordinate(evt.clientX, boardRect.left, boardRect.right, square ? square.right - square.left : 0);
          const boardY = toBoardCoordinate(evt.clientY, boardRect.top, boardRect.bottom, square ? square.bottom - square.top : 0);
          this.panX = boardX * (1 - this.scale) / this.scale;
          this.panY = boardY * (1 - this.scale) / this.scale;
        }
        this.updateTransform();
      }
      this.lastTap = now;
    }
    this.pointerInfoMap.delete(evt.pointerId);
    this.view.clearDropTarget(evt.pointerId);
  }
}

// controller/controller.ts
class Controller {
  gameState;
  view;
  browser;
  keyHandler;
  pointerHandler;
  constructor(gameState, view, browser) {
    this.gameState = gameState;
    this.view = view;
    this.browser = browser;
    this.keyHandler = new KeyHandler(gameState, view);
    this.pointerHandler = new PointerHandler(gameState, view);
    this.attachEventListeners();
  }
  async playWordClick() {
    const preview = this.gameState.getTurnPreview();
    if (isTurnPreviewSuccess(preview)) {
      const { confirmed, copyUrl } = await this.view.showConfirmationDialog(t("ui.dialog.play_word_title"), this.browser.hasClipboard(), preview);
      if (!confirmed)
        return;
      try {
        await this.gameState.playWord();
        if (copyUrl) {
          const url = new URL(this.browser.getHref());
          url.hash = this.gameState.turnUrlParams.toString();
          await this.browser.writeToClipboard(url.toString());
        }
      } catch (e) {
        alert(e instanceof PlayRejectedError ? e.message : e);
      }
    } else {
      alert(preview.error);
    }
  }
  async passOrExchangeClick() {
    const tileCount = this.gameState.exchangeTilesCount;
    const { confirmed, copyUrl } = await this.view.showConfirmationDialog(tileCount ? `Exchange ${tileCount}?` : "Pass Turn?", this.browser.hasClipboard());
    if (!confirmed)
      return;
    try {
      await this.gameState.passOrExchange();
      if (copyUrl) {
        const url = new URL(this.browser.getHref());
        url.hash = this.gameState.turnUrlParams.toString();
        await this.browser.writeToClipboard(url.toString());
      }
    } catch (e) {
      alert(e);
    }
  }
  attachEventListeners() {
    const doc = this.browser.getDocument();
    const gameContainer = doc.getElementById("game-container");
    gameContainer.addEventListener("pointerdown", this.pointerHandler.pointerDown.bind(this.pointerHandler));
    doc.addEventListener("pointermove", this.pointerHandler.pointerMove.bind(this.pointerHandler));
    doc.addEventListener("pointerup", this.pointerHandler.pointerUp.bind(this.pointerHandler));
    doc.addEventListener("pointercancel", this.pointerHandler.pointerCancel.bind(this.pointerHandler));
    gameContainer.addEventListener("keydown", this.keyHandler.keydown.bind(this.keyHandler));
    doc.getElementById("play-word").addEventListener("click", this.playWordClick.bind(this));
    doc.getElementById("pass-exchange").addEventListener("click", this.passOrExchangeClick.bind(this));
    doc.getElementById("recall-tiles").addEventListener("click", this.recallTilesClick.bind(this));
    doc.getElementById("game-setup").addEventListener("click", this.gameSetupClick.bind(this));
  }
  gameSetupClick() {
    this.view.showSettingsDialog();
  }
  recallTilesClick() {
    this.gameState.recallTiles();
  }
}

// view/i18n.ts
function initI18n(doc) {
  doc.querySelectorAll("[data-i18n]").forEach((element) => {
    const key = element.dataset.i18n;
    if (key) {
      const translation = t(key);
      if (translation !== key) {
        element.prepend(translation);
      }
    }
  });
  doc.querySelectorAll("[data-i18n-title]").forEach((element) => {
    const key = element.dataset.i18nTitle;
    if (key) {
      const translation = t(key);
      if (translation !== key) {
        element.title = translation;
      }
    }
  });
}

// browser.ts
class DomBrowser {
  reload() {
    console.log(`Reloading: ${window.location}`);
    window.location.reload();
  }
  getHash() {
    return window.location.hash;
  }
  getSearch() {
    return window.location.search;
  }
  setHash(hash) {
    window.location.hash = hash;
  }
  addHashChangeListener(listener) {
    window.addEventListener("hashchange", listener);
  }
  get localStorage() {
    return localStorage;
  }
  get languages() {
    return navigator.languages;
  }
  getDocument() {
    return document;
  }
  getURLSearchParams(query) {
    return new URLSearchParams(query);
  }
  getRandom() {
    return Math.random();
  }
  getHref() {
    return location.href;
  }
  writeToClipboard(text) {
    return navigator.clipboard.writeText(text);
  }
  hasClipboard() {
    return "clipboard" in navigator;
  }
  addPasteListener(listener) {
    window.addEventListener("paste", (event) => {
      const text = event.clipboardData?.getData("text/plain");
      if (text) {
        listener(text);
      }
    });
  }
  setLocation(url) {
    window.location.href = url;
  }
}

// app.ts
class App {
  browser;
  gameState;
  view;
  controller;
  bufferedLogs = [];
  constructor(browser) {
    this.browser = browser;
  }
  updateUrl() {
    const paramsStr = this.gameState.turnUrlParams.toString();
    if (this.browser.getHash().substr(1) !== paramsStr) {
      this.browser.setHash(paramsStr);
    }
  }
  async init() {
    if (this.browser.getURLSearchParams(this.browser.getSearch()).has("debug")) {
      this.initDebug();
    }
    await loadTranslations(...this.browser.languages);
    initI18n(this.browser.getDocument());
    const handleGameChange = async () => {
      const params = this.browser.getURLSearchParams(this.browser.getHash()?.substring(1) || "");
      const gidParam = params.get("gid");
      const gameId = gidParam ? toGameId(gidParam) : makeGameId();
      if (this.gameState?.gameId === gameId) {
        const hash = this.browser.getHash()?.substring(1);
        const paramsStr = this.gameState.turnUrlParams.toString();
        if (hash !== paramsStr) {
          await this.gameState.applyTurnParams(params);
        }
        return;
      }
      const savedGame = gidParam && this.browser.localStorage.getItem(makeStorageKey(gidParam));
      if (savedGame) {
        console.log(`Loaded ${gameId} from local storage${this.gameState ? "; switching from " + this.gameState.gameId + " to it" : ""}.`);
        this.gameState = GameState.fromJSON(JSON.parse(savedGame).game);
        this.gameState.settings.baseUrl = this.browser.getHref();
        this.gameState.storage = this.browser.localStorage;
        await this.gameState.applyTurnParams(params);
      } else if (this.gameState) {
        this.browser.reload();
        console.log("Switched to new game" + (gidParam ? ` "${gidParam}"` : "") + ".");
        return;
      } else {
        console.log("Switching to new game" + (gidParam ? ` "${gidParam}"` : "") + ".");
        if (!params.get("seed"))
          params.set("seed", String(Math.floor(1e6 * this.browser.getRandom())));
        if (!params.get("bag"))
          params.set("bag", "." + this.chooseBagLanguage());
        this.gameState = await GameState.fromParams(params, this.browser.getHref());
        this.gameState.storage = this.browser.localStorage;
      }
      this.updateUrl();
      this.view = new View(this.gameState, this.browser);
      this.controller = new Controller(this.gameState, this.view, this.browser);
      if (this.browser.getURLSearchParams(this.browser.getSearch()).has("debug")) {
        this.view.gameSetup.initDebugDisplay(this.bufferedLogs);
        this.bufferedLogs = [];
      }
      this.view.renderBoard();
      this.view.renderRack();
      this.view.renderScores();
      this.view.renderBagTileCount();
      this.view.renderActionButtons();
      this.gameState.addEventListener("tilemove", (evt) => {
        if (evt.detail.fromRow !== undefined && evt.detail.fromCol !== undefined) {
          this.view.renderTileSpot(evt.detail.fromRow, evt.detail.fromCol);
        }
        this.view.renderTileSpot(evt.detail.placement.row, evt.detail.placement.col);
        if (evt.detail.fromRow === "exchange" !== (evt.detail.placement.row === "exchange")) {
          this.view.renderActionButtons();
        }
        this.gameState.save();
      });
      this.gameState.addEventListener("turnchange", () => {
        this.view.renderBoard();
        this.view.renderRack();
        this.view.renderScores();
        this.view.renderBagTileCount();
        this.view.renderActionButtons();
        this.updateUrl();
      });
    };
    this.browser.addHashChangeListener(handleGameChange);
    await handleGameChange();
  }
  chooseBagLanguage() {
    for (const bagLanguage of this.browser.languages) {
      if (hasBagDefaults(bagLanguage))
        return bagLanguage;
    }
    return "en";
  }
  initDebug() {
    const app = this;
    for (const level of ["debug", "log", "warn", "error", "info"]) {
      const original = console[level];
      console[level] = function(...args) {
        original.apply(console, args);
        const message = args.map(String).join(" ");
        if (app.view?.gameSetup) {
          app.view.gameSetup.addDebugMessage(message);
        } else {
          app.bufferedLogs.push(message);
        }
      };
    }
  }
}
if (typeof window !== "undefined") {
  const app = new App(new DomBrowser);
  try {
    await app.init();
  } catch (e) {
    console.error(e);
    alert(e);
  }
}
</script></head>
  <body>
    <h1 data-i18n="ui.title"></h1>
    <div id="game-container">
      <div id="center-panel">
        <div id="score-panel"></div>
        <div id="board-container"></div>
      </div>
      <div id="controls-container">
        <div id="bag-tile-count-container"></div>
        <div id="rack-container"></div>
        <div id="exchange-container"></div>
        <div id="buttons-container">
          <button id="play-word" data-i18n-title="ui.buttons.play_word">✅</button>
          <button id="recall-tiles" data-i18n-title="ui.buttons.recall_tiles">❌</button>
          <button id="pass-exchange">♻</button>
          <button id="game-setup" data-i18n-title="ui.buttons.game_setup">⚙️</button>
        </div>
        <div id="settings-dialog" hidden>
          <div class="content">
            <div class="settings-group">
              <h3 data-i18n="ui.settings.players"></h3>
              <div id="player-list"></div>
              <button id="add-player-button" data-i18n="ui.buttons.add_player"></button>
            </div>
            <div class="settings-group">
              <h3 data-i18n="ui.settings.dictionary"></h3>
              <select id="dictionary-type">
                <option value="permissive" data-i18n="ui.settings.dictionary_options.permissive"></option>
                <option value="freeapi" data-i18n="ui.settings.dictionary_options.freeapi"></option>
                                <option value="en.yawl">English YAWL</option>
                <option value="test">Test Dictionary</option>
                <option value="wordlist" data-i18n="ui.settings.dictionary_options.wordlist"></option>
              </select>
              <div id="dictionary-url-container" hidden>
                <label data-i18n="ui.settings.dictionary_url_label"><input type="text" id="dictionary-url" placeholder="URL"></label>
              </div>
            </div>
            <div class="settings-group">
              <h3 data-i18n="ui.settings.tile_distribution"></h3>
              <select id="tile-distribution">
              </select>
            </div>
            <div class="settings-group">
              <h3 data-i18n="ui.settings.bingo_bonus"></h3>
              <input type="number" id="bingo-bonus">
            </div>
            <div class="settings-group">
              <h3 data-i18n="ui.settings.random_seed"></h3>
              <input type="tel" id="random-seed" pattern="[0-9]*" maxlength="10">
              <label>
                <input type="checkbox" id="random-seed-checkbox" checked>
                <span data-i18n="ui.settings.random_seed_random_label"></span>
              </label>
            </div>
          </div>
          <div class="buttons">
            <button id="start-game-with-settings" data-i18n="ui.buttons.start_game_with_settings"></button>
            <button id="cancel-settings" data-i18n="ui.buttons.cancel_settings"></button>
          </div>
          <div class="source-link">
            <a href="https://github.com/jtobey/sharewords">source code</a>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>

