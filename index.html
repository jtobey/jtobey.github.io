<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
  <style>/* style.css */
#game-container {
  display: flex;
  flex-direction: column;
}

#board-container {
  overflow: hidden;
  position: relative;
  touch-action: none;
  border: 1px solid #ccc;
  width: 601px;
  height: 601px;
}

#board-transformer {
  display: grid;
  transform-origin: 0 0;
  background-color: #ccc;
  width: 100%;
  height: 100%;
}

.square {
  box-sizing: border-box;
  position: relative;
  display: flex;
  background-color: #dda;
  border-bottom: 1px solid #ccc;
  border-right: 1px solid #ccc;
  justify-content: center;
  align-items:  center;
  width: auto;
  height: auto;
}

.bonus-text {
  color: #dda;
  font-family: sans-serif;
  font-size: .75em;
}

#controls-container {
  margin-top: 20px;
}

#buttons-container button {
  margin-bottom: 4px;
}

#rack-container, #exchange-container {
  display: flex;
  flex-direction: row;
  gap: 5px;
  margin-bottom: 10px;
}

.tile, .tile-spot {
  box-sizing: border-box;
  cursor: pointer;
  position: relative;
  touch-action: none;
  background-color: #eee;
  border: 1px solid #999;
  width: 40px;
  height: 40px;
  font-size: 24px;
}

.letter {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.value {
  position: absolute;
  font-size: 50%;
  bottom: 2px;
  left: 4px;
}

.tile-spot {
  cursor: default;
  background-color: #dda;
  border-color: #ccc;
}

.tile-spot[data-row="exchange"] {
  display: flex;
  justify-content: center;
  align-items:  center;
}

.tile-spot[data-row="exchange"]:before {
  content: "♻";
  color: #bbb;
  font-size: 28px;
}

.placed {
  touch-action: none;
  background-color: #90ee90b3 !important;
}

.square.dl {
  background-color: #c99;
}

.square.tl {
  background-color: #bbb;
}

.square.dw {
  background-color: #ff3;
}

.square.tw {
  background-color: #f90;
}

.square.center {
  background-color: #f6f;
}

.tile.selected, .placed.selected {
  border: 2px solid #00f !important;
}

.square.selected {
  background-color: #f0f0c0 !important;
}

.drop-target {
  box-shadow: inset 0 0 5px 2px #0000ff80;
}

.tile:focus, .square:focus, .placed:focus {
  outline: 3px solid #333;
}

#center-panel {
  display: flex;
  flex-direction: column;
  align-items:  center;
}

#score-panel, #bag-tile-count-container {
  display: flex;
  flex-direction: row;
  justify-content: center;
  margin-bottom: 10px;
  font-size: 18px;
}

.player-score {
  margin: 0 10px;
}

.current-player {
  font-weight: bold;
}

.ghost-tile {
  position: fixed;
  pointer-events: none;
  z-index: 1000;
  transition: transform .1s ease-out;
  transform: translate(-50%, -50%);
  box-shadow: 0 4px 8px #0003;
}

.tile.dragging, .placed.dragging {
  opacity: .4;
}

@media (min-width: 1024px) {
  #game-container {
    flex-direction: row;
    align-items:  flex-start;
  }

  #controls-container {
    margin-top: 0;
    margin-left: 20px;
  }
}

@media (max-width: 601px) {
  #board-container {
    width: 98vw;
    height: 98vw;
  }

  .square {
    width: auto;
    height: auto;
    font-size: 3.2vw;
  }

  .bonus-text {
    font-size: 2.4vw;
  }
}

dialog {
  border: 1px solid #ccc;
  border-radius: 5px;
  box-shadow: 0 2px 10px #0000001a;
}

#settings-dialog {
  background-color: #f9f9f9;
  border: 1px solid #ccc;
  border-radius: 5px;
  margin-top: 1em;
  padding: 1em;
}

.settings-group {
  margin-bottom: 1em;
}

.player-entry {
  display: flex;
  align-items:  center;
  margin-bottom: .5em;
}

.player-entry input {
  margin-right: .5em;
}

@media (prefers-color-scheme: dark) {
  #settings-dialog {
    color: #eee;
    background-color: #333;
  }
}

dialog::backdrop {
  background-color: #00000080;
}

dialog .buttons {
  display: flex;
  justify-content: flex-end;
  margin-top: 1em;
}

dialog button {
  margin-left: .5em;
}

@media (prefers-color-scheme: dark) {
  body {
    color: #eee;
    background-color: #121212;
  }

  h1 {
    color: #eee;
  }

  #board-container {
    border-color: #444;
  }

  #board-transformer {
    background-color: #111;
  }

  .square {
    background-color: #332;
    border-bottom: 1px solid #444;
    border-right: 1px solid #444;
  }

  .tile, .tile-spot {
    background-color: #444;
    border: 1px solid #777;
  }

  .tile-spot {
    background-color: #332;
    border-color: #444;
  }

  .tile-spot[data-row="exchange"]:before {
    color: #444;
  }

  .placed {
    background-color: #228822b3 !important;
  }

  .square.dl {
    background-color: #533;
  }

  .square.tl {
    background-color: #555;
  }

  .square.dw {
    background-color: #660;
  }

  .square.tw {
    background-color: #840;
  }

  .square.center {
    background-color: #505;
  }

  .tile.selected, .placed.selected {
    border: 2px solid #add8e6 !important;
  }

  .square.selected {
    background-color: #404010 !important;
  }

  .bonus-text {
    color: #332;
  }

  dialog {
    color: #eee;
    background-color: #222;
    border-color: #555;
  }
}
</style><script type="module">// game/validation.ts
function indicesOk(arrayLength, ...indices) {
  for (const index of indices) {
    if (index !== Math.floor(index) || index < 0 || index >= arrayLength)
      return false;
  }
  return true;
}
function checkIndices(arrayLength, ...indices) {
  for (const index of indices) {
    if (!indicesOk(arrayLength, index)) {
      throw new RangeError(`Index ${index} is out of range 0..${arrayLength - 1}.`);
    }
  }
}
function arraysEqual(a1, a2, warnIfNot = true) {
  if (a1.length === a2.length && a1.keys().every((k) => a1[k] === a2[k])) {
    return true;
  }
  if (warnIfNot)
    console.warn(`[${a1}] does not equal [${a2}]`);
  return false;
}

// game/bag_defaults.ts
var DEFAULT_BAG_LANGUAGE = "en";
var BAG_DEFAULTS = {
  en: {
    name: "English",
    letterCounts: {
      A: 9,
      B: 2,
      C: 2,
      D: 4,
      E: 12,
      F: 2,
      G: 2,
      H: 2,
      I: 9,
      J: 1,
      K: 1,
      L: 4,
      M: 2,
      N: 6,
      O: 8,
      P: 2,
      Q: 1,
      R: 6,
      S: 5,
      T: 6,
      U: 4,
      V: 2,
      W: 2,
      X: 1,
      Y: 2,
      Z: 1,
      "": 2
    },
    letterValues: {
      A: 1,
      B: 3,
      C: 4,
      D: 2,
      E: 1,
      F: 4,
      G: 3,
      H: 4,
      I: 1,
      J: 9,
      K: 5,
      L: 1,
      M: 3,
      N: 1,
      O: 1,
      P: 3,
      Q: 10,
      R: 1,
      S: 1,
      T: 1,
      U: 2,
      V: 5,
      W: 4,
      X: 8,
      Y: 4,
      Z: 10,
      "": 0
    }
  },
  es: {
    name: "Español",
    letterCounts: {
      A: 10,
      B: 2,
      C: 2,
      D: 3,
      E: 10,
      F: 2,
      G: 2,
      H: 2,
      I: 9,
      J: 2,
      K: 1,
      L: 4,
      M: 2,
      N: 6,
      Ñ: 1,
      O: 11,
      P: 2,
      Qu: 2,
      R: 5,
      S: 5,
      T: 4,
      U: 4,
      V: 2,
      X: 1,
      Y: 2,
      Z: 2,
      "": 2
    },
    letterValues: {
      A: 1,
      B: 3,
      C: 4,
      D: 2,
      E: 1,
      F: 4,
      G: 3,
      H: 4,
      I: 1,
      J: 4,
      K: 10,
      L: 1,
      M: 3,
      N: 1,
      Ñ: 5,
      O: 1,
      P: 3,
      Qu: 5,
      R: 1,
      S: 1,
      T: 1,
      U: 2,
      V: 4,
      X: 10,
      Y: 4,
      Z: 4,
      "": 0
    }
  }
};
function getBagLanguages() {
  return Object.entries(BAG_DEFAULTS).map(([key, value]) => ({
    code: key,
    name: value.name
  }));
}
function getBagDefaults(bagLanguage) {
  let defaults = BAG_DEFAULTS[bagLanguage];
  if (!defaults) {
    console.warn(`Unsupported bag language "${bagLanguage}", defaulting to "${DEFAULT_BAG_LANGUAGE}".`);
    defaults = BAG_DEFAULTS[DEFAULT_BAG_LANGUAGE];
  }
  return {
    letterCounts: new Map(Object.entries(defaults.letterCounts)),
    letterValues: new Map(Object.entries(defaults.letterValues))
  };
}

// game/player.ts
class Player {
  id;
  name;
  constructor({ id, name = `Player ${id}` }) {
    this.id = id;
    this.name = name;
  }
  equals(other) {
    return other instanceof Player && other.id === this.id && other.name === this.name;
  }
  toJSON() {
    return {
      id: this.id,
      name: this.name
    };
  }
  static fromJSON(json) {
    if (!(typeof json === "object" && typeof json.id === "string" && typeof json.name === "string")) {
      throw new TypeError(`Invalid Player serialization: ${JSON.stringify(json)}`);
    }
    return new Player(json);
  }
}

// game/version.ts
var PROTOCOL_VERSION = "0";

// game/settings.ts
function toGameId(gameIdStr) {
  return gameIdStr;
}
function fromGameId(gameId) {
  return gameId;
}
function makeGameId(now = Date.now()) {
  const ALPHABET = "123456789BCDFGHJKLMNPQRSTVWXYZbcdfghjkmnpqrstvwxyz";
  const base = BigInt(ALPHABET.length);
  let n = BigInt(Math.floor(now));
  let id = "";
  while (id.length < 7) {
    id = ALPHABET[Number(n % base)] + id;
    n /= base;
  }
  return toGameId(id);
}
var DEFAULT_BOARD_LAYOUT = [
  "D..d..T......T.",
  ".D...D...t.t..T",
  "..D.....t...t..",
  "d..D...t.....t.",
  "....D.t...D....",
  ".D...t.d.....t.",
  "T...d...d...t..",
  "...d.t...d.t...",
  "..d...t...t...T",
  ".d.....t.d...D.",
  "....D...d.D....",
  ".d.....d...D..d",
  "..d...d.....D..",
  "T..d.d...D...D.",
  ".T......T..d..D"
];
var DEFAULT_BINGO_BONUS = 42;
var DEFAULT_RACK_CAPACITY = 7;

class Settings {
  letterCounts;
  letterValues;
  gameId;
  version = PROTOCOL_VERSION;
  players = ["1", "2"].map((id) => new Player({ id }));
  maxPlayerNameLength = 50;
  boardLayout = [...DEFAULT_BOARD_LAYOUT];
  bingoBonus = DEFAULT_BINGO_BONUS;
  rackCapacity = DEFAULT_RACK_CAPACITY;
  tileSystemType = "honor";
  tileSystemSettings = { seed: "1" };
  dictionaryType = "permissive";
  dictionarySettings = null;
  constructor(bagDefaults, letterCounts = bagDefaults.letterCounts, letterValues = bagDefaults.letterValues) {
    this.letterCounts = letterCounts;
    this.letterValues = letterValues;
  }
  static forLanguage(bagLanguage) {
    return new Settings(getBagDefaults(bagLanguage));
  }
  toJSON() {
    return {
      version: this.version,
      players: this.players.map((p) => p.toJSON()),
      letterCounts: mapToJSON(this.letterCounts),
      letterValues: mapToJSON(this.letterValues),
      boardLayout: this.boardLayout,
      bingoBonus: this.bingoBonus,
      rackCapacity: this.rackCapacity,
      tileSystemType: this.tileSystemType,
      tileSystemSettings: this.tileSystemSettings,
      dictionaryType: this.dictionaryType,
      dictionarySettings: this.dictionarySettings
    };
  }
  static fromJSON(json) {
    if (!(typeof json === "object" && arraysEqual([...Object.keys(json)], [
      "version",
      "players",
      "letterCounts",
      "letterValues",
      "boardLayout",
      "bingoBonus",
      "rackCapacity",
      "tileSystemType",
      "tileSystemSettings",
      "dictionaryType",
      "dictionarySettings"
    ]) && json.version === PROTOCOL_VERSION && Array.isArray(json.players) && Array.isArray(json.boardLayout) && json.boardLayout.every((s) => typeof s === "string") && typeof json.bingoBonus === "number" && typeof json.rackCapacity === "number" && json.tileSystemType === "honor" && typeof json.tileSystemSettings === "object" && typeof json.tileSystemSettings.seed === "string" && ["permissive", "freeapi", "custom"].includes(json.dictionaryType))) {
      throw new TypeError(`Invalid Settings serialization: ${JSON.stringify(json)}`);
    }
    const settings = Settings.forLanguage("en");
    settings.version = json.version;
    settings.players = json.players.map(Player.fromJSON);
    settings.letterCounts = checkLetterToNumberMap("letterCounts", json.letterCounts);
    settings.letterValues = checkLetterToNumberMap("letterValues", json.letterValues);
    settings.boardLayout = json.boardLayout;
    settings.bingoBonus = json.bingoBonus;
    settings.rackCapacity = json.rackCapacity;
    settings.tileSystemType = json.tileSystemType;
    settings.tileSystemSettings = json.tileSystemSettings;
    settings.dictionaryType = json.dictionaryType;
    settings.dictionarySettings = json.dictionarySettings;
    return settings;
  }
}
function checkLetterToNumberMap(name, json) {
  function fail(msg) {
    throw new TypeError(`Invalid Settings.${name} serialization: ${msg}`);
  }
  if (!Array.isArray(json)) {
    if (typeof json !== "object")
      fail(`Type is "${typeof json}", not "object" as expected.`);
    json = [...Object.entries(json)];
  }
  json.forEach(([k, v]) => {
    if (typeof k !== "string")
      fail(`Letter ${k} has type "${typeof k}", not "string" as expected.`);
    if (typeof v !== "number")
      fail(`Letter ${k} has value ${v}, not a number as expected.`);
  });
  return new Map(json);
}
function mapToJSON(map) {
  if (!(map instanceof Map))
    return Object.entries(map);
  return [...map.entries()];
}

// game/tiles_state.ts
function checkIndicesForExchange(length, ...indices) {
  if ([...new Set(indices)].length !== indices.length) {
    throw new Error(`exchangeTileIndices contains duplicates: ${indices}`);
  }
  checkIndices(length, ...indices);
  return [...indices];
}

// game/turn.ts
function toTurnNumber(n) {
  return n;
}
function fromTurnNumber(turnNumber) {
  return turnNumber;
}
function nextTurnNumber(turnNumber) {
  return toTurnNumber(1 + fromTurnNumber(turnNumber));
}

class Turn {
  playerId;
  turnNumber;
  move;
  mainWord;
  row;
  col;
  vertical;
  blanks;
  extraParams;
  constructor(playerId, turnNumber, move) {
    this.playerId = playerId;
    this.turnNumber = turnNumber;
    this.move = move;
    if ("playTiles" in move && "exchangeTileIndices" in move) {
      throw new Error(`Can't exchange and play tiles on the same turn. Turn number is ${turnNumber}.`);
    }
  }
}
function getPlayerForTurnNumber(players, turnNumber) {
  return players[(fromTurnNumber(turnNumber) - 1) % players.length];
}
function updateTurnHistory({
  history,
  nextTurnNumber: nextTurnNumber2,
  finalTurnNumber,
  turns
}) {
  for (const turn of turns) {
    if (fromTurnNumber(turn.turnNumber) >= nextTurnNumber2) {
      break;
    }
    if (history.length) {
      const latestTurnNumber = fromTurnNumber(history.slice(-1)[0].turnNumber);
      if (fromTurnNumber(turn.turnNumber) <= latestTurnNumber)
        continue;
    }
    const params = new URLSearchParams;
    const addExtra = () => {
      if (turn.extraParams) {
        for (const [key, value] of turn.extraParams) {
          params.set(key, value);
        }
      }
    };
    if ("playTiles" in turn.move) {
      params.set("wl", `${turn.row}.${turn.col}`);
      addExtra();
      if (turn.blanks?.length)
        params.set("bt", turn.blanks.join("."));
      params.set(turn.vertical ? "wv" : "wh", turn.mainWord);
    } else if ("exchangeTileIndices" in turn.move) {
      params.set("ex", turn.move.exchangeTileIndices.join("."));
      addExtra();
    }
    history.push({ turnNumber: turn.turnNumber, paramsStr: String(params) });
    if (turn.turnNumber === finalTurnNumber)
      break;
  }
}

// game/tile.ts
var MIN_TILE_VALUE = 0;
var MAX_TILE_VALUE = 999999;

class Tile {
  letter;
  value;
  constructor({ letter, value }) {
    if (value !== Math.floor(value) || value < MIN_TILE_VALUE || value > MAX_TILE_VALUE) {
      throw new RangeError(`Invalid Tile value: ${value}`);
    }
    this.letter = letter;
    this.value = value;
  }
  get isBlank() {
    return this.letter === "";
  }
  equals(other) {
    return this.letter === other.letter && this.value === other.value;
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    return `${this.letter}:${this.value}`;
  }
  static fromJSON(json) {
    if (typeof json === "string") {
      const match = json.match(/(.*):([0-9]+)$/s);
      if (match) {
        const letter = match[1];
        const value = parseInt(match[2]);
        return new Tile({ letter, value });
      }
    }
    throw new TypeError(`invalid Tile serialization: ${JSON.stringify(json)}`);
  }
}
function isBoardPlacementRow(row) {
  return typeof row === "number";
}
function isBoardPlacement(tilePlacement) {
  return isBoardPlacementRow(tilePlacement.row);
}
function makeTiles({ letterCounts, letterValues }) {
  const tiles = [];
  for (const [letter, count] of letterCounts) {
    tiles.push(...Array(count).fill(new Tile({ letter, value: letterValues.get(letter) || 0 })));
  }
  return tiles;
}

// game/serializable.ts
function toJSON(s) {
  if (s && typeof s === "object" && "toJSON" in s)
    return s.toJSON();
  return s;
}

// game/bag.ts
class Bag {
  randomGenerator;
  tiles;
  constructor([...tiles], randomGenerator, shuffle = true) {
    this.randomGenerator = randomGenerator;
    this.tiles = tiles;
    if (shuffle)
      this.shuffle(0);
  }
  get size() {
    return this.tiles.length;
  }
  draw(numberOfTiles) {
    this.checkEnoughTiles(numberOfTiles);
    return this.tiles.splice(-numberOfTiles);
  }
  exchange(tilesToExchange) {
    const numberOfTiles = tilesToExchange.length;
    this.checkEnoughTiles(numberOfTiles);
    const drawnTiles = this.tiles.splice(-numberOfTiles, numberOfTiles, ...tilesToExchange);
    this.shuffle(this.size - numberOfTiles);
    return drawnTiles;
  }
  checkEnoughTiles(numberOfTilesNeeded) {
    if (numberOfTilesNeeded > this.size) {
      throw new RangeError(`Not enough tiles in bag: ${this.size} < ${numberOfTilesNeeded}`);
    }
  }
  shuffle(indexOfFirstNewTile) {
    for (let i = Math.max(1, indexOfFirstNewTile);i <= this.size; ++i) {
      const j = Math.floor(this.randomGenerator.random() * i);
      [this.tiles[i - 1], this.tiles[j]] = [this.tiles[j], this.tiles[i - 1]];
    }
  }
  toJSON() {
    return {
      tiles: this.tiles.map(toJSON),
      prng: this.randomGenerator.toJSON()
    };
  }
}

// game/mulberry32_prng.ts
class Mulberry32Prng {
  seed;
  constructor(seed) {
    this.seed = Number(BigInt(seed) & 0xFFFFFFFFn);
  }
  random() {
    this.seed = this.seed + 1831565813 >>> 0;
    let t = this.seed;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  toJSON() {
    return this.seed;
  }
  static fromJSON(json) {
    if (typeof json !== "number") {
      throw new TypeError(`Invalid serialized Mulberry32Prng: ${JSON.stringify(json)}`);
    }
    return new Mulberry32Prng(json);
  }
}

// game/honor_system_bag.ts
class HonorSystemBag extends Bag {
  constructor(randomSeed, tiles, shuffle = true, randomGenerator = new Mulberry32Prng(BigInt(randomSeed))) {
    super(tiles, randomGenerator, shuffle);
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in HonorSystemBag serialization: ${JSON.stringify(json)}`);
    }
    if (typeof json !== "object")
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], ["tiles", "prng"]))
      fail("Wrong keys or key order");
    if (!Array.isArray(json.tiles))
      fail("Tiles are not an array.");
    return new HonorSystemBag("", json.tiles.map(Tile.fromJSON), false, Mulberry32Prng.fromJSON(json.prng));
  }
}

// game/events.ts
class BagEvent extends CustomEvent {
}

class TileEvent extends CustomEvent {
}

class GameEvent extends CustomEvent {
}

class BoardEvent extends CustomEvent {
}

// game/honor_system_tiles_state.ts
class HonorSystemTilesState extends EventTarget {
  rackCapacity;
  numberOfTurnsPlayed;
  racks;
  bag;
  isGameOver;
  constructor(players, tileSystemSettings, tiles, rackCapacity, numberOfTurnsPlayed = 0, racks = new Map(players.map((player) => [player.id, []])), bag = new HonorSystemBag(tileSystemSettings.seed, tiles), isGameOver = false, init = true) {
    super();
    this.rackCapacity = rackCapacity;
    this.numberOfTurnsPlayed = numberOfTurnsPlayed;
    this.racks = racks;
    this.bag = bag;
    this.isGameOver = isGameOver;
    if (this.racks.size < players.length) {
      throw new Error(`The player IDs are not unique: ${players.map((player) => player.id)}`);
    }
    if (init)
      this.initRacks();
  }
  copyFrom(other) {
    if (!(other instanceof HonorSystemTilesState))
      throw new TypeError;
    this.numberOfTurnsPlayed = other.numberOfTurnsPlayed;
    this.racks = other.racks;
    this.bag = other.bag;
    this.isGameOver = other.isGameOver;
  }
  get numberOfTilesInBag() {
    return this.bag.size;
  }
  get stateId() {
    return this.numberOfTurnsPlayed;
  }
  countTiles(playerId) {
    return this.getRack(playerId).length;
  }
  getTiles(playerId) {
    return Promise.resolve([...this.getRack(playerId)]);
  }
  playTurns(...turnsToPlay) {
    for (const turn of turnsToPlay) {
      this.playOneTurn(turn);
      if (this.isGameOver)
        return Promise.resolve(toTurnNumber(this.numberOfTurnsPlayed));
    }
    return Promise.resolve(null);
  }
  playOneTurn(turn) {
    const rack = this.getRack(turn.playerId);
    const rackCopy = [...rack];
    if ("playTiles" in turn.move) {
      for (const tileToPlay of turn.move.playTiles) {
        const index = rackCopy.findIndex((rackTile) => rackTile.equals(tileToPlay.tile));
        if (index === -1) {
          throw new Error(`Player ${turn.playerId} does not hold tile ${tileToPlay.tile.toString()}`);
        }
        rackCopy.splice(index, 1);
      }
      const numberOfTilesToDraw = Math.min(rack.length - rackCopy.length, this.bag.size);
      const drawnTiles = this.bag.draw(numberOfTilesToDraw);
      for (const tile of drawnTiles) {
        this.dispatchEvent(new BagEvent("tiledraw", { detail: { playerId: turn.playerId, tile } }));
      }
      rackCopy.push(...drawnTiles);
      if (rackCopy.length === 0)
        this.isGameOver = true;
    } else if ("exchangeTileIndices" in turn.move) {
      const indicesOfTilesToExchange = checkIndicesForExchange(rackCopy.length, ...turn.move.exchangeTileIndices);
      indicesOfTilesToExchange.sort((a, b) => b - a);
      const tilesToExchange = [];
      for (const indexOfTileToExchange of indicesOfTilesToExchange) {
        tilesToExchange.push(...rackCopy.splice(indexOfTileToExchange, 1));
      }
      const newTiles = this.bag.exchange(tilesToExchange);
      for (const tile of tilesToExchange) {
        this.dispatchEvent(new BagEvent("tilereturn", { detail: { playerId: turn.playerId, tile } }));
      }
      for (const tile of newTiles) {
        this.dispatchEvent(new BagEvent("tiledraw", { detail: { playerId: turn.playerId, tile } }));
      }
      rackCopy.push(...newTiles);
    }
    rack.splice(0, rack.length, ...rackCopy);
    this.numberOfTurnsPlayed += 1;
  }
  getRack(playerId) {
    const rack = this.racks.get(playerId);
    if (rack === undefined) {
      throw new Error(`Unknown playerId: ${playerId}`);
    }
    return rack;
  }
  initRacks() {
    for (const [playerId, rack] of this.racks.entries()) {
      const drawnTiles = this.bag.draw(this.rackCapacity);
      for (const tile of drawnTiles) {
        this.dispatchEvent(new BagEvent("tiledraw", { detail: { playerId, tile } }));
      }
      rack.push(...drawnTiles);
    }
  }
  toJSON() {
    const racks = [...this.racks.entries().map(([playerId, rack]) => [playerId, rack.map((tile) => tile.toJSON())])];
    return {
      rackCapacity: this.rackCapacity,
      numberOfTurnsPlayed: this.numberOfTurnsPlayed,
      bag: this.bag.toJSON(),
      racks
    };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in HonorSystemTileState serialization: ${JSON.stringify(json)}`);
    }
    if (!(typeof json === "object"))
      fail("Not an object");
    if (typeof json.rackCapacity !== "number")
      fail("rackCapacity is not a number");
    if (typeof json.numberOfTurnsPlayed !== "number")
      fail("numberOfTurnsPlayed is not a number");
    if (!Array.isArray(json.racks))
      fail("Racks are not in an array.");
    const bag = HonorSystemBag.fromJSON(json.bag);
    const racks = new Map;
    let isGameOver = false;
    for (const racksEntry of json.racks) {
      if (!Array.isArray(racksEntry))
        fail("Rack list entry is not an array");
      if (racksEntry.length !== 2)
        fail("Rack list entry length is not 2");
      const [playerId, rackJson] = racksEntry;
      if (typeof playerId !== "string")
        fail("Rack list playerId is not a string");
      if (!Array.isArray(rackJson))
        fail("Rack is not an array");
      if (rackJson.length > json.rackCapacity)
        fail("Rack length is over capacity");
      if (rackJson.length === 0)
        isGameOver = true;
      racks.set(playerId, rackJson.map(Tile.fromJSON));
    }
    return new HonorSystemTilesState([], { seed: "" }, [], json.rackCapacity, json.numberOfTurnsPlayed, racks, bag, isGameOver, false);
  }
}

// i18n.ts
var {readFileSync} = (() => ({}));
// i18n/en.json
var en_default = {
  error: {
    word_placement: {
      no_tiles: "Drag some tiles onto the board, and try again.",
      blank_tiles_must_be_assigned_letters: "Blank tiles must be assigned letters.",
      non_blank_tiles_cannot_be_assigned_letters: "Non-blank tiles cannot be assigned letters.",
      tiles_not_in_line: "Tiles are not in a line.",
      square_occupied: "Square ${row},${col} is occupied.",
      line_with_gaps: "Tiles form a line with gaps between them.",
      no_single_letter_words: "No single-letter words accepted.",
      must_connect_to_existing: "Tiles must connect to existing words or cover the center square."
    },
    play_rejected: {
      not_words_in_dictionary: "Not words in ${dictionaryName}: ${invalidWords}.",
      play_rejected: "${message} Play rejected.",
      word_not_in_dictionary: 'Word "${word}" ${status} in ${dictionaryName}.',
      status: {
        not_found: "not found",
        has_no_definition: "has no definition"
      }
    },
    url: {
      protocol_not_supported: "Protocol version not supported: ${version}",
      no_random_seed: "No random seed in URL.",
      unknown_dictionary_type: 'Unknown dictionary type: "${type}".',
      custom_dictionary_requires_url: "Custom dictionary requires a URL.",
      invalid_tile_distribution: "Invalid tile distribution specifier: ${specifier}",
      invalid_letter_config: "Invalid letter configuration in URL: ${config}",
      tn_not_a_number: '"tn" param is not a turn number: "${param}"',
      both_word_and_exchange: "Found both word and exchange data for turn ${turnNumber}.",
      invalid_bt_component: 'Invalid "bt" parameter component: "${component}"',
      duplicate_bt_index: "Duplicate blank tile assignment index: bt=${param}",
      bt_index_out_of_range: 'Blank tile assignment index out of range: no "${word}"[${index}].',
      invalid_wl_param: 'Invalid "wl" parameter: "${param}"',
      word_out_of_bounds: "Attempted to play a word out of bounds: ${row},${col}.",
      wrong_letter: 'Word requires "${requiredLetter}" at ${row},${col}, but "${actualLetter}" is there.',
      invalid_letter: 'Attempt to play an invalid letter: "${letter}"',
      bt_index_range: '"bt" parameter has index ${index} out of range 0-${maxIndex}.',
      incomplete_turn_data: "Incomplete data for turn ${turnNumber}: wl=${wl} ${direction}=${word} bt=${bt}",
      invalid_exchange_index: 'Invalid exchange tile index: "${index}"',
      invalid_player_id: 'Invalid turn URL: Player ID "${id}" should be in 1-${maxId}.',
      duplicate_bt_param: 'Duplicate "bt" parameter for turn ${turnNumber}.',
      duplicate_word_params: "Duplicate word parameters for turn ${turnNumber}.",
      unrecognized_param: 'Unrecognized parameter name: "${param}"'
    }
  },
  ui: {
    title: "Crossword Builder",
    buttons: {
      play_word: "Play Word",
      pass_turn: "Pass Turn",
      exchange_count: "Exchange ${count}",
      recall_tiles: "Recall Tiles",
      game_setup: "Game Setup",
      add_player: "Add Player",
      remove_player: "-",
      start_game_with_settings: "Start Game with Settings",
      cancel_settings: "Cancel",
      ok: "OK"
    },
    settings: {
      players: "Players",
      dictionary: "Dictionary",
      dictionary_options: {
        permissive: "Anything is a word",
        freeapi: "freeapi",
        custom: "custom"
      },
      dictionary_url_label: "URL:",
      bingo_bonus: "Bingo Bonus",
      random_seed: "Random Seed",
      player_placeholder: "Player ${index}"
    },
    bag_tile_count: "Tiles in bag: ${count}",
    dialog: {
      copy_turn_url: "Copy Turn URL?",
      confirm_title: "Confirm"
    },
    game: {
      join_link: "join"
    }
  }
};

// i18n.ts
var [DEFAULT_LANG, DEFAULT_TRANSLATIONS] = ["en", en_default];
var translations = {};
async function loadTranslations(...languages) {
  for (const lang of languages) {
    if (lang === DEFAULT_LANG) {
      translations = DEFAULT_TRANSLATIONS;
      return;
    }
    try {
      if (typeof window !== "undefined" && typeof window.fetch === "function") {
        const response = await fetch(`i18n/${lang}.json`);
        if (!response.ok) {
          console.warn(`Language '${lang}' not supported.`);
        } else {
          translations = await response.json();
          return;
        }
      } else {
        const path = `i18n/${lang}.json`;
        try {
          const data = readFileSync(path, "utf-8");
          translations = JSON.parse(data);
          return;
        } catch (error) {
          console.warn(`Language '${lang}' not supported.`);
        }
      }
    } catch (error) {
      console.error(error);
    }
  }
  console.warn(`Configured languages not supported. Falling back to ${DEFAULT_LANG}.`);
  translations = DEFAULT_TRANSLATIONS;
}
function t(key, params) {
  const keys = key.split(".");
  let value = translations;
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      return key;
    }
  }
  if (typeof value === "string") {
    if (params) {
      return value.replace(/\$\{(\w+)\}/g, (_, placeholder) => {
        return params[placeholder] !== undefined ? String(params[placeholder]) : `{${placeholder}}`;
      });
    }
    return value;
  }
  return key;
}

// game/game_params.ts
class UrlError extends Error {
  constructor(message) {
    super(message);
    this.name = "UrlError";
  }
}
function getBagParam(settings) {
  const letterToUrl = (l) => l === "" ? "_" : l;
  let bagParam = [...settings.letterCounts.entries()].map(([letter, count]) => `${letterToUrl(letter)}-${count}-${settings.letterValues.get(letter) ?? 0}`).join(".");
  for (const { code: bagLanguage } of getBagLanguages()) {
    const defaults = getBagDefaults(bagLanguage);
    const settingsLetters = new Set(settings.letterCounts.keys());
    const defaultLetters = new Set(defaults.letterCounts.keys());
    const diffParts = [];
    for (const letter of settingsLetters) {
      if (!defaultLetters.has(letter)) {
        const count = settings.letterCounts.get(letter);
        const value = settings.letterValues.get(letter) ?? 0;
        diffParts.push(`${letterToUrl(letter)}-${count}-${value}`);
      }
    }
    for (const letter of defaultLetters) {
      const settingsHasLetter = settingsLetters.has(letter);
      const count = settings.letterCounts.get(letter);
      const value = settings.letterValues.get(letter);
      const defaultCount = defaults.letterCounts.get(letter);
      const defaultValue = defaults.letterValues.get(letter);
      if (settingsHasLetter && count === defaultCount && value === defaultValue) {
        continue;
      }
      if (!settingsHasLetter) {
        diffParts.push(`${letterToUrl(letter)}-0`);
        continue;
      }
      let part = letterToUrl(letter);
      const countIsDefault = count === defaultCount;
      const valueIsDefault = value === defaultValue;
      if (!countIsDefault && !valueIsDefault) {
        part += `-${count}-${value}`;
      } else if (!countIsDefault) {
        part += `-${count}`;
      } else if (count !== 0) {
        part += `--${value}`;
      }
      diffParts.push(part);
    }
    diffParts.sort();
    const abbreviatedBagParam = [...diffParts, `.${bagLanguage}`].join(".");
    if (abbreviatedBagParam.length < bagParam.length) {
      bagParam = abbreviatedBagParam;
    }
  }
  return bagParam;
}
function gameParamsFromSettings(settings) {
  const params = new URLSearchParams;
  const defaults = Settings.forLanguage("en");
  params.set("v", settings.version);
  if (!playersEqual(settings.players, defaults.players)) {
    settings.players.forEach((p, index) => {
      params.set(`p${index + 1}n`, p.name);
    });
  }
  if (!arraysEqual(settings.boardLayout, defaults.boardLayout, false)) {
    params.set("board", settings.boardLayout.join("-"));
  }
  if (settings.bingoBonus !== defaults.bingoBonus) {
    params.set("bingo", String(settings.bingoBonus));
  }
  const bagParam = getBagParam(settings);
  if (bagParam) {
    params.set("bag", bagParam);
  }
  if (settings.rackCapacity !== defaults.rackCapacity) {
    params.set("racksize", String(settings.rackCapacity));
  }
  if (settings.tileSystemType === "honor") {
    params.set("seed", settings.tileSystemSettings.seed);
  }
  if (settings.dictionaryType !== defaults.dictionaryType) {
    params.set("dt", settings.dictionaryType);
  }
  if (typeof settings.dictionarySettings === "string") {
    params.set("ds", settings.dictionarySettings);
  }
  return params;
}
function parseGameParams(allParams) {
  const gameParams = new URLSearchParams;
  const turnParams = new URLSearchParams;
  for (const [name, value] of allParams) {
    if (turnParams.size || name === "tn") {
      turnParams.append(name, value);
    } else {
      gameParams.append(name, value);
    }
  }
  const settings = Settings.forLanguage("en");
  const vParam = gameParams.get("v");
  if (vParam && vParam !== settings.version) {
    throw new UrlError(t("error.url.protocol_not_supported", { version: vParam }));
  }
  const gidParam = gameParams.get("gid");
  if (gidParam)
    settings.gameId = toGameId(gidParam);
  const newPlayers = [];
  for (let playerNumber = 1;; ++playerNumber) {
    const pnParam = gameParams.get(`p${playerNumber}n`);
    if (!pnParam)
      break;
    newPlayers.push(new Player({ id: String(playerNumber), name: pnParam.slice(0, settings.maxPlayerNameLength) }));
  }
  if (newPlayers.length)
    settings.players = newPlayers;
  const bagParam = gameParams.get("bag");
  if (bagParam)
    parseBagParam(settings, bagParam);
  const boardParam = gameParams.get("board");
  if (boardParam)
    settings.boardLayout = boardParam.split("-");
  const bingoParam = gameParams.get("bingo");
  if (bingoParam)
    settings.bingoBonus = parseInt(bingoParam, 10);
  const racksizeParam = gameParams.get("racksize");
  if (racksizeParam)
    settings.rackCapacity = parseInt(racksizeParam, 10);
  const seedParam = gameParams.get("seed");
  if (!seedParam)
    throw new UrlError(t("error.url.no_random_seed"));
  settings.tileSystemSettings = { seed: seedParam };
  const dtParam = gameParams.get("dt");
  if (dtParam === "permissive" || dtParam === "freeapi" || dtParam === "custom") {
    settings.dictionaryType = dtParam;
  } else if (dtParam) {
    throw new UrlError(t("error.url.unknown_dictionary_type", { type: dtParam }));
  }
  const dsParam = gameParams.get("ds");
  if (dsParam)
    settings.dictionarySettings = dsParam;
  else if (settings.dictionaryType === "custom") {
    throw new UrlError(t("error.url.custom_dictionary_requires_url"));
  }
  let playerId = gameParams.get("pid") ?? undefined;
  if (!playerId) {
    const urlTurnNumber = parseInt(turnParams.get("tn"), 10) || 1;
    const turnNumber = toTurnNumber(urlTurnNumber + turnParams.getAll("wl").length + turnParams.getAll("ex").length);
    playerId = getPlayerForTurnNumber(settings.players, turnNumber).id;
    console.log(`Joining as Player ${playerId}.`);
  }
  return { settings, playerId, turnParams };
}
function playersEqual(ps1, ps2) {
  if (ps1.length !== ps2.length)
    return false;
  for (const index in ps1) {
    if (!ps1[index].equals(ps2[index]))
      return false;
  }
  return true;
}
function parseBagParam(settings, bagParam) {
  const urlToLetter = (s) => s === "_" ? "" : s;
  const letterCounts = new Map;
  const letterValues = new Map;
  const iterator = bagParam.split(".")[Symbol.iterator]();
  for (const letterConfig of iterator) {
    if (letterConfig === "") {
      const rest = [...iterator].join(".");
      const bagDefaults = getBagDefaults(rest);
      if (!bagDefaults) {
        throw new UrlError(t("error.url.invalid_tile_distribution", { specifier: rest }));
      }
      for (const [letter2, count2] of bagDefaults.letterCounts) {
        if (!letterCounts.has(letter2)) {
          letterCounts.set(letter2, count2);
          letterValues.set(letter2, bagDefaults.letterValues.get(letter2));
        }
      }
      break;
    }
    const match = letterConfig.match(/^(?<letter>\D+?)(?:-(?<count>(?:\d+$|\d*))(?:-(?<value>\d+))?)?$/u);
    if (!match) {
      throw new UrlError(t("error.url.invalid_letter_config", { config: letterConfig }));
    }
    const g = match.groups;
    const letter = urlToLetter(g.letter);
    const count = g.count ? parseInt(g.count, 10) : settings.letterCounts.get(letter) ?? 1;
    const value = g.value ? parseInt(g.value, 10) : settings.letterValues.get(letter) ?? 1;
    letterCounts.set(letter, count);
    letterValues.set(letter, value);
  }
  settings.letterCounts = letterCounts;
  settings.letterValues = letterValues;
}

// game/board.ts
class Square {
  row;
  col;
  letterBonus;
  wordBonus;
  tile;
  assignedLetter;
  constructor({ row, col, letterBonus, wordBonus }) {
    this.row = row;
    this.col = col;
    this.letterBonus = letterBonus;
    this.wordBonus = wordBonus;
  }
  get letter() {
    return this.assignedLetter || this.tile?.letter;
  }
  get value() {
    return this.tile?.value;
  }
}
var CHAR_TO_BONUS = new Map([
  [".", [1, 1]],
  ["d", [2, 1]],
  ["t", [3, 1]],
  ["D", [1, 2]],
  ["T", [1, 3]]
]);

class InvalidBonusSquareLayout extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidBonusSquareLayout";
  }
}
function parseRowStrings(rowStrings) {
  const firstRowString = rowStrings[0];
  if (!firstRowString || !rowStrings.every((s) => s.length === firstRowString.length)) {
    throw new InvalidBonusSquareLayout(`Row strings do not form a rectangle: ${rowStrings.join(`
`)}.`);
  }
  return rowStrings.map((rowString, row) => rowString.split("").map((character, col) => {
    const bonus = CHAR_TO_BONUS.get(character);
    if (!bonus)
      throw new InvalidBonusSquareLayout(`Unrecognized square type: ${character}`);
    const [letterBonus, wordBonus] = bonus;
    return new Square({ row, col, letterBonus, wordBonus });
  }));
}
function generateRowStrings(squares) {
  return squares.map((row) => row.map((square) => {
    const pair = [square.letterBonus, square.wordBonus];
    const entry = CHAR_TO_BONUS.entries().find(([char, bonus]) => bonus[0] === pair[0] && bonus[1] === pair[1]);
    if (entry === undefined)
      throw new Error(`Unrecognized bonus multiplier pair: ${pair}`);
    return entry[0];
  }).join(""));
}

class WordPlacementError extends Error {
  constructor(message) {
    super(message);
    this.name = "WordPlacementError";
  }
}

class Board extends EventTarget {
  squares;
  scores = new Map;
  centerSquare;
  constructor(...rowStrings) {
    super();
    this.squares = parseRowStrings(rowStrings);
    const centerRow = this.squares[this.squares.length >> 1];
    const centerSquare = centerRow?.[centerRow.length >> 1];
    if (!centerSquare)
      throw new Error(`Board lacks a center square: ${rowStrings}`);
    this.centerSquare = centerSquare;
  }
  copyFrom(other) {
    this.squares.forEach((rowSquares, row) => {
      rowSquares.forEach((square, col) => {
        const otherSquare = other.squares[row][col];
        square.tile = otherSquare.tile;
        square.assignedLetter = otherSquare.assignedLetter;
      });
    });
    this.scores = other.scores;
  }
  checkWordPlacement(...placements) {
    const anyPlacement = placements[0];
    if (!anyPlacement)
      throw new WordPlacementError(t("error.word_placement.no_tiles"));
    for (const placement of placements) {
      if (placement.tile.isBlank && !placement.assignedLetter) {
        throw new WordPlacementError(t("error.word_placement.blank_tiles_must_be_assigned_letters"));
      }
      if (!placement.tile.isBlank && placement.assignedLetter) {
        throw new WordPlacementError(t("error.word_placement.non_blank_tiles_cannot_be_assigned_letters"));
      }
    }
    const mainDir = { x: 0, y: 0 };
    const tilesInOneRow = placements.every((tile) => tile.row === anyPlacement.row);
    if (tilesInOneRow && (placements.length > 1 || this.squares[anyPlacement.row]?.[anyPlacement.col - 1]?.tile || this.squares[anyPlacement.row]?.[anyPlacement.col + 1]?.tile)) {
      mainDir.x = 1;
      placements.sort((a, b) => a.col - b.col);
    } else if (placements.every((tile) => tile.col === anyPlacement.col)) {
      mainDir.y = 1;
      placements.sort((a, b) => a.row - b.row);
    } else {
      throw new WordPlacementError(t("error.word_placement.tiles_not_in_line"));
    }
    const crossDir = { x: mainDir.y, y: mainDir.x };
    const firstPlacement = placements[0];
    if (!firstPlacement)
      throw new Error("Lost a tile.");
    let { row: mainRow, col: mainCol } = firstPlacement;
    while (this.squares[mainRow - mainDir.y]?.[mainCol - mainDir.x]?.tile) {
      mainRow -= mainDir.y;
      mainCol -= mainDir.x;
    }
    const mainStartRow = mainRow;
    const mainStartCol = mainCol;
    const mainWordTileContent = [];
    const crossWords = [];
    const blanks = [];
    let placementIndex = 0;
    let mainWordMultiplier = 1, mainWordScore = 0, crossWordsScore = 0;
    while (true) {
      const mainSquare = this.squares[mainRow]?.[mainCol];
      if (!mainSquare)
        break;
      let mainLetter, mainValue, wordMultiplier;
      const placement = placements[placementIndex];
      if (placement && placement.row === mainRow && placement.col === mainCol) {
        if (mainSquare.tile) {
          throw new WordPlacementError(t("error.word_placement.square_occupied", { row: mainRow, col: mainCol }));
        }
        placementIndex += 1;
        if (placement.assignedLetter) {
          blanks.push(mainWordTileContent.length);
          mainLetter = placement.assignedLetter;
        } else {
          mainLetter = placement.tile.letter;
        }
        mainValue = mainSquare.letterBonus * placement.tile.value;
        wordMultiplier = mainSquare.wordBonus;
        mainWordMultiplier *= wordMultiplier;
        let crossRow = mainRow, crossCol = mainCol;
        while (this.squares[crossRow - crossDir.y]?.[crossCol - crossDir.x]?.tile) {
          crossRow -= crossDir.y;
          crossCol -= crossDir.x;
        }
        const crossWordTileContent = [];
        let crossWordScore = 0;
        while (true) {
          const crossSquare = this.squares[crossRow]?.[crossCol];
          if (crossRow === mainRow && crossCol === mainCol) {
            crossWordTileContent.push(mainLetter);
            crossWordScore += mainValue;
          } else if (crossSquare?.tile) {
            crossWordTileContent.push(crossSquare.letter);
            crossWordScore += crossSquare.tile.value;
          } else {
            break;
          }
          crossRow += crossDir.y;
          crossCol += crossDir.x;
        }
        if (crossWordTileContent.length > 1) {
          crossWords.push(crossWordTileContent.join(""));
          crossWordsScore += crossWordScore * wordMultiplier;
        }
      } else if (mainSquare.tile) {
        mainLetter = mainSquare.assignedLetter || mainSquare.tile.letter;
        mainValue = mainSquare.tile.value;
        wordMultiplier = 1;
      } else {
        break;
      }
      mainWordTileContent.push(mainLetter);
      mainWordScore += mainValue;
      mainRow += mainDir.y;
      mainCol += mainDir.x;
    }
    mainWordScore *= mainWordMultiplier;
    if (placementIndex < placements.length) {
      throw new WordPlacementError(t("error.word_placement.line_with_gaps"));
    }
    if (mainWordTileContent.length === 1) {
      throw new WordPlacementError(t("error.word_placement.no_single_letter_words"));
    }
    if (!crossWords.length && mainWordTileContent.length === placements.length) {
      if (!placements.some((tile) => tile.row === this.centerSquare.row && tile.col === this.centerSquare.col)) {
        throw new WordPlacementError(t("error.word_placement.must_connect_to_existing"));
      }
    }
    const mainWordForValidation = mainWordTileContent.join("");
    const mainWordForUrl = mainWordTileContent.every((tc) => [...tc].length === 1) ? mainWordForValidation : mainWordTileContent.join(".");
    return {
      wordsFormed: [mainWordForValidation, ...crossWords],
      score: mainWordScore + crossWordsScore,
      mainWordForUrl,
      row: mainStartRow,
      col: mainStartCol,
      vertical: Boolean(mainDir.y),
      blanks
    };
  }
  placeTiles(...placements) {
    for (const placement of placements) {
      const square = this.squares[placement.row]?.[placement.col];
      if (!square)
        throw new Error(`Invalid board coordinates: ${placement.row},${placement.col}.`);
      if (square.tile)
        throw new Error(`Square ${placement.row}, ${placement.col} is occupied.`);
    }
    for (const placement of placements) {
      const square = this.squares[placement.row]?.[placement.col];
      if (square) {
        square.tile = placement.tile;
        square.assignedLetter = placement.assignedLetter;
        this.dispatchEvent(new BoardEvent("tileplaced", { detail: { placement } }));
      }
    }
  }
  toJSON() {
    const rows = generateRowStrings(this.squares);
    const tiles = [];
    this.squares.forEach((row) => row.forEach((square) => {
      if (square.tile) {
        const result = [square.row, square.col, square.tile.toJSON()];
        if (square.assignedLetter)
          result.push(square.assignedLetter);
        tiles.push(result);
      }
    }));
    const scores = [...this.scores.entries()];
    return { rows, tiles, scores };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in Board serialization: ${JSON.stringify(json)}`);
    }
    if (!(typeof json === "object"))
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], ["rows", "tiles", "scores"]))
      fail("Wrong keys or key order");
    if (!Array.isArray(json.rows))
      fail("Rows are not an array");
    if (!json.rows.every((row) => typeof row === "string"))
      fail("Row element is not a string");
    if (!Array.isArray(json.tiles))
      fail("Tiles are not an array");
    if (!Array.isArray(json.scores))
      fail("Scores are not an array");
    try {
      const board = new Board(...json.rows);
      for (const tile of json.tiles) {
        if (!Array.isArray(tile))
          fail("Tile is not an array");
        if (tile.length > 4)
          fail("Wrong size array for tile");
        const [row, col, tileJson, assignedLetter] = tile;
        if (!(typeof row === "number"))
          fail("Tile row is not a number");
        if (!(typeof col === "number"))
          fail("Tile col is not a number");
        const square = board.squares[row]?.[col];
        if (!square)
          fail("Tile coordinates are off the board");
        square.tile = Tile.fromJSON(tileJson);
        if (assignedLetter)
          square.assignedLetter = assignedLetter;
      }
      for (const element of json.scores) {
        if (!Array.isArray(element))
          fail("Score is not an array");
        if (element.length !== 2)
          fail("Wrong size array for score");
        const [playerId, score] = element;
        if (!(typeof playerId === "string"))
          fail("Player ID is not a string");
        if (!(typeof score === "number"))
          fail("Score is not a number");
        if (board.scores.has(playerId))
          fail("Duplicate Player ID in scores array");
        board.scores.set(playerId, score);
      }
      return board;
    } catch (e) {
      if (e instanceof InvalidBonusSquareLayout)
        fail("Invalid board layout");
      throw e;
    }
  }
}

// game/dictionary.ts
var DICTIONARY_TYPES = ["permissive", "freeapi", "custom"];

class PlayRejectedError extends Error {
  constructor(message) {
    super(t("error.play_rejected.play_rejected", { message }));
    this.name = "PlayRejected";
  }
}
function makeDictionary(dictionaryType, dictionarySettings) {
  if (!DICTIONARY_TYPES.includes(dictionaryType)) {
    throw new Error(`dictionaryType ${dictionaryType} is not supported.`);
  }
  return async (...words) => {
    const promises = words.map((word) => {
      return checkWord(word, dictionaryType, dictionarySettings);
    });
    const results = await Promise.all(promises);
    const errors = results.filter((r) => r);
    if (errors.length === 0)
      return;
    if (errors.length === 1)
      throw errors[0];
    const invalidWords = errors.map((wnidError) => wnidError.word);
    throw new PlayRejectedError(t("error.play_rejected.not_words_in_dictionary", { dictionaryName: errors[0].dictionaryName, invalidWords: invalidWords.join(", ") }));
  };
}

class WordNotInDictionaryError extends PlayRejectedError {
  word;
  dictionaryName;
  status;
  constructor(word, dictionaryName, status) {
    super(t("error.play_rejected.word_not_in_dictionary", { word, status, dictionaryName }));
    this.word = word;
    this.dictionaryName = dictionaryName;
    this.status = status;
    this.name = "WordNotInDictionaryError";
  }
}

class WordNotFoundError extends WordNotInDictionaryError {
  constructor(word, dictionaryName) {
    super(word, dictionaryName, t("error.play_rejected.status.not_found"));
    this.name = "WordNotFoundError";
  }
}

class NoDefinitionError extends WordNotInDictionaryError {
  constructor(word, dictionaryName) {
    super(word, dictionaryName, t("error.play_rejected.status.has_no_definition"));
    this.name = "NoDefinitionError";
  }
}
async function checkWord(wordToCheck, dictionaryType, dictionarySettings) {
  if (dictionaryType === "permissive")
    return null;
  let urlPrefix = "";
  let dictionaryNameForAlert = "";
  if (dictionaryType === "freeapi") {
    urlPrefix = "https://api.dictionaryapi.dev/api/v2/entries/en/";
    dictionaryNameForAlert = "Free Dictionary API";
  } else if (dictionaryType === "custom") {
    dictionaryNameForAlert = "Custom Dictionary";
  }
  if (typeof dictionarySettings === "string") {
    urlPrefix = dictionarySettings;
  }
  if (!urlPrefix) {
    throw new Error("Custom dictionary requires setting a URL prefix.");
  }
  const url = urlPrefix + wordToCheck.toLowerCase();
  try {
    const response = await fetch(url);
    if (!response.ok) {
      if (response.status === 404) {
        return new WordNotFoundError(wordToCheck, dictionaryNameForAlert);
      } else {
        throw new Error(`Error validating word "${wordToCheck}" with ${dictionaryNameForAlert} (Status: ${response.status} ${response.statusText}).`);
      }
    }
    if (dictionaryType === "freeapi") {
      const data = await response.json();
      if (!Array.isArray(data) || data.length === 0 || data[0] && data[0].title === "No Definitions Found") {
        return new NoDefinitionError(wordToCheck, dictionaryNameForAlert);
      }
    }
    console.log(`Word "${wordToCheck}" is valid according to ${dictionaryNameForAlert}.`);
    return null;
  } catch (error) {
    console.error(`Network or other error validating word "${wordToCheck}":`, error);
    throw new Error(`Could not reach ${dictionaryNameForAlert} to validate "${wordToCheck}". Check connection or API status.`);
  }
}

// game/shared_state.ts
class SharedState {
  settings;
  gameId;
  board;
  tilesState;
  nextTurnNumber;
  checkWords;
  gameParams;
  constructor(settings, gameId = settings.gameId ?? makeGameId(), board = new Board(...settings.boardLayout), tilesState = makeTilesState(settings), nextTurnNumber2 = toTurnNumber(1), checkWords = makeDictionary(settings.dictionaryType, settings.dictionarySettings), gameParams = gameParamsFromSettings(settings)) {
    this.settings = settings;
    this.gameId = gameId;
    this.board = board;
    this.tilesState = tilesState;
    this.nextTurnNumber = nextTurnNumber2;
    this.checkWords = checkWords;
    this.gameParams = gameParams;
    this.settings.players.forEach((player, index) => {
      const expected = String(index + 1);
      if (player.id !== expected) {
        throw new Error(`players[${index}] should have ID "${expected}", not "${player.id}".`);
      }
    });
  }
  copyFrom(other) {
    this.board.copyFrom(other.board);
    this.tilesState.copyFrom(other.tilesState);
    this.nextTurnNumber = other.nextTurnNumber;
    this.players.forEach((player, index) => {
      player.name = other.players[index].name;
    });
  }
  get players() {
    return this.settings.players;
  }
  get isGameOver() {
    return this.tilesState.isGameOver;
  }
  getPlayerForTurnNumber(turnNumber) {
    return getPlayerForTurnNumber(this.players, turnNumber);
  }
  getTurnUrlParams(turnHistory) {
    const entries = [["gid", fromGameId(this.gameId)]];
    const firstHistoryTurnNumber = turnHistory[0]?.turnNumber;
    if (firstHistoryTurnNumber === undefined || firstHistoryTurnNumber === toTurnNumber(1)) {
      entries.push(...this.gameParams);
    }
    if (turnHistory.length) {
      entries.push(["tn", String(firstHistoryTurnNumber)]);
      turnHistory.forEach((turnData) => {
        entries.push(...new URLSearchParams(turnData.paramsStr));
      });
    } else {
      entries.push(["tn", "1"]);
    }
    return new URLSearchParams(entries);
  }
  async playTurns(...turns) {
    const seen = [];
    for (const turn of turns) {
      if (turn.turnNumber < this.nextTurnNumber) {
        console.log(`Ignoring old turn number ${turn.turnNumber}`);
      } else if (turn.turnNumber in seen) {
        throw new Error(`playTurns received duplicate turn number ${turn.turnNumber}.`);
      } else {
        seen[turn.turnNumber] = turn;
      }
    }
    const turnsToPlayNow = [];
    const boardChanges = [];
    const wordsToCheck = new Set;
    let turnNumber = this.nextTurnNumber;
    for (const turn of seen.filter((t2) => t2)) {
      if (turn.turnNumber !== turnNumber) {
        console.warn(`Ignoring out-of-order turn number ${turn.turnNumber}; expected ${turnNumber}.`);
        break;
      }
      const playerId = this.getPlayerForTurnNumber(turnNumber).id;
      if (turn.playerId !== playerId) {
        throw new Error(`Turn number ${turn.turnNumber} belongs to player "${playerId}", not "${turn.playerId}".`);
      }
      if ("playTiles" in turn.move) {
        const { wordsFormed, score, mainWordForUrl, row, col, vertical, blanks } = this.board.checkWordPlacement(...turn.move.playTiles);
        wordsFormed.forEach((w) => wordsToCheck.add(w));
        const bingoBonus = turn.move.playTiles.length === this.tilesState.rackCapacity ? this.settings.bingoBonus : 0;
        boardChanges.push({ playerId, score: score + bingoBonus, placements: turn.move.playTiles });
        turn.mainWord = mainWordForUrl;
        turn.row = row;
        turn.col = col;
        turn.vertical = vertical;
        turn.blanks = blanks;
        console.log(`Player ${playerId} plays ${wordsFormed[0]} for ${score}`);
      } else if ("exchangeTileIndices" in turn.move) {
        checkIndicesForExchange(this.tilesState.countTiles(playerId), ...turn.move.exchangeTileIndices);
        const numAttempted = turn.move.exchangeTileIndices.length;
        const numInBag = this.tilesState.numberOfTilesInBag;
        if (numAttempted > numInBag) {
          throw new Error(`Player ${playerId} attempted to exchange ${numAttempted} but the bag holds only ${numInBag}.`);
        }
        if (numAttempted) {
          console.log(`Player ${playerId} exchanges ${numAttempted} tiles.`);
        } else {
          console.log(`Player ${playerId} passes.`);
        }
      } else {
        throw new Error(`Turn number ${turn.turnNumber} is not a play or exchange.`);
      }
      turnsToPlayNow.push(turn);
      turnNumber = nextTurnNumber(turnNumber);
    }
    if (wordsToCheck.size)
      await this.checkWords(...wordsToCheck);
    if (turnsToPlayNow.length === 0)
      return turnsToPlayNow;
    console.debug(`Turn validation success.`);
    for (const { playerId, score, placements } of boardChanges) {
      this.board.placeTiles(...placements);
      this.board.scores.set(playerId, (this.board.scores.get(playerId) ?? 0) + score);
    }
    this.nextTurnNumber = turnNumber;
    return turnsToPlayNow;
  }
  *turnsFromParams(params, turnNumber) {
    let wordLocationStr = null;
    let blankTileIndicesStr = null;
    let direction = null;
    let wordPlayed = null;
    let exchangeIndicesStr = null;
    function* processPendingMoveIfAny() {
      const playerId = this.getPlayerForTurnNumber(turnNumber).id;
      if (wordPlayed && direction && wordLocationStr) {
        if (exchangeIndicesStr) {
          throw new UrlError(t("error.url.both_word_and_exchange", { turnNumber }));
        }
        const blankTileAssignments = [];
        if (blankTileIndicesStr) {
          blankTileIndicesStr.split(".").forEach((s) => {
            const match2 = s.match(/^(\d+)$/);
            if (!match2) {
              throw new UrlError(t("error.url.invalid_bt_component", { component: s }));
            }
            const index = parseInt(match2[1], 10);
            if (index in blankTileAssignments) {
              throw new UrlError(t("error.url.duplicate_bt_index", { param: blankTileIndicesStr }));
            }
            const assignedLetter = wordPlayed[index];
            if (!assignedLetter) {
              throw new UrlError(t("error.url.bt_index_out_of_range", { word: wordPlayed, index }));
            }
            blankTileAssignments[index] = assignedLetter;
          });
        }
        const match = wordLocationStr.match(/^(\d+)\.(\d+)$/);
        if (!match) {
          throw new UrlError(t("error.url.invalid_wl_param", { param: wordLocationStr }));
        }
        let row = parseInt(match[1], 10);
        let col = parseInt(match[2], 10);
        const placements = [];
        const lettersPlayed = wordPlayed.indexOf(".") === -1 ? [...wordPlayed] : wordPlayed.split(".");
        lettersPlayed.map((letter, letterIndex) => {
          const square = this.board.squares[row]?.[col];
          if (!square)
            throw new UrlError(t("error.url.word_out_of_bounds", { row, col }));
          if (!square.tile) {
            const assignedLetter = blankTileAssignments[letterIndex] ?? "";
            if (assignedLetter) {
              placements.push({ tile: new Tile({ letter: "", value: 0 }), row, col, assignedLetter });
            } else {
              const value = this.settings.letterValues.get(letter);
              if (value === undefined)
                throw new UrlError(t("error.url.invalid_letter", { letter }));
              placements.push({ tile: new Tile({ letter, value }), row, col });
            }
          } else if (square.letter !== letter) {
            throw new UrlError(t("error.url.wrong_letter", { requiredLetter: letter, row, col, actualLetter: square.letter }));
          }
          if (direction === "wv") {
            row += 1;
          } else {
            col += 1;
          }
        });
        if (blankTileAssignments.length > wordPlayed.length) {
          throw new UrlError(t("error.url.bt_index_range", { index: blankTileAssignments.length - 1, maxIndex: wordPlayed.length - 1 }));
        }
        yield new Turn(playerId, turnNumber, { playTiles: placements });
      } else if (exchangeIndicesStr != null) {
        if (wordPlayed || direction || wordLocationStr || blankTileIndicesStr) {
          throw new UrlError(t("error.url.incomplete_turn_data", { turnNumber, wl: wordLocationStr, direction, word: wordPlayed, bt: blankTileIndicesStr }));
        }
        const exchangeIndexStrs = exchangeIndicesStr ? exchangeIndicesStr.split(".") : [];
        const numberOfTilesInRack = this.tilesState.countTiles(playerId);
        const exchangeTileIndices = [];
        exchangeIndexStrs.forEach((s) => {
          const index = parseInt(s, 10);
          if (isNaN(index) || index < 0 || index >= numberOfTilesInRack) {
            throw new UrlError(t("error.url.invalid_exchange_index", { index: s }));
          }
          exchangeTileIndices.push(index);
        });
        yield new Turn(playerId, turnNumber, { exchangeTileIndices });
      } else {
        return;
      }
      turnNumber = nextTurnNumber(turnNumber);
      wordLocationStr = null;
      blankTileIndicesStr = null;
      direction = null;
      wordPlayed = null;
      exchangeIndicesStr = null;
    }
    for (const [key, value] of params) {
      const pnMatch = key.match(/^p(\d+)n$/);
      if (pnMatch) {
        const playerIndex = parseInt(pnMatch[1], 10) - 1;
        const player = this.players[playerIndex];
        if (player) {
          player.name = value;
        } else {
          throw new UrlError(t("error.url.invalid_player_id", { id: pnMatch[1], maxId: this.players.length }));
        }
      } else if (key === "wl") {
        yield* processPendingMoveIfAny.call(this);
        wordLocationStr = value;
      } else if (key === "ex") {
        yield* processPendingMoveIfAny.call(this);
        exchangeIndicesStr = value;
      } else if (key === "bt") {
        if (blankTileIndicesStr) {
          throw new UrlError(t("error.url.duplicate_bt_param", { turnNumber }));
        }
        blankTileIndicesStr = value;
      } else if (key === "wv" || key === "wh") {
        if (direction) {
          throw new UrlError(t("error.url.duplicate_word_params", { turnNumber }));
        }
        direction = key;
        wordPlayed = value;
      } else {
        throw new UrlError(t("error.url.unrecognized_param", { param: key }));
      }
    }
    yield* processPendingMoveIfAny.call(this);
  }
  toJSON() {
    return {
      gameId: this.gameId,
      nextTurnNumber: this.nextTurnNumber,
      settings: this.settings.toJSON(),
      board: this.board.toJSON(),
      tilesState: this.tilesState.toJSON()
    };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in SharedState serialization: ${JSON.stringify(json)}`);
    }
    if (typeof json !== "object")
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], [
      "gameId",
      "nextTurnNumber",
      "settings",
      "board",
      "tilesState"
    ]))
      fail("Wrong keys or key order");
    if (typeof json.gameId !== "string")
      fail("Game ID is not a string");
    if (typeof json.nextTurnNumber !== "number")
      fail("Next turn number is not a number");
    const settings = Settings.fromJSON(json.settings);
    return new SharedState(settings, json.gameId, Board.fromJSON(json.board), rehydrateTilesState(settings.tileSystemType, json.tilesState), toTurnNumber(json.nextTurnNumber));
  }
}
function makeTilesState(settings) {
  if (settings.tileSystemType === "honor") {
    return new HonorSystemTilesState(settings.players, settings.tileSystemSettings, makeTiles(settings), settings.rackCapacity);
  }
  throw new Error(`Unsupported tileSystemType: ${settings.tileSystemType}`);
}
function rehydrateTilesState(tileSystemType, tilesStateJson) {
  if (tileSystemType === "honor")
    return HonorSystemTilesState.fromJSON(tilesStateJson);
  throw new TypeError(`Unknown tileSystemType: ${tileSystemType}`);
}

// game/game_state.ts
function makeStorageKey(gameId) {
  return "sharewords_" + gameId;
}

class GameState extends EventTarget {
  playerId;
  keepAllHistory;
  tilesHeld;
  history;
  pendingExtraParams;
  shared;
  inPlayTurns = false;
  storage = null;
  constructor(playerId, settings, keepAllHistory = true, shared, tilesHeld = [], history = [], pendingExtraParams = new URLSearchParams) {
    super();
    this.playerId = playerId;
    this.keepAllHistory = keepAllHistory;
    this.tilesHeld = tilesHeld;
    this.history = history;
    this.pendingExtraParams = pendingExtraParams;
    if (!shared) {
      if (!settings) {
        throw new Error("New GameState requires either a Settings or a SharedState.");
      }
      shared = new SharedState(settings);
    }
    this.shared = shared;
    if (!this.shared.settings.players.some((p) => p.id === playerId)) {
      throw new Error(`Player ID "${playerId}" is not listed in settings.`);
    }
    this.board.addEventListener("tileplaced", (evt) => {
      const { placement } = evt.detail;
      const myTile = this.tilesHeld.find((p) => p.row === placement.row && p.col === placement.col);
      if (myTile && myTile.tile !== placement.tile) {
        console.debug(`My tile at ${placement.row},${placement.col} is displaced. Moving it to rack.`);
        this.moveTile(myTile.row, myTile.col, "rack", 0);
      }
    });
    this.tilesState.addEventListener("tiledraw", this.tiledraw.bind(this));
    this.tilesState.addEventListener("tilereturn", this.tilereturn.bind(this));
  }
  copyFrom(other) {
    this.shared.copyFrom(other.shared);
    this.keepAllHistory = other.keepAllHistory;
    this.tilesHeld.splice(0, this.tilesHeld.length, ...other.tilesHeld);
    this.history.splice(0, this.history.length, ...other.history);
    this.pendingExtraParams = other.pendingExtraParams;
  }
  save() {
    const gid = this.gameId;
    if (gid && this.storage) {
      const game = this.toJSON();
      const ver = this.settings.version;
      const ts = Date.now();
      const key = makeStorageKey(gid);
      const value = JSON.stringify({ game, ts, ver });
      this.storage.setItem(key, value);
    }
  }
  async init() {
    const tiles = await this.tilesState.getTiles(this.playerId);
    this.tilesHeld.splice(0, this.tilesHeld.length, ...tiles.map((tile, index) => {
      return {
        tile,
        row: "rack",
        col: index
      };
    }));
    this.tilesHeld.forEach((p) => {
      this.dispatchEvent(new TileEvent("tilemove", { detail: { placement: p } }));
    });
  }
  get gameId() {
    return this.shared.gameId;
  }
  get settings() {
    return this.shared.settings;
  }
  get nextTurnNumber() {
    return this.shared.nextTurnNumber;
  }
  get players() {
    return this.shared.players;
  }
  get board() {
    return this.shared.board;
  }
  get tilesState() {
    return this.shared.tilesState;
  }
  get numberOfTilesInBag() {
    return this.tilesState.numberOfTilesInBag;
  }
  get isGameOver() {
    return this.tilesState.isGameOver;
  }
  get exchangeTilesCount() {
    return this.tilesHeld.filter((p) => p.row === "exchange").length;
  }
  async getTiles(playerId) {
    return await this.tilesState.getTiles(playerId);
  }
  get turnUrlParams() {
    return this.shared.getTurnUrlParams(this.history.slice(1 - this.players.length));
  }
  getHistoryUrlParamsForPlayer(playerId) {
    return new URLSearchParams([["pid", playerId], ...this.shared.getTurnUrlParams(this.history)]);
  }
  get playerWhoseTurnItIs() {
    if (this.isGameOver)
      return null;
    return this.getPlayerForTurnNumber(this.nextTurnNumber);
  }
  getPlayerForTurnNumber(turnNumber) {
    return this.shared.getPlayerForTurnNumber(turnNumber);
  }
  tiledraw(evt) {
    if (evt.detail.playerId === this.playerId) {
      console.debug(`I drew "${evt.detail.tile.letter}".`);
      const occupiedIndices = new Set(this.tilesHeld.filter((p) => p.row === "rack").map((p) => p.col));
      for (let col = 0;col < this.settings.rackCapacity; ++col) {
        if (!occupiedIndices.has(col)) {
          this.tilesHeld.push({ row: "rack", col, tile: evt.detail.tile });
          return;
        }
      }
      throw new Error(`No room for drawn tile! ${JSON.stringify(this.tilesHeld)}`);
    }
  }
  tilereturn(evt) {
    if (evt.detail.playerId === this.playerId) {
      let index = this.tilesHeld.findIndex((p) => p.row === "exchange" && p.tile.equals(evt.detail.tile));
      if (index === -1)
        index = this.tilesHeld.findIndex((p) => p.tile.equals(evt.detail.tile));
      if (index === -1) {
        console.error(`Tile not found for exchange: ${JSON.stringify(evt.detail.tile)}`);
      } else {
        this.tilesHeld.splice(index, 1);
      }
    }
  }
  moveTile(fromRow, fromCol, toRow, toCol, assignedLetter) {
    const preparation = this.prepareTileMove(fromRow, fromCol, toRow, toCol);
    if (!preparation.success)
      throw new RangeError(preparation.message);
    for (const pushed of preparation.toPush) {
      const pushedFromCol = pushed.col;
      pushed.col = pushedFromCol + preparation.pushDirection;
      this.dispatchEvent(new TileEvent("tilemove", { detail: { fromRow, fromCol: pushedFromCol, placement: pushed } }));
    }
    preparation.placement.row = preparation.toRow;
    preparation.placement.col = preparation.toCol;
    preparation.placement.assignedLetter = assignedLetter;
    if (!isBoardPlacementRow(preparation.toRow)) {
      delete preparation.placement.assignedLetter;
    }
    this.dispatchEvent(new TileEvent("tilemove", { detail: { fromRow, fromCol, placement: preparation.placement } }));
  }
  prepareTileMove(fromRow, fromCol, toRow, toCol) {
    const placement = this.tilesHeld.find((p) => p.row === fromRow && p.col === fromCol);
    if (placement === undefined)
      return { success: false, message: `No tile at ${fromRow},${fromCol}.` };
    let pushDirection = toRow !== fromRow || toCol < fromCol ? 1 : -1;
    let toPush = [];
    const occupant = fromRow === toRow && fromCol === toCol ? undefined : this.tilesHeld.find((p) => p.row === toRow && p.col === toCol);
    if (toRow === "rack" || toRow === "exchange") {
      const capacity = this.settings.rackCapacity;
      if (!indicesOk(capacity, toCol))
        return { success: false, message: `Invalid toCol: ${toCol}` };
      if (occupant) {
        let tryPush = function() {
          const newToPush2 = [];
          for (let col = toCol;; col += pushDirection) {
            if (col < 0 || col >= capacity)
              return null;
            const rowmate = newRowmates.get(col);
            if (rowmate)
              newToPush2.push(rowmate);
            else
              return newToPush2;
          }
        };
        const newRowmates = new Map(this.tilesHeld.filter((p) => p.row === toRow && !(p.row === fromRow && p.col === fromCol)).map((p) => [p.col, p]));
        if (toRow === fromRow && toCol > fromCol) {
          pushDirection = -1;
        } else {
          pushDirection = 1;
        }
        let newToPush = tryPush();
        if (!newToPush) {
          pushDirection = -pushDirection;
          newToPush = tryPush();
          if (!newToPush)
            return {
              success: false,
              message: `${toRow === "rack" ? "Rack" : "Exchange area"} is full.`
            };
        }
        toPush = newToPush;
      }
    } else {
      const square = this.board.squares[toRow]?.[toCol];
      if (!square)
        return { success: false, message: `Tile destination ${toRow},${toCol} is off the board.` };
      if (occupant || square.tile) {
        for (const [deltaRow, deltaCol] of [[0, 1], [1, 0], [-1, 0], [0, -1]]) {
          const [row, col] = [toRow + deltaRow, toCol + deltaCol];
          const nearbySquare = this.board.squares[row]?.[col];
          if (!nearbySquare)
            continue;
          if (nearbySquare.tile)
            continue;
          if (this.tilesHeld.some((p) => p.row === row && p.col === col))
            continue;
          return { success: true, placement, toRow: row, toCol: col, pushDirection, toPush };
        }
        return { success: false, message: `Square ${toRow},${toCol} is occupied` };
      }
    }
    return { success: true, placement, toRow, toCol, pushDirection, toPush };
  }
  recallTiles() {
    const placedTiles = this.tilesHeld.filter((p) => p.row !== "rack");
    const occupiedRackSpots = new Set(this.tilesHeld.filter((p) => p.row === "rack").map((p) => p.col));
    let nextFreeSpot = 0;
    for (const placement of placedTiles) {
      while (occupiedRackSpots.has(nextFreeSpot)) {
        ++nextFreeSpot;
      }
      if (nextFreeSpot >= this.settings.rackCapacity) {
        console.error("No space in rack to recall tile.");
        break;
      }
      this.moveTile(placement.row, placement.col, "rack", nextFreeSpot);
      ++nextFreeSpot;
    }
  }
  async playWord() {
    const placements = this.tilesHeld.filter(isBoardPlacement);
    const turn = new Turn(this.playerId, this.nextTurnNumber, { playTiles: placements });
    turn.extraParams = this.pendingExtraParams;
    this.pendingExtraParams = new URLSearchParams;
    await this.playTurns([turn]);
  }
  async passOrExchange() {
    const placements = this.tilesHeld.map((p, index) => ({ p, index })).filter(({ p }) => p.row === "exchange");
    const exchangeTileIndices = placements.map(({ index }) => index);
    const turn = new Turn(this.playerId, this.nextTurnNumber, { exchangeTileIndices });
    turn.extraParams = this.pendingExtraParams;
    this.pendingExtraParams = new URLSearchParams;
    await this.playTurns([turn]);
  }
  async playTurns(turns) {
    if (this.isGameOver) {
      throw new Error("Game Over.");
    }
    if (this.inPlayTurns)
      throw new Error(`playTurns: recursion detected.`);
    const json = this.toJSON();
    const oldNextTurnNumber = this.nextTurnNumber;
    let ok = false;
    try {
      this.inPlayTurns = true;
      await this.doPlayTurns(turns);
      this.save();
      ok = true;
    } finally {
      this.inPlayTurns = false;
      if (!ok) {
        console.log("Rolling back game state.");
        this.copyFrom(GameState.fromJSON(json));
        this.dispatchEvent(new GameEvent("turnchange"));
      }
    }
    if (this.nextTurnNumber !== oldNextTurnNumber) {
      this.dispatchEvent(new GameEvent("turnchange"));
    }
  }
  async doPlayTurns(turns) {
    const newTurns = [];
    let finalTurnNumber = null;
    for (const turn of turns) {
      for (const newTurn of await this.shared.playTurns(turn)) {
        if (newTurn.playerId === this.playerId && "playTiles" in newTurn.move) {
          for (const placement of newTurn.move.playTiles) {
            let index = this.tilesHeld.findIndex((p) => p.row === placement.row && p.col === placement.col && p.tile.equals(placement.tile));
            if (index === -1)
              index = this.tilesHeld.findIndex((p) => p.tile.equals(placement.tile));
            if (index === -1)
              index = this.tilesHeld.findIndex((p) => p.tile.isBlank);
            if (index === -1)
              throw new Error(`Could not find tile to place: ${JSON.stringify(placement)}`);
            this.tilesHeld.splice(index, 1);
          }
        }
        finalTurnNumber = await this.tilesState.playTurns(turn);
        newTurns.push(turn);
        if (finalTurnNumber !== null)
          break;
      }
    }
    updateTurnHistory({
      history: this.history,
      nextTurnNumber: this.nextTurnNumber,
      finalTurnNumber,
      turns: newTurns
    });
    if (finalTurnNumber !== null) {
      const finalTurnPlayerId = this.getPlayerForTurnNumber(finalTurnNumber).id;
      console.log(`Player ${finalTurnPlayerId} ends game after turn ${finalTurnNumber}.`);
      let allTilesSum = 0;
      for (const player of this.players) {
        if (player.id !== finalTurnPlayerId) {
          const playerTiles = await this.getTiles(player.id);
          const tilesSum = playerTiles.reduce((sum, curr) => sum + curr.value, 0);
          this.board.scores.set(player.id, (this.board.scores.get(player.id) ?? 0) - tilesSum);
          console.log(`Transfering ${tilesSum} from Player ${player.id}.`);
          allTilesSum += tilesSum;
        }
      }
      console.log(`Transfering ${allTilesSum} to Player ${finalTurnPlayerId}.`);
      this.board.scores.set(finalTurnPlayerId, (this.board.scores.get(finalTurnPlayerId) ?? 0) + allTilesSum);
    }
    if (!this.keepAllHistory) {
      const turnsToKeep = this.players.length - 1;
      if (turnsToKeep > 0 && this.history.length > turnsToKeep) {
        this.history.splice(0, this.history.length - turnsToKeep);
      }
    }
  }
  changePlayerName(playerId, name) {
    const playerIndex = this.players.findIndex((p) => p.id === playerId);
    if (playerIndex === -1) {
      throw new Error(`Player with ID ${playerId} not found.`);
    }
    const player = this.players[playerIndex];
    if (player.name !== name) {
      player.name = name;
      this.pendingExtraParams.set(`p${playerIndex + 1}n`, name);
      this.dispatchEvent(new GameEvent("turnchange"));
    }
  }
  async applyTurnParams(params) {
    if (this.isGameOver)
      return;
    const iterator = params[Symbol.iterator]();
    let urlTurnNumberStr;
    for (const [key, value] of iterator) {
      if (key !== "tn")
        continue;
      urlTurnNumberStr = value;
      break;
    }
    if (!urlTurnNumberStr) {
      console.info("applyTurnParams: no turn number found.");
      return;
    }
    const turnNumber = toTurnNumber(parseInt(urlTurnNumberStr));
    if (isNaN(turnNumber)) {
      throw new UrlError(t("error.url.tn_not_a_number", { param: urlTurnNumberStr }));
    }
    await this.playTurns(this.shared.turnsFromParams(iterator, turnNumber));
  }
  static async fromParams(params) {
    const { settings, playerId, turnParams } = parseGameParams(params);
    const gameState = new GameState(playerId, settings);
    await gameState.init();
    await gameState.applyTurnParams(turnParams);
    return gameState;
  }
  toJSON() {
    return {
      shared: this.shared.toJSON(),
      playerId: this.playerId,
      keepAllHistory: this.keepAllHistory,
      tilesHeld: this.tilesHeld.map((placement) => {
        const json = {
          tile: placement.tile.toJSON(),
          row: placement.row,
          col: placement.col
        };
        if (placement.assignedLetter)
          json.assignedLetter = placement.assignedLetter;
        return json;
      }),
      history: this.history.map((turnData) => {
        return { turnNumber: turnData.turnNumber, params: turnData.paramsStr };
      }),
      pendingExtraParams: this.pendingExtraParams.toString()
    };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in GameState serialization: ${JSON.stringify(json)}`);
    }
    if (typeof json !== "object")
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], ["shared", "playerId", "keepAllHistory", "tilesHeld", "history", "pendingExtraParams"])) {
      fail("Wrong keys or key order");
    }
    if (typeof json.playerId !== "string")
      fail("Player ID is not a string");
    if (typeof json.keepAllHistory !== "boolean")
      fail("keepAllHistory is not a boolean");
    if (!Array.isArray(json.tilesHeld))
      fail("tilesHeld is not an array");
    if (!Array.isArray(json.history))
      fail("History is not an array");
    if (typeof json.pendingExtraParams !== "string")
      fail("pendingExtraParams is not a string");
    const tilesHeld = json.tilesHeld.map((tileJson) => {
      if (typeof tileJson !== "object")
        fail("tilesHeld element is not an object");
      if (!arraysEqual([...Object.keys({ ...tileJson, assignedLetter: "x" })], ["tile", "row", "col", "assignedLetter"])) {
        fail("Wrong tilesHeld element keys or key order");
      }
      if (typeof tileJson.row !== "number" && tileJson.row !== "rack" && tileJson.row !== "exchange") {
        fail("Invalid tilesHeld[].row");
      }
      if (typeof tileJson.col !== "number")
        fail("Invalid tilesHeld[].col");
      if (tileJson.assignedLetter !== undefined && typeof tileJson.assignedLetter !== "string") {
        fail("Invalid tilesHeld[].assignedLetter");
      }
      const tile = Tile.fromJSON(tileJson.tile);
      if (tile.letter && tileJson.assignedLetter)
        fail("Non-blank tile with an assigned letter");
      const result = {
        tile,
        row: tileJson.row,
        col: tileJson.col
      };
      if (tileJson.assignedLetter)
        result.assignedLetter = tileJson.assignedLetter;
      return result;
    });
    const history = json.history.map((turnDataJson) => {
      if (!arraysEqual([...Object.keys(turnDataJson)], ["turnNumber", "params"])) {
        fail("Wrong history element keys or key order");
      }
      if (typeof turnDataJson.turnNumber !== "number")
        fail("turnNumber is not a number");
      if (typeof turnDataJson.params !== "string")
        fail("params is not a string");
      return { turnNumber: toTurnNumber(turnDataJson.turnNumber), paramsStr: turnDataJson.params };
    });
    const gameState = new GameState(json.playerId, undefined, json.keepAllHistory, SharedState.fromJSON(json.shared), tilesHeld, history, new URLSearchParams(json.pendingExtraParams));
    return gameState;
  }
}

// view/dialog.ts
class Dialog {
  title;
  content;
  buttons;
  dialogElement;
  contentElement;
  promiseResolve = () => {};
  doc;
  constructor(doc, title, content, buttons) {
    this.title = title;
    this.content = content;
    this.buttons = buttons;
    this.doc = doc;
    this.dialogElement = this.doc.createElement("dialog");
    this.dialogElement.innerHTML = `
      <form method="dialog">
        <h2>${this.title}</h2>
        <div class="content"></div>
        <div class="buttons"></div>
      </form>
    `;
    this.contentElement = this.dialogElement.querySelector(".content");
    this.contentElement.appendChild(this.content);
    const buttonsContainer = this.dialogElement.querySelector(".buttons");
    for (const label of this.buttons) {
      const button = this.doc.createElement("button");
      button.textContent = label;
      button.value = label;
      buttonsContainer.appendChild(button);
    }
    this.doc.body.appendChild(this.dialogElement);
    this.dialogElement.addEventListener("close", () => {
      this.promiseResolve(this.dialogElement.returnValue);
      this.dialogElement.remove();
    });
  }
  show() {
    this.dialogElement.showModal();
    return new Promise((resolve) => {
      this.promiseResolve = resolve;
    });
  }
  close() {
    this.dialogElement.close();
  }
}

// view/game_setup.ts
class GameSetup {
  gameState;
  browser;
  doc;
  settingsDialog;
  playerList;
  addPlayerButton;
  dictionaryType;
  dictionaryUrlContainer;
  dictionaryUrl;
  bingoBonus;
  randomSeed;
  startGameButton;
  cancelSettingsButton;
  constructor(gameState, browser) {
    this.gameState = gameState;
    this.browser = browser;
    this.doc = browser.getDocument();
    this.settingsDialog = this.doc.getElementById("settings-dialog");
    this.playerList = this.doc.getElementById("player-list");
    this.addPlayerButton = this.doc.getElementById("add-player-button");
    this.dictionaryType = this.doc.getElementById("dictionary-type");
    this.dictionaryUrlContainer = this.doc.getElementById("dictionary-url-container");
    this.dictionaryUrl = this.doc.getElementById("dictionary-url");
    this.bingoBonus = this.doc.getElementById("bingo-bonus");
    this.randomSeed = this.doc.getElementById("random-seed");
    this.startGameButton = this.doc.getElementById("start-game-with-settings");
    this.cancelSettingsButton = this.doc.getElementById("cancel-settings");
    this._bindSettingsDialogEvents();
  }
  _bindSettingsDialogEvents() {
    this.addPlayerButton.addEventListener("click", () => {
      const currentPlayers = Array.from(this.playerList.querySelectorAll("input")).map((i) => ({ name: i.value }));
      currentPlayers.push({ name: "" });
      this._updatePlayerList(currentPlayers);
    });
    this.dictionaryType.addEventListener("change", () => this._handleDictChange());
    this.startGameButton.addEventListener("click", () => {
      const params = new URLSearchParams;
      const playerInputs = Array.from(this.playerList.querySelectorAll("input"));
      const playerNames = playerInputs.map((input) => input.value).filter((name) => name.trim() !== "");
      playerNames.map((name, index) => {
        params.set(`p${index + 1}n`, name);
      });
      const dictionaryType = this.dictionaryType.value;
      params.set("dt", dictionaryType);
      if (dictionaryType === "freeapi" || dictionaryType === "custom") {
        const url = this.dictionaryUrl.value;
        if (url) {
          params.set("ds", url);
        }
      }
      params.set("bingo", this.bingoBonus.value);
      params.set("seed", this.randomSeed.value || String(Math.floor(1e6 * this.browser.getRandom())));
      this.browser.setHash(params.toString());
      this.browser.reload();
    });
    this.cancelSettingsButton.addEventListener("click", () => {
      this.settingsDialog.hidden = true;
    });
  }
  _updatePlayerList(players) {
    this.playerList.innerHTML = "";
    players.forEach((player, index) => {
      const playerEntry = this.doc.createElement("div");
      playerEntry.className = "player-entry";
      const input = this.doc.createElement("input");
      input.type = "text";
      input.value = player.name;
      input.placeholder = t("ui.settings.player_placeholder", { index: index + 1 });
      playerEntry.appendChild(input);
      const removeButton = this.doc.createElement("button");
      removeButton.textContent = t("ui.buttons.remove_player");
      removeButton.onclick = () => {
        const currentPlayers = Array.from(this.playerList.querySelectorAll("input")).map((i) => ({ name: i.value }));
        currentPlayers.splice(index, 1);
        this._updatePlayerList(currentPlayers);
      };
      playerEntry.appendChild(removeButton);
      if (this.gameState.keepAllHistory && player.id !== undefined) {
        const historyParams = this.gameState.getHistoryUrlParamsForPlayer(player.id);
        const replayLink = this.doc.createElement("a");
        const gameUrl = this.browser.getHref().replace(this.browser.getHash(), "");
        replayLink.href = gameUrl + "#" + historyParams;
        const linkText = this.doc.createTextNode(t("ui.game.join_link"));
        replayLink.appendChild(linkText);
        playerEntry.appendChild(replayLink);
      }
      this.playerList.appendChild(playerEntry);
    });
  }
  _handleDictChange() {
    const selectedValue = this.dictionaryType.value;
    if (selectedValue === "freeapi" || selectedValue === "custom") {
      this.dictionaryUrlContainer.hidden = false;
      this.dictionaryUrl.required = selectedValue === "custom";
    } else {
      this.dictionaryUrlContainer.hidden = true;
    }
  }
  _populateSettingsDialog() {
    this._updatePlayerList(this.gameState.players);
    this.dictionaryType.value = this.gameState.settings.dictionaryType;
    this._handleDictChange();
    if (this.gameState.settings.dictionarySettings && typeof this.gameState.settings.dictionarySettings === "object" && "url" in this.gameState.settings.dictionarySettings && typeof this.gameState.settings.dictionarySettings.url === "string") {
      this.dictionaryUrl.value = this.gameState.settings.dictionarySettings.url;
    } else {
      this.dictionaryUrl.value = "";
    }
    this.bingoBonus.value = String(this.gameState.settings.bingoBonus);
    this.randomSeed.value = this.gameState.settings.tileSystemSettings.seed;
  }
  showSettingsDialog() {
    if (this.settingsDialog.hidden) {
      this._populateSettingsDialog();
      this.settingsDialog.hidden = false;
    } else {
      this.settingsDialog.hidden = true;
    }
  }
  debugContainer;
  initDebugDisplay(bufferedLogs) {
    const buttons = this.settingsDialog.querySelector(".buttons");
    if (!buttons)
      return;
    this.debugContainer = this.doc.createElement("div");
    this.debugContainer.id = "debug-console";
    this.debugContainer.style.height = "150px";
    this.debugContainer.style.overflowY = "scroll";
    this.debugContainer.style.border = "1px solid #ccc";
    this.debugContainer.style.padding = "5px";
    this.debugContainer.style.marginTop = "10px";
    buttons.after(this.debugContainer);
    for (const message of bufferedLogs) {
      this.addDebugMessage(message);
    }
  }
  addDebugMessage(message) {
    if (!this.debugContainer)
      return;
    const p = this.doc.createElement("pre");
    p.style.margin = "0";
    p.style.fontFamily = "monospace";
    p.textContent = message;
    this.debugContainer.appendChild(p);
    this.debugContainer.scrollTop = this.debugContainer.scrollHeight;
  }
}

// view/view.ts
class View {
  gameContainer;
  boardContainer;
  boardTransformer;
  rackContainer;
  exchangeContainer;
  scorePanel;
  bagTileCountContainer;
  gameState;
  gameSetup;
  dropTargetMap = new Map;
  doc;
  constructor(gameState, browser) {
    this.gameState = gameState;
    this.doc = browser.getDocument();
    this.gameContainer = this.doc.getElementById("game-container");
    this.boardContainer = this.gameContainer.querySelector("#board-container");
    this.boardTransformer = this.doc.createElement("div");
    this.boardTransformer.id = "board-transformer";
    this.boardContainer.appendChild(this.boardTransformer);
    this.rackContainer = this.gameContainer.querySelector("#rack-container");
    this.exchangeContainer = this.gameContainer.querySelector("#exchange-container");
    this.scorePanel = this.gameContainer.querySelector("#score-panel");
    this.bagTileCountContainer = this.gameContainer.querySelector("#bag-tile-count-container");
    this.gameSetup = new GameSetup(gameState, browser);
    this.gameState.addEventListener("turnchange", () => this.renderScores());
  }
  addTileToElement(element, tile, assignedLetter) {
    element.textContent = "";
    const letterDiv = this.doc.createElement("div");
    letterDiv.className = "letter";
    letterDiv.textContent = assignedLetter || tile.letter || "?";
    element.appendChild(letterDiv);
    if (!tile.isBlank) {
      const valueDiv = this.doc.createElement("div");
      valueDiv.className = "value";
      valueDiv.textContent = String(tile.value);
      element.appendChild(valueDiv);
    }
  }
  addBonusTextToSquare(squareDiv, square) {
    const bonusSpan = this.doc.createElement("span");
    bonusSpan.className = "bonus-text";
    if (square.letterBonus === 2)
      bonusSpan.textContent = "2L";
    if (square.letterBonus === 3)
      bonusSpan.textContent = "3L";
    if (square.wordBonus === 2)
      bonusSpan.textContent = "2W";
    if (square.wordBonus === 3)
      bonusSpan.textContent = "3W";
    if (bonusSpan.textContent)
      squareDiv.appendChild(bonusSpan);
  }
  renderSquare(row, col, squareDiv = this.getElementByLocation(row, col)) {
    if (!squareDiv)
      return;
    squareDiv.innerHTML = "";
    squareDiv.classList.remove("placed");
    const square = this.gameState.board.squares[row][col];
    if (square.tile) {
      this.addTileToElement(squareDiv, square.tile, square.assignedLetter);
    } else {
      const placedTile = this.gameState.tilesHeld.find((p) => p.row === row && p.col === col);
      if (placedTile) {
        this.addTileToElement(squareDiv, placedTile.tile, placedTile.assignedLetter);
        squareDiv.classList.add("placed");
        squareDiv.tabIndex = 0;
      } else {
        this.addBonusTextToSquare(squareDiv, square);
      }
    }
  }
  renderBoard() {
    this.boardTransformer.innerHTML = "";
    const dimension = this.gameState.board.squares.length;
    this.boardTransformer.style.gridTemplateColumns = `repeat(${dimension}, 1fr)`;
    this.boardTransformer.style.gridTemplateRows = `repeat(${dimension}, 1fr)`;
    const baseSquareSize = 40;
    const baseFontSize = 24;
    const squareSize = 601 / dimension;
    const fontSize = squareSize / baseSquareSize * baseFontSize;
    this.boardTransformer.style.fontSize = `${fontSize}px`;
    const centerSquare = this.gameState.board.centerSquare;
    for (let r = 0;r < this.gameState.board.squares.length; r++) {
      const row = this.gameState.board.squares[r];
      if (!row)
        throw new Error(`Invalid board: Row ${r} is missing.`);
      for (let c = 0;c < row.length; c++) {
        const square = row[c];
        if (!square)
          throw new Error(`Invalid board: Square ${r},${c} is missing.`);
        const squareDiv = this.doc.createElement("div");
        squareDiv.className = "square";
        if (square.letterBonus === 2)
          squareDiv.classList.add("dl");
        if (square.letterBonus === 3)
          squareDiv.classList.add("tl");
        if (square.wordBonus === 2)
          squareDiv.classList.add("dw");
        if (square.wordBonus === 3)
          squareDiv.classList.add("tw");
        if (r === centerSquare.row && c === centerSquare.col)
          squareDiv.classList.add("center");
        squareDiv.dataset.row = String(r);
        squareDiv.dataset.col = String(c);
        this.boardTransformer.appendChild(squareDiv);
        this.renderSquare(r, c, squareDiv);
      }
    }
  }
  renderScores() {
    this.scorePanel.innerHTML = "";
    const currentPlayer = this.gameState.playerWhoseTurnItIs;
    let maxScore = -Infinity;
    if (this.gameState.isGameOver) {
      const scores = [...this.gameState.board.scores.values()];
      if (scores.length > 0) {
        maxScore = Math.max(...scores);
      }
    }
    for (const player of this.gameState.players) {
      const score = this.gameState.board.scores.get(player.id) ?? 0;
      const scoreDiv = this.doc.createElement("div");
      scoreDiv.className = "player-score";
      if (player.id === currentPlayer?.id) {
        scoreDiv.classList.add("current-player");
      }
      const nameSpan = this.doc.createElement("span");
      nameSpan.textContent = player.name;
      const scoreSpan = this.doc.createElement("span");
      scoreSpan.textContent = `: ${score}`;
      if (this.gameState.isGameOver && score === maxScore) {
        scoreSpan.textContent += " \uD83C\uDF89";
      }
      const editButton = this.doc.createElement("span");
      editButton.textContent = " ✏️";
      editButton.className = "edit-button";
      editButton.style.cursor = "pointer";
      editButton.addEventListener("click", () => {
        const input = this.doc.createElement("input");
        input.type = "text";
        input.value = player.name;
        scoreDiv.replaceChild(input, nameSpan);
        input.focus();
        const save = () => {
          if (input.value && input.value !== player.name) {
            this.gameState.changePlayerName(player.id, input.value);
          }
        };
        const cancel = () => {
          scoreDiv.replaceChild(nameSpan, input);
        };
        input.addEventListener("blur", save);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            save();
          } else if (e.key === "Escape") {
            cancel();
          }
        });
      });
      if (player.id === this.gameState.playerId) {
        scoreDiv.appendChild(editButton);
      }
      scoreDiv.appendChild(nameSpan);
      scoreDiv.appendChild(scoreSpan);
      this.scorePanel.appendChild(scoreDiv);
    }
  }
  renderRackSpot(rackName, col) {
    const spotElement = this.getElementByLocation(rackName, col);
    if (!spotElement)
      return;
    spotElement.innerHTML = "";
    spotElement.removeAttribute("tabIndex");
    spotElement.className = "";
    const tilePlacement = this.gameState.tilesHeld.find((p) => p.row === rackName && p.col === col);
    if (tilePlacement) {
      spotElement.className = "tile";
      this.addTileToElement(spotElement, tilePlacement.tile, tilePlacement.assignedLetter);
      spotElement.tabIndex = 0;
    } else {
      spotElement.className = "tile-spot";
    }
  }
  renderRacklike(container, name) {
    container.innerHTML = "";
    for (let i = 0;i < this.gameState.settings.rackCapacity; i++) {
      const spotDiv = this.doc.createElement("div");
      spotDiv.dataset.row = name;
      spotDiv.dataset.col = String(i);
      container.appendChild(spotDiv);
      this.renderRackSpot(name, i);
    }
  }
  renderRack() {
    this.renderRacklike(this.rackContainer, "rack");
    this.renderRacklike(this.exchangeContainer, "exchange");
  }
  renderTileSpot(row, col) {
    if (isBoardPlacementRow(row)) {
      this.renderSquare(row, col);
    } else {
      this.renderRackSpot(row, col);
    }
  }
  renderBagTileCount() {
    this.bagTileCountContainer.textContent = t("ui.bag_tile_count", { count: this.gameState.numberOfTilesInBag });
  }
  renderActionButtons() {
    const passExchangeButton = this.doc.getElementById("pass-exchange");
    const playWordButton = this.doc.getElementById("play-word");
    const isLocalPlayerTurn = this.gameState.playerWhoseTurnItIs?.id === this.gameState.playerId;
    passExchangeButton.disabled = !isLocalPlayerTurn;
    playWordButton.disabled = !isLocalPlayerTurn;
    const count = this.gameState.exchangeTilesCount;
    if (count === 0) {
      passExchangeButton.textContent = t("ui.buttons.pass_turn");
    } else {
      passExchangeButton.textContent = t("ui.buttons.exchange_count", { count });
    }
  }
  getElementByLocation(row, col) {
    const selector = `[data-row="${row}"][data-col="${col}"]`;
    if (typeof row === "number") {
      return this.boardTransformer.querySelector(selector);
    }
    return this.doc.querySelector(selector);
  }
  clearDropTarget(dropTargetId) {
    const dropTarget = this.dropTargetMap.get(dropTargetId);
    if (dropTarget) {
      this.dropTargetMap.delete(dropTargetId);
      if (!this.dropTargetMap.values().find((v) => v.row === dropTarget.row && v.col === dropTarget.col)) {
        const el = this.getElementByLocation(dropTarget.row, dropTarget.col);
        el?.classList.remove("drop-target");
      }
    }
  }
  setDropTarget(dropTargetId, row, col) {
    this.clearDropTarget(dropTargetId);
    const el = this.getElementByLocation(row, col);
    if (el) {
      el.classList.add("drop-target");
      this.dropTargetMap.set(dropTargetId, { row, col });
    }
  }
  getDropTarget(dropTargetId) {
    return this.dropTargetMap.get(dropTargetId);
  }
  deselect(dropTargetId, selectedTile) {
    const prevSelected = this.getElementByLocation(selectedTile.row, selectedTile.col);
    prevSelected?.classList.remove("selected");
    this.clearDropTarget(dropTargetId);
  }
  select(row, col) {
    const element = this.getElementByLocation(row, col);
    element?.classList.add("selected");
  }
  createGhostTile(originalTileElement) {
    const ghostTile = originalTileElement.cloneNode(true);
    ghostTile.classList.remove("selected");
    ghostTile.classList.add("ghost-tile");
    this.doc.body.appendChild(ghostTile);
    return ghostTile;
  }
  removeGhostTile(ghostTileElement) {
    if (ghostTileElement && ghostTileElement.parentNode) {
      ghostTileElement.parentNode.removeChild(ghostTileElement);
    }
  }
  async showConfirmationDialog(title, showCopyCheckbox) {
    const content = this.doc.createElement("div");
    let copyUrlCheckbox;
    if (showCopyCheckbox) {
      const copyUrlContainer = this.doc.createElement("div");
      const label = this.doc.createElement("label");
      const checkbox = this.doc.createElement("input");
      checkbox.type = "checkbox";
      checkbox.id = "copy-url-checkbox";
      checkbox.checked = true;
      label.appendChild(checkbox);
      label.appendChild(this.doc.createTextNode(t("ui.dialog.copy_turn_url")));
      copyUrlContainer.appendChild(label);
      copyUrlCheckbox = checkbox;
      content.appendChild(copyUrlContainer);
    }
    const dialog = new Dialog(this.doc, title, content, [t("ui.buttons.ok"), t("ui.buttons.cancel_settings")]);
    const result = await dialog.show();
    return {
      confirmed: result === "OK",
      copyUrl: result === "OK" && (copyUrlCheckbox?.checked ?? false)
    };
  }
  showSettingsDialog() {
    this.gameSetup.showSettingsDialog();
  }
  setBoardTransform(scale, x, y) {
    this.boardTransformer.style.transform = `scale(${scale}) translate(${x}px, ${y}px)`;
  }
  getBoardContainer() {
    return this.boardContainer;
  }
}

// controller/key_handler.ts
class KeyHandler {
  gameState;
  view;
  selectedTile = null;
  constructor(gameState, view) {
    this.gameState = gameState;
    this.view = view;
  }
  select(row, col) {
    this.deselect();
    this.selectedTile = { row, col };
    this.view.select(row, col);
    this.view.setDropTarget("keyboard", row, col);
  }
  deselect() {
    if (!this.selectedTile)
      return;
    this.view.deselect("keyboard", this.selectedTile);
    this.selectedTile = null;
  }
  keydown(evt) {
    const target = evt.target;
    if (!target.dataset.col || !target.dataset.row)
      return;
    const col = parseInt(target.dataset.col, 10);
    const rowStr = target.dataset.row;
    const row = rowStr === "rack" ? "rack" : rowStr === "exchange" ? "exchange" : parseInt(rowStr, 10);
    switch (evt.key) {
      case " ":
      case "Enter": {
        evt.preventDefault();
        if (this.selectedTile) {
          const dropTarget = this.view.getDropTarget("keyboard");
          if (!dropTarget)
            return;
          const { row: toRow, col: toCol } = dropTarget;
          if (isBoardPlacementRow(toRow)) {
            if (this.gameState.board.squares[toRow]?.[toCol]?.tile)
              return;
            if (this.gameState.tilesHeld.find((p) => p.row === toRow && p.col === toCol))
              return;
          }
          try {
            const selectedPlacement = this.gameState.tilesHeld.find((p) => p.row === this.selectedTile.row && p.col === this.selectedTile.col);
            let assignedLetter;
            if (selectedPlacement?.tile.isBlank && isBoardPlacementRow(toRow)) {
              const letter = prompt("Enter a letter for the blank tile:");
              if (!letter || letter.length !== 1 || !/^[a-zA-Z]$/.test(letter)) {
                alert("Invalid letter. Please enter a single letter.");
                return;
              }
              assignedLetter = letter.toUpperCase();
            }
            this.gameState.moveTile(this.selectedTile.row, this.selectedTile.col, toRow, toCol, assignedLetter);
            this.deselect();
          } catch (e) {
            alert(e);
          }
        } else {
          this.select(row, col);
          this.view.setDropTarget("keyboard", row, col);
        }
        break;
      }
      case "Escape": {
        evt.preventDefault();
        if (this.selectedTile) {
          const previouslySelected = this.view.getElementByLocation(this.selectedTile.row, this.selectedTile.col);
          this.deselect();
          previouslySelected?.focus();
        }
        break;
      }
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight": {
        evt.preventDefault();
        this.moveDropTarget(evt.key);
        break;
      }
    }
  }
  moveDropTarget(key) {
    const dropTarget = this.view.getDropTarget("keyboard");
    if (!this.selectedTile || !dropTarget)
      return;
    let { row: r, col: c } = dropTarget;
    const rackCapacity = this.gameState.settings.rackCapacity;
    const boardCenterCol = this.gameState.board.centerSquare.col;
    const rackCenter = Math.ceil((rackCapacity - 1) / 2);
    const boardCenterRow = this.gameState.board.centerSquare.row;
    const boardWidth = this.gameState.board.squares[boardCenterRow].length;
    const boardHeight = this.gameState.board.squares.length;
    switch (key) {
      case "ArrowUp":
        if (r === "exchange") {
          r = "rack";
        } else if (r === "rack") {
          const offset = c - rackCenter;
          c = boardCenterCol + offset;
          c = Math.max(0, Math.min(boardWidth - 1, c));
          r = boardHeight - 1;
        } else if (r > 0) {
          r--;
        }
        break;
      case "ArrowDown":
        if (r === "rack") {
          r = "exchange";
        } else if (r !== "exchange") {
          if (r === boardHeight - 1) {
            const offset = c - boardCenterCol;
            c = rackCenter + offset;
            c = Math.max(0, Math.min(rackCapacity - 1, c));
            r = "rack";
          } else if (r < boardHeight - 1) {
            r++;
          }
        }
        break;
      case "ArrowLeft":
        if (r === "rack" && c === 0 && boardWidth > 0) {
          r = boardCenterRow;
          c = boardWidth - 1;
        } else if (c > 0) {
          c--;
        }
        break;
      case "ArrowRight":
        if (r === "rack" || r === "exchange") {
          if (c < rackCapacity - 1) {
            c++;
          }
        } else {
          if (c === boardWidth - 1) {
            r = "rack";
            c = 0;
          } else {
            c++;
          }
        }
        break;
    }
    this.view.setDropTarget("keyboard", r, c);
  }
}

// controller/pointer_handler.ts
class PointerHandler {
  gameState;
  view;
  pointerInfoMap = new Map;
  scale = 1;
  panX = 0;
  panY = 0;
  lastTap = 0;
  constructor(gameState, view) {
    this.gameState = gameState;
    this.view = view;
  }
  scrollWindowBy(dx, dy) {
    window.scrollBy(dx, dy);
  }
  updateTransform() {
    this.scale = Math.max(1, Math.min(4, this.scale));
    const boardRect = this.view.getBoardContainer().getBoundingClientRect();
    const maxPanX = (this.scale * boardRect.width - boardRect.width) / this.scale;
    const maxPanY = (this.scale * boardRect.height - boardRect.height) / this.scale;
    const oldPanX = this.panX;
    const oldPanY = this.panY;
    this.panX = Math.max(-maxPanX, Math.min(0, this.panX));
    this.panY = Math.max(-maxPanY, Math.min(0, this.panY));
    this.view.setBoardTransform(this.scale, this.panX, this.panY);
    return {
      overshootX: oldPanX - this.panX,
      overshootY: oldPanY - this.panY
    };
  }
  pointerCancel(evt) {
    const info = this.pointerInfoMap.get(evt.pointerId);
    if (info)
      console.debug(`Pointer cancel: ${evt.pointerId} (${info.x.toFixed(2)},${info.y.toFixed(2)})`);
    this.pointerInfoMap.delete(evt.pointerId);
    this.view.clearDropTarget(evt.pointerId);
  }
  pointerDown(evt) {
    if (evt.button !== 0)
      return;
    const target = evt.target;
    const tapInfo = {
      downX: evt.clientX,
      downY: evt.clientY,
      x: evt.clientX,
      y: evt.clientY,
      pointerMoved: false
    };
    const tileTarget = target.closest(".tile, .placed");
    if (tileTarget instanceof HTMLElement) {
      evt.preventDefault();
      evt.stopPropagation();
      const col = parseInt(tileTarget.dataset.col, 10);
      const rowStr = tileTarget.dataset.row;
      const row = rowStr === "rack" ? "rack" : rowStr === "exchange" ? "exchange" : parseInt(rowStr, 10);
      const dragInfo = {
        ...tapInfo,
        draggingTile: { row, col, element: tileTarget },
        ghostTile: null
      };
      this.pointerInfoMap.set(evt.pointerId, dragInfo);
    } else if (target.closest("#board-container")) {
      evt.preventDefault();
      evt.stopPropagation();
      const panInfo = {
        ...tapInfo,
        draggingTile: null
      };
      this.pointerInfoMap.set(evt.pointerId, panInfo);
    }
  }
  pointerMove(evt) {
    const info = this.pointerInfoMap.get(evt.pointerId);
    if (!info)
      return;
    evt.preventDefault();
    if (!info.pointerMoved && Math.hypot(evt.clientX - info.downX, evt.clientY - info.downY) > 5) {
      info.pointerMoved = true;
    }
    if (!info.draggingTile) {
      const panningPointerInfos = [...this.pointerInfoMap.values().filter((anyInfo) => !anyInfo.draggingTile)];
      const panningPointerCount = panningPointerInfos.length;
      const midpointBefore = panningPointerInfos.reduce((sum, curr) => {
        return {
          x: sum.x + curr.x / panningPointerCount,
          y: sum.y + curr.y / panningPointerCount
        };
      }, { x: 0, y: 0 });
      const getMaxDistance = (midpoint, points) => {
        return Math.max(...points.map((p) => Math.hypot(midpoint.x - p.x, midpoint.y - p.y)));
      };
      const maxDistanceBefore = getMaxDistance(midpointBefore, panningPointerInfos);
      const midpointAfter = {
        x: midpointBefore.x + (evt.clientX - info.x) / panningPointerCount,
        y: midpointBefore.y + (evt.clientY - info.y) / panningPointerCount
      };
      const pointsAfter = [
        { x: evt.clientX, y: evt.clientY },
        ...panningPointerInfos.filter((anyInfo) => anyInfo !== info)
      ];
      const maxDistanceAfter = getMaxDistance(midpointAfter, pointsAfter);
      if (maxDistanceBefore > 0 && maxDistanceAfter > 0) {
        const multiplier = maxDistanceAfter / maxDistanceBefore;
        const boardRect = this.view.getBoardContainer().getBoundingClientRect();
        const boardX = midpointBefore.x - boardRect.left;
        const boardY = midpointBefore.y - boardRect.top;
        this.panX -= boardX * (multiplier - 1) / this.scale;
        this.panY -= boardY * (multiplier - 1) / this.scale;
        this.scale *= multiplier;
      }
      this.panX += (midpointAfter.x - midpointBefore.x) / this.scale;
      this.panY += (midpointAfter.y - midpointBefore.y) / this.scale;
      const { overshootX, overshootY } = this.updateTransform();
      if (panningPointerCount === 1) {
        this.scrollWindowBy(-overshootX * this.scale, -overshootY * this.scale);
      }
    } else if (info.draggingTile && info.pointerMoved) {
      if (!info.ghostTile) {
        info.ghostTile = this.view.createGhostTile(info.draggingTile.element);
        info.draggingTile.element.classList.add("dragging");
      }
      info.ghostTile.style.left = `${evt.clientX}px`;
      info.ghostTile.style.top = `${evt.clientY}px`;
      info.ghostTile.style.display = "none";
      const targetElement = document.elementFromPoint(evt.clientX, evt.clientY);
      info.ghostTile.style.display = "";
      if (targetElement) {
        const dropTarget = targetElement.closest(".square, .tile-spot, .tile, .placed");
        if (dropTarget instanceof HTMLElement && dropTarget.dataset.row && dropTarget.dataset.col) {
          const toRowStr = dropTarget.dataset.row;
          const toRow = toRowStr === "rack" ? "rack" : toRowStr === "exchange" ? "exchange" : parseInt(toRowStr, 10);
          const toCol = parseInt(dropTarget.dataset.col, 10);
          this.view.setDropTarget(evt.pointerId, toRow, toCol);
        } else {
          this.view.clearDropTarget(evt.pointerId);
        }
      }
    }
    info.x = evt.clientX;
    info.y = evt.clientY;
  }
  pointerUp(evt) {
    const info = this.pointerInfoMap.get(evt.pointerId);
    if (!info)
      return;
    const target = evt.target;
    if (info.draggingTile && info.ghostTile) {
      const dropTarget = this.view.getDropTarget(evt.pointerId);
      if (dropTarget) {
        try {
          const fromRow = info.draggingTile.row;
          const fromCol = info.draggingTile.col;
          const toRow = dropTarget.row;
          const toCol = dropTarget.col;
          const selectedPlacement = this.gameState.tilesHeld.find((p) => p.row === fromRow && p.col === fromCol);
          if (selectedPlacement?.tile.isBlank && isBoardPlacementRow(toRow)) {
            const letter = prompt("Enter a letter for the blank tile:");
            if (letter && /^[a-zA-Z]$/.test(letter)) {
              this.gameState.moveTile(fromRow, fromCol, toRow, toCol, letter.toUpperCase());
            } else if (letter !== null) {
              alert("Invalid letter. Please enter a single letter.");
            }
          } else {
            this.gameState.moveTile(fromRow, fromCol, toRow, toCol);
          }
        } catch (e) {
          alert(e);
        }
      }
      this.view.removeGhostTile(info.ghostTile);
      info.draggingTile.element.classList.remove("dragging");
    } else if (target.closest("#board-container") && !info.pointerMoved) {
      const now = Date.now();
      if (now - this.lastTap < 300) {
        if (this.scale > 1) {
          this.scale = 1;
          this.panX = 0;
          this.panY = 0;
        } else {
          let toBoardCoordinate = function(evtCoordinate, boardLo, boardHi, squareLength) {
            const boardCoordinate = evtCoordinate - boardLo;
            const boardLength = boardHi - boardLo;
            if (boardCoordinate < squareLength)
              return 0;
            if (boardCoordinate + squareLength > boardLength)
              return boardLength;
            return boardCoordinate;
          };
          this.scale = 1.8;
          const boardRect = this.view.getBoardContainer().getBoundingClientRect();
          const square = target.closest(".square")?.getBoundingClientRect();
          const boardX = toBoardCoordinate(evt.clientX, boardRect.left, boardRect.right, square ? square.right - square.left : 0);
          const boardY = toBoardCoordinate(evt.clientY, boardRect.top, boardRect.bottom, square ? square.bottom - square.top : 0);
          this.panX = boardX * (1 - this.scale) / this.scale;
          this.panY = boardY * (1 - this.scale) / this.scale;
        }
        this.updateTransform();
      }
      this.lastTap = now;
    }
    this.pointerInfoMap.delete(evt.pointerId);
    this.view.clearDropTarget(evt.pointerId);
  }
}

// controller/controller.ts
class Controller {
  gameState;
  view;
  browser;
  keyHandler;
  pointerHandler;
  constructor(gameState, view, browser) {
    this.gameState = gameState;
    this.view = view;
    this.browser = browser;
    this.keyHandler = new KeyHandler(gameState, view);
    this.pointerHandler = new PointerHandler(gameState, view);
    this.attachEventListeners();
  }
  async playWordClick() {
    const { confirmed, copyUrl } = await this.view.showConfirmationDialog("Play Word?", this.browser.hasClipboard());
    if (!confirmed)
      return;
    try {
      await this.gameState.playWord();
      if (copyUrl) {
        const url = new URL(this.browser.getHref());
        url.hash = this.gameState.turnUrlParams.toString();
        await this.browser.writeToClipboard(url.toString());
      }
    } catch (e) {
      alert(e instanceof PlayRejectedError ? e.message : e);
    }
  }
  async passOrExchangeClick() {
    const tileCount = this.gameState.exchangeTilesCount;
    const { confirmed, copyUrl } = await this.view.showConfirmationDialog(tileCount ? `Exchange ${tileCount}?` : "Pass Turn?", this.browser.hasClipboard());
    if (!confirmed)
      return;
    try {
      await this.gameState.passOrExchange();
      if (copyUrl) {
        const url = new URL(this.browser.getHref());
        url.hash = this.gameState.turnUrlParams.toString();
        await this.browser.writeToClipboard(url.toString());
      }
    } catch (e) {
      alert(e);
    }
  }
  attachEventListeners() {
    const doc = this.browser.getDocument();
    const gameContainer = doc.getElementById("game-container");
    gameContainer.addEventListener("pointerdown", this.pointerHandler.pointerDown.bind(this.pointerHandler));
    doc.addEventListener("pointermove", this.pointerHandler.pointerMove.bind(this.pointerHandler));
    doc.addEventListener("pointerup", this.pointerHandler.pointerUp.bind(this.pointerHandler));
    doc.addEventListener("pointercancel", this.pointerHandler.pointerCancel.bind(this.pointerHandler));
    gameContainer.addEventListener("keydown", this.keyHandler.keydown.bind(this.keyHandler));
    doc.getElementById("play-word").addEventListener("click", this.playWordClick.bind(this));
    doc.getElementById("pass-exchange").addEventListener("click", this.passOrExchangeClick.bind(this));
    doc.getElementById("recall-tiles").addEventListener("click", this.recallTilesClick.bind(this));
    doc.getElementById("game-setup").addEventListener("click", this.gameSetupClick.bind(this));
  }
  gameSetupClick() {
    this.view.showSettingsDialog();
  }
  recallTilesClick() {
    this.gameState.recallTiles();
  }
}

// view/i18n.ts
function initI18n(doc) {
  const elements = doc.querySelectorAll("[data-i18n]");
  elements.forEach((element) => {
    const key = element.getAttribute("data-i18n");
    if (key) {
      const translation = t(key);
      if (translation !== key) {
        element.prepend(translation);
      }
    }
  });
}

// browser.ts
class DomBrowser {
  reload() {
    console.log(`Reloading: ${window.location}`);
    window.location.reload();
  }
  getHash() {
    return window.location.hash;
  }
  getSearch() {
    return window.location.search;
  }
  setHash(hash) {
    window.location.hash = hash;
  }
  addHashChangeListener(listener) {
    window.addEventListener("hashchange", listener);
  }
  get localStorage() {
    return localStorage;
  }
  get languages() {
    return navigator.languages;
  }
  getDocument() {
    return document;
  }
  getURLSearchParams(query) {
    return new URLSearchParams(query);
  }
  getRandom() {
    return Math.random();
  }
  getHref() {
    return location.href;
  }
  writeToClipboard(text) {
    return navigator.clipboard.writeText(text);
  }
  hasClipboard() {
    return "clipboard" in navigator;
  }
  addPasteListener(listener) {
    window.addEventListener("paste", (event) => {
      const text = event.clipboardData?.getData("text/plain");
      if (text) {
        listener(text);
      }
    });
  }
  setLocation(url) {
    window.location.href = url;
  }
}

// app.ts
class App {
  browser;
  gameState;
  view;
  controller;
  bufferedLogs = [];
  constructor(browser) {
    this.browser = browser;
  }
  updateUrl() {
    const paramsStr = this.gameState.turnUrlParams.toString();
    if (this.browser.getHash().substr(1) !== paramsStr) {
      this.browser.setHash(paramsStr);
    }
  }
  async init() {
    if (this.browser.getURLSearchParams(this.browser.getSearch()).has("debug")) {
      this.initDebug();
    }
    const handleGameChange = async () => {
      const params = this.browser.getURLSearchParams(this.browser.getHash()?.substring(1) || "");
      const gidParam = params.get("gid");
      const gameId = gidParam ? toGameId(gidParam) : makeGameId();
      if (this.gameState?.gameId === gameId) {
        const hash = this.browser.getHash()?.substring(1);
        const paramsStr = this.gameState.turnUrlParams.toString();
        if (hash !== paramsStr) {
          await this.gameState.applyTurnParams(params);
        }
        return;
      }
      const savedGame = gidParam && this.browser.localStorage.getItem(makeStorageKey(gidParam));
      if (savedGame) {
        console.log(`Loaded ${gameId} from local storage${this.gameState ? "; switching from " + this.gameState.gameId + " to it" : ""}.`);
        this.gameState = GameState.fromJSON(JSON.parse(savedGame).game);
        await loadTranslations(...this.browser.languages);
        initI18n(this.browser.getDocument());
        this.gameState.storage = this.browser.localStorage;
        await this.gameState.applyTurnParams(params);
      } else if (this.gameState) {
        this.browser.reload();
        console.log(`Switched to new game "${gidParam}".`);
        return;
      } else {
        console.log(`Switching to new game "${gidParam}".`);
        if (!params.get("seed"))
          params.set("seed", String(Math.floor(1e6 * this.browser.getRandom())));
        this.gameState = await GameState.fromParams(params);
        await loadTranslations(...this.browser.languages);
        initI18n(this.browser.getDocument());
        this.gameState.storage = this.browser.localStorage;
      }
      this.updateUrl();
      this.view = new View(this.gameState, this.browser);
      this.controller = new Controller(this.gameState, this.view, this.browser);
      if (this.browser.getURLSearchParams(this.browser.getSearch()).has("debug")) {
        this.view.gameSetup.initDebugDisplay(this.bufferedLogs);
        this.bufferedLogs = [];
      }
      this.view.renderBoard();
      this.view.renderRack();
      this.view.renderScores();
      this.view.renderBagTileCount();
      this.view.renderActionButtons();
      this.gameState.addEventListener("tilemove", (evt) => {
        if (evt.detail.fromRow !== undefined && evt.detail.fromCol !== undefined) {
          this.view.renderTileSpot(evt.detail.fromRow, evt.detail.fromCol);
        }
        this.view.renderTileSpot(evt.detail.placement.row, evt.detail.placement.col);
        if (evt.detail.fromRow === "exchange" !== (evt.detail.placement.row === "exchange")) {
          this.view.renderActionButtons();
        }
        this.gameState.save();
      });
      this.gameState.addEventListener("turnchange", () => {
        this.view.renderBoard();
        this.view.renderRack();
        this.view.renderScores();
        this.view.renderBagTileCount();
        this.view.renderActionButtons();
        this.updateUrl();
      });
    };
    this.browser.addHashChangeListener(handleGameChange);
    await handleGameChange();
  }
  initDebug() {
    const app = this;
    for (const level of ["log", "warn", "error", "info"]) {
      const original = console[level];
      console[level] = function(...args) {
        original.apply(console, args);
        const message = args.map(String).join(" ");
        if (app.view?.gameSetup) {
          app.view.gameSetup.addDebugMessage(message);
        } else {
          app.bufferedLogs.push(message);
        }
      };
    }
  }
}
if (typeof window !== "undefined") {
  const app = new App(new DomBrowser);
  app.init();
}
</script></head>
  <body>
    <h1 data-i18n="ui.title"></h1>
    <div id="game-container">
      <div id="center-panel">
        <div id="score-panel"></div>
        <div id="board-container"></div>
      </div>
      <div id="controls-container">
        <div id="bag-tile-count-container"></div>
        <div id="rack-container"></div>
        <div id="exchange-container"></div>
        <div id="buttons-container">
          <button id="play-word" data-i18n="ui.buttons.play_word"></button>
          <button id="pass-exchange">Pass/Exchange</button>
          <button id="recall-tiles" data-i18n="ui.buttons.recall_tiles"></button>
          <button id="game-setup" data-i18n="ui.buttons.game_setup"></button>
        </div>
        <div id="settings-dialog" hidden>
          <div class="content">
            <div class="settings-group">
              <h3 data-i18n="ui.settings.players"></h3>
              <div id="player-list"></div>
              <button id="add-player-button" data-i18n="ui.buttons.add_player"></button>
            </div>
            <div class="settings-group">
              <h3 data-i18n="ui.settings.dictionary"></h3>
              <select id="dictionary-type">
                <option value="permissive" data-i18n="ui.settings.dictionary_options.permissive"></option>
                <option value="freeapi" data-i18n="ui.settings.dictionary_options.freeapi"></option>
                <option value="custom" data-i18n="ui.settings.dictionary_options.custom"></option>
              </select>
              <div id="dictionary-url-container" hidden>
                <label data-i18n="ui.settings.dictionary_url_label"><input type="text" id="dictionary-url" placeholder="URL"></label>
              </div>
            </div>
            <div class="settings-group">
              <h3 data-i18n="ui.settings.bingo_bonus"></h3>
              <input type="number" id="bingo-bonus">
            </div>
            <div class="settings-group">
              <h3 data-i18n="ui.settings.random_seed"></h3>
              <input type="text" id="random-seed">
            </div>
          </div>
          <div class="buttons">
            <button id="start-game-with-settings" data-i18n="ui.buttons.start_game_with_settings"></button>
            <button id="cancel-settings" data-i18n="ui.buttons.cancel_settings"></button>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>

