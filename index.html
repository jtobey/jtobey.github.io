<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
  <style>/* style.css */
#game-container {
  display: flex;
  flex-direction: column;
}

#board-container {
  display: grid;
  grid-template-columns: repeat(15, 40px);
  grid-template-rows: repeat(15, 40px);
  background-color: #ccc;
  border: 1px solid #ccc;
  width: 601px;
  height: 601px;
}

.square {
  box-sizing: border-box;
  position: relative;
  display: flex;
  background-color: #dda;
  border-bottom: 1px solid #ccc;
  border-right: 1px solid #ccc;
  justify-content: center;
  align-items:  center;
  width: 40px;
  height: 40px;
  font-size: 24px;
}

.bonus-text {
  color: #dda;
  font-family: sans-serif;
  font-size: 18px;
}

#controls-container {
  margin-top: 20px;
}

#buttons-container button {
  margin-bottom: 4px;
}

#rack-container, #exchange-container {
  display: flex;
  flex-direction: row;
  gap: 5px;
  margin-bottom: 10px;
}

.tile, .tile-spot {
  box-sizing: border-box;
  cursor: pointer;
  position: relative;
  touch-action: none;
  background-color: #eee;
  border: 1px solid #999;
  width: 40px;
  height: 40px;
  font-size: 24px;
}

.letter {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.value {
  position: absolute;
  font-size: 50%;
  bottom: 2px;
  left: 4px;
}

.tile-spot {
  cursor: default;
  background-color: #dda;
  border-color: #ccc;
}

.tile-spot[data-row="exchange"] {
  display: flex;
  justify-content: center;
  align-items:  center;
}

.tile-spot[data-row="exchange"]:before {
  content: "♻";
  color: #bbb;
  font-size: 28px;
}

.placed {
  touch-action: none;
  background-color: #90ee90b3 !important;
}

.square.dl {
  background-color: #c99;
}

.square.tl {
  background-color: #bbb;
}

.square.dw {
  background-color: #ff3;
}

.square.tw {
  background-color: #f90;
}

.square.center {
  background-color: #6f9;
}

.tile.selected, .placed.selected {
  border: 2px solid #00f !important;
}

.square.selected {
  background-color: #f0f0c0 !important;
}

.drop-target {
  box-shadow: inset 0 0 5px 2px #0000ff80;
}

.tile:focus, .square:focus, .placed:focus {
  outline: 3px solid #333;
}

#center-panel {
  display: flex;
  flex-direction: column;
  align-items:  center;
}

#score-panel, #bag-tile-count-container {
  display: flex;
  flex-direction: row;
  justify-content: center;
  margin-bottom: 10px;
  font-size: 18px;
}

.player-score {
  margin: 0 10px;
}

.current-player {
  font-weight: bold;
}

.ghost-tile {
  position: fixed;
  pointer-events: none;
  z-index: 1000;
  transition: transform .1s ease-out;
  transform: translate(-50%, -50%);
  box-shadow: 0 4px 8px #0003;
}

.tile.dragging, .placed.dragging {
  opacity: .4;
}

@media (min-width: 1024px) {
  #game-container {
    flex-direction: row;
    align-items:  flex-start;
  }

  #controls-container {
    margin-top: 0;
    margin-left: 20px;
  }
}

@media (max-width: 601px) {
  #board-container {
    grid-template-columns: repeat(15, 1fr);
    grid-template-rows: repeat(15, 1fr);
    width: 98vw;
    height: 98vw;
  }

  .square {
    width: auto;
    height: auto;
    font-size: 3.2vw;
  }

  .bonus-text {
    font-size: 2.4vw;
  }
}

dialog {
  border: 1px solid #ccc;
  border-radius: 5px;
  box-shadow: 0 2px 10px #0000001a;
}

#settings-dialog {
  background-color: #f9f9f9;
  border: 1px solid #ccc;
  border-radius: 5px;
  margin-top: 1em;
  padding: 1em;
}

.settings-group {
  margin-bottom: 1em;
}

.player-entry {
  display: flex;
  align-items:  center;
  margin-bottom: .5em;
}

.player-entry input {
  margin-right: .5em;
}

@media (prefers-color-scheme: dark) {
  #settings-dialog {
    color: #eee;
    background-color: #333;
  }
}

dialog::backdrop {
  background-color: #00000080;
}

dialog .buttons {
  display: flex;
  justify-content: flex-end;
  margin-top: 1em;
}

dialog button {
  margin-left: .5em;
}

@media (prefers-color-scheme: dark) {
  body {
    color: #eee;
    background-color: #121212;
  }

  h1 {
    color: #eee;
  }

  #board-container {
    background-color: #111;
    border-color: #444;
  }

  .square {
    background-color: #332;
    border-bottom: 1px solid #444;
    border-right: 1px solid #444;
  }

  .tile, .tile-spot {
    background-color: #444;
    border: 1px solid #777;
  }

  .tile-spot {
    background-color: #332;
    border-color: #444;
  }

  .tile-spot[data-row="exchange"]:before {
    color: #444;
  }

  .placed {
    background-color: #228822b3 !important;
  }

  .square.dl {
    background-color: #533;
  }

  .square.tl {
    background-color: #555;
  }

  .square.dw {
    background-color: #660;
  }

  .square.tw {
    background-color: #840;
  }

  .square.center {
    background-color: #253;
  }

  .tile.selected, .placed.selected {
    border: 2px solid #add8e6 !important;
  }

  .square.selected {
    background-color: #404010 !important;
  }

  .bonus-text {
    color: #332;
  }

  dialog {
    color: #eee;
    background-color: #222;
    border-color: #555;
  }
}
</style><script type="module">// game/validation.ts
function indicesOk(arrayLength, ...indices) {
  for (const index of indices) {
    if (index !== Math.floor(index) || index < 0 || index >= arrayLength)
      return false;
  }
  return true;
}
function checkIndices(arrayLength, ...indices) {
  for (const index of indices) {
    if (!indicesOk(arrayLength, index)) {
      throw new RangeError(`Index ${index} is out of range 0..${arrayLength - 1}.`);
    }
  }
}
function arraysEqual(a1, a2, warnIfNot = true) {
  if (a1.length === a2.length && a1.keys().every((k) => a1[k] === a2[k])) {
    return true;
  }
  if (warnIfNot)
    console.warn(`[${a1}] does not equal [${a2}]`);
  return false;
}
function objectsEqual(o1, o2) {
  const keys = Object.keys(o1).sort();
  if (!arraysEqual(keys, Object.keys(o2).sort(), false))
    return false;
  return keys.every((key) => o1[key] === o2[key]);
}

// game/player.ts
class Player {
  id;
  name;
  constructor({ id, name = `Player ${id}` }) {
    this.id = id;
    this.name = name;
  }
  equals(other) {
    return other instanceof Player && other.id === this.id && other.name === this.name;
  }
  toJSON() {
    return {
      id: this.id,
      name: this.name
    };
  }
  static fromJSON(json) {
    if (!(typeof json === "object" && typeof json.id === "string" && typeof json.name === "string")) {
      throw new TypeError(`Invalid Player serialization: ${JSON.stringify(json)}`);
    }
    return new Player(json);
  }
}

// game/version.ts
var PROTOCOL_VERSION = "0";

// game/settings.ts
function toGameId(gameIdStr) {
  return gameIdStr;
}
function fromGameId(gameId) {
  return gameId;
}
function makeGameId() {
  return `game-${Date.now()}.${Math.floor(1e9 * Math.random())}`;
}
var DEFAULT_PLAYER_LIST = [
  new Player({ id: "1" }),
  new Player({ id: "2" })
];
var DEFAULT_LETTER_COUNTS = {
  A: 9,
  B: 2,
  C: 2,
  D: 4,
  E: 12,
  F: 2,
  G: 2,
  H: 2,
  I: 9,
  J: 1,
  K: 1,
  L: 4,
  M: 2,
  N: 6,
  O: 8,
  P: 2,
  Q: 1,
  R: 6,
  S: 5,
  T: 6,
  U: 4,
  V: 2,
  W: 2,
  X: 1,
  Y: 2,
  Z: 1,
  "": 2
};
var DEFAULT_LETTER_VALUES = {
  A: 1,
  B: 3,
  C: 4,
  D: 2,
  E: 1,
  F: 4,
  G: 3,
  H: 4,
  I: 1,
  J: 9,
  K: 5,
  L: 1,
  M: 3,
  N: 1,
  O: 1,
  P: 3,
  Q: 10,
  R: 1,
  S: 1,
  T: 1,
  U: 2,
  V: 5,
  W: 4,
  X: 8,
  Y: 4,
  Z: 10
};
var DEFAULT_BOARD_LAYOUT = [
  "D..d..T......T.",
  ".D...D...t.t..T",
  "..D.....t...t..",
  "d..D...t.....t.",
  "....D.t...D....",
  ".D...d.d.....t.",
  "T...d...d...t..",
  "...d.t...d.t...",
  "..d...t...t...T",
  ".d.....t.t...D.",
  "....D...d.D....",
  ".d.....d...D..d",
  "..d...d.....D..",
  "T..d.d...D...D.",
  ".T......T..d..D"
];
var DEFAULT_BINGO_BONUS = 42;
var DEFAULT_RACK_CAPACITY = 7;

class Settings {
  gameId;
  version = PROTOCOL_VERSION;
  players = DEFAULT_PLAYER_LIST.map((p) => new Player(p));
  maxPlayerNameLength = 50;
  letterCounts = DEFAULT_LETTER_COUNTS;
  letterValues = DEFAULT_LETTER_VALUES;
  boardLayout = DEFAULT_BOARD_LAYOUT;
  bingoBonus = DEFAULT_BINGO_BONUS;
  rackCapacity = DEFAULT_RACK_CAPACITY;
  tileSystemType = "honor";
  tileSystemSettings = { seed: "1" };
  dictionaryType = "permissive";
  dictionarySettings = null;
  toJSON() {
    return {
      version: this.version,
      players: this.players.map((p) => p.toJSON()),
      letterCounts: this.letterCounts,
      letterValues: this.letterValues,
      boardLayout: this.boardLayout,
      bingoBonus: this.bingoBonus,
      rackCapacity: this.rackCapacity,
      tileSystemType: this.tileSystemType,
      tileSystemSettings: this.tileSystemSettings,
      dictionaryType: this.dictionaryType,
      dictionarySettings: this.dictionarySettings
    };
  }
  static fromJSON(json) {
    if (!(typeof json === "object" && arraysEqual([...Object.keys(json)], [
      "version",
      "players",
      "letterCounts",
      "letterValues",
      "boardLayout",
      "bingoBonus",
      "rackCapacity",
      "tileSystemType",
      "tileSystemSettings",
      "dictionaryType",
      "dictionarySettings"
    ]) && json.version === PROTOCOL_VERSION && Array.isArray(json.players) && Array.isArray(json.boardLayout) && json.boardLayout.every((s) => typeof s === "string") && typeof json.bingoBonus === "number" && typeof json.rackCapacity === "number" && json.tileSystemType === "honor" && typeof json.tileSystemSettings === "object" && typeof json.tileSystemSettings.seed === "string" && ["permissive", "freeapi", "custom"].includes(json.dictionaryType))) {
      throw new TypeError(`Invalid Settings serialization: ${JSON.stringify(json)}`);
    }
    const settings = new Settings;
    settings.version = json.version;
    settings.players = json.players.map(Player.fromJSON);
    settings.letterCounts = checkLetterToNumberMap("letterCounts", json.letterCounts);
    settings.letterValues = checkLetterToNumberMap("letterValues", json.letterValues);
    settings.boardLayout = json.boardLayout;
    settings.bingoBonus = json.bingoBonus;
    settings.rackCapacity = json.rackCapacity;
    settings.tileSystemType = json.tileSystemType;
    settings.tileSystemSettings = json.tileSystemSettings;
    settings.dictionaryType = json.dictionaryType;
    settings.dictionarySettings = json.dictionarySettings;
    return settings;
  }
}
function checkLetterToNumberMap(name, json) {
  if (!(typeof json === "object" && Object.keys(json).every((k) => typeof k === "string") && Object.values(json).every((v) => typeof v === "number"))) {
    throw new TypeError(`Invalid Settings.${name} serialization: ${JSON.stringify(json)}`);
  }
  return json;
}

// game/tiles_state.ts
function checkIndicesForExchange(length, ...indices) {
  if ([...new Set(indices)].length !== indices.length) {
    throw new Error(`exchangeTileIndices contains duplicates: ${indices}`);
  }
  checkIndices(length, ...indices);
  return [...indices];
}

// game/turn.ts
function toTurnNumber(n) {
  return n;
}
function fromTurnNumber(turnNumber) {
  return turnNumber;
}
function nextTurnNumber(turnNumber) {
  return toTurnNumber(1 + fromTurnNumber(turnNumber));
}

class Turn {
  playerId;
  turnNumber;
  move;
  mainWord;
  row;
  col;
  vertical;
  blanks;
  extraParams;
  constructor(playerId, turnNumber, move) {
    this.playerId = playerId;
    this.turnNumber = turnNumber;
    this.move = move;
    if ("playTiles" in move && "exchangeTileIndices" in move) {
      throw new Error(`Can't exchange and play tiles on the same turn. Turn number is ${turnNumber}.`);
    }
  }
}
function updateTurnHistory({
  history,
  nextTurnNumber: nextTurnNumber2,
  finalTurnNumber,
  turns
}) {
  let wroteHistory = false;
  for (const turn of turns) {
    if (fromTurnNumber(turn.turnNumber) >= nextTurnNumber2) {
      break;
    }
    if (history.length && fromTurnNumber(turn.turnNumber) <= fromTurnNumber(history.slice(-1)[0].turnNumber)) {
      continue;
    }
    const params = new URLSearchParams;
    const addExtra = () => {
      if (turn.extraParams) {
        for (const [key, value] of turn.extraParams) {
          params.set(key, value);
        }
      }
    };
    if ("playTiles" in turn.move) {
      params.set("wl", `${turn.row}.${turn.col}`);
      addExtra();
      if (turn.blanks?.length)
        params.set("bt", turn.blanks.join("."));
      params.set(turn.vertical ? "wv" : "wh", turn.mainWord);
    } else if ("exchangeTileIndices" in turn.move) {
      params.set("ex", turn.move.exchangeTileIndices.join("."));
      addExtra();
    }
    history.push({ turnNumber: turn.turnNumber, paramsStr: String(params) });
    wroteHistory = true;
    if (turn.turnNumber === finalTurnNumber) {
      return { wroteHistory };
    }
  }
  return { wroteHistory };
}

// game/tile.ts
var MIN_TILE_VALUE = 0;
var MAX_TILE_VALUE = 999999;

class Tile {
  letter;
  value;
  constructor({ letter, value }) {
    if (value !== Math.floor(value) || value < MIN_TILE_VALUE || value > MAX_TILE_VALUE) {
      throw new RangeError(`Invalid Tile value: ${value}`);
    }
    this.letter = letter;
    this.value = value;
  }
  get isBlank() {
    return this.letter === "";
  }
  equals(other) {
    return this.letter === other.letter && this.value === other.value;
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    return `${this.letter}:${this.value}`;
  }
  static fromJSON(json) {
    if (typeof json === "string") {
      const match = json.match(/(.*):([0-9]+)$/s);
      if (match) {
        const letter = match[1];
        const value = parseInt(match[2]);
        return new Tile({ letter, value });
      }
    }
    throw new TypeError(`invalid Tile serialization: ${JSON.stringify(json)}`);
  }
}
function isBoardPlacementRow(row) {
  return typeof row === "number";
}
function isBoardPlacement(tilePlacement) {
  return isBoardPlacementRow(tilePlacement.row);
}
function makeTiles({ letterCounts, letterValues }) {
  const tiles = [];
  const countsEntries = letterCounts instanceof Map ? letterCounts.entries() : Object.entries(letterCounts);
  if (!(letterValues instanceof Map))
    letterValues = new Map(Object.entries(letterValues));
  for (const [letter, count] of countsEntries) {
    tiles.push(...Array(count).fill(new Tile({ letter, value: letterValues.get(letter) || 0 })));
  }
  return tiles;
}

// game/serializable.ts
function toJSON(s) {
  if (s && typeof s === "object" && "toJSON" in s)
    return s.toJSON();
  return s;
}

// game/bag.ts
class Bag {
  randomGenerator;
  tiles;
  constructor([...tiles], randomGenerator, shuffle = true) {
    this.randomGenerator = randomGenerator;
    this.tiles = tiles;
    if (shuffle)
      this.shuffle(0);
  }
  get size() {
    return this.tiles.length;
  }
  draw(numberOfTiles) {
    this.checkEnoughTiles(numberOfTiles);
    return this.tiles.splice(-numberOfTiles);
  }
  exchange(tilesToExchange) {
    const numberOfTiles = tilesToExchange.length;
    this.checkEnoughTiles(numberOfTiles);
    const drawnTiles = this.tiles.splice(-numberOfTiles, numberOfTiles, ...tilesToExchange);
    this.shuffle(this.size - numberOfTiles);
    return drawnTiles;
  }
  checkEnoughTiles(numberOfTilesNeeded) {
    if (numberOfTilesNeeded > this.size) {
      throw new RangeError(`Not enough tiles in bag: ${this.size} < ${numberOfTilesNeeded}`);
    }
  }
  shuffle(indexOfFirstNewTile) {
    for (let i = Math.max(1, indexOfFirstNewTile);i <= this.size; ++i) {
      const j = Math.floor(this.randomGenerator.random() * i);
      [this.tiles[i - 1], this.tiles[j]] = [this.tiles[j], this.tiles[i - 1]];
    }
  }
  toJSON() {
    return {
      tiles: this.tiles.map(toJSON),
      prng: this.randomGenerator.toJSON()
    };
  }
}

// game/mulberry32_prng.ts
class Mulberry32Prng {
  seed;
  constructor(seed) {
    this.seed = Number(BigInt(seed) & 0xFFFFFFFFn);
  }
  random() {
    this.seed = this.seed + 1831565813 >>> 0;
    let t = this.seed;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  toJSON() {
    return this.seed;
  }
  static fromJSON(json) {
    if (typeof json !== "number") {
      throw new TypeError(`Invalid serialized Mulberry32Prng: ${JSON.stringify(json)}`);
    }
    return new Mulberry32Prng(json);
  }
}

// game/honor_system_bag.ts
class HonorSystemBag extends Bag {
  constructor(randomSeed, tiles, shuffle = true, randomGenerator = new Mulberry32Prng(BigInt(randomSeed))) {
    super(tiles, randomGenerator, shuffle);
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in HonorSystemBag serialization: ${JSON.stringify(json)}`);
    }
    if (typeof json !== "object")
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], ["tiles", "prng"]))
      fail("Wrong keys or key order");
    if (!Array.isArray(json.tiles))
      fail("Tiles are not an array.");
    return new HonorSystemBag("", json.tiles.map(Tile.fromJSON), false, Mulberry32Prng.fromJSON(json.prng));
  }
}

// game/events.ts
class BagEvent extends CustomEvent {
}

class TileEvent extends CustomEvent {
}

class GameEvent extends CustomEvent {
}

class BoardEvent extends CustomEvent {
}

// game/honor_system_tiles_state.ts
class HonorSystemTilesState extends EventTarget {
  rackCapacity;
  numberOfTurnsPlayed;
  racks;
  bag;
  isGameOver;
  constructor(players, tileSystemSettings, tiles, rackCapacity, numberOfTurnsPlayed = 0, racks = new Map(players.map((player) => [player.id, []])), bag = new HonorSystemBag(tileSystemSettings.seed, tiles), isGameOver = false, init = true) {
    super();
    this.rackCapacity = rackCapacity;
    this.numberOfTurnsPlayed = numberOfTurnsPlayed;
    this.racks = racks;
    this.bag = bag;
    this.isGameOver = isGameOver;
    if (this.racks.size < players.length) {
      throw new Error(`The player IDs are not unique: ${players.map((player) => player.id)}`);
    }
    if (init)
      this.initRacks();
  }
  get numberOfTilesInBag() {
    return this.bag.size;
  }
  get stateId() {
    return this.numberOfTurnsPlayed;
  }
  countTiles(playerId) {
    return this.getRack(playerId).length;
  }
  getTiles(playerId) {
    return Promise.resolve([...this.getRack(playerId)]);
  }
  playTurns(...turnsToPlay) {
    for (const turn of turnsToPlay) {
      if (this.isGameOver)
        return Promise.resolve(toTurnNumber(this.numberOfTurnsPlayed));
      this.playOneTurn(turn);
    }
    return Promise.resolve(null);
  }
  playOneTurn(turn) {
    const rack = this.getRack(turn.playerId);
    const rackCopy = [...rack];
    if ("playTiles" in turn.move) {
      for (const tileToPlay of turn.move.playTiles) {
        const index = rackCopy.findIndex((rackTile) => rackTile.equals(tileToPlay.tile));
        if (index === -1) {
          throw new Error(`Player ${turn.playerId} does not hold tile ${tileToPlay.tile.toString()}`);
        }
        rackCopy.splice(index, 1);
      }
      const numberOfTilesToDraw = Math.min(rack.length - rackCopy.length, this.bag.size);
      const drawnTiles = this.bag.draw(numberOfTilesToDraw);
      for (const tile of drawnTiles) {
        this.dispatchEvent(new BagEvent("tiledraw", { detail: { playerId: turn.playerId, tile } }));
      }
      rackCopy.push(...drawnTiles);
      if (rackCopy.length === 0)
        this.isGameOver = true;
    } else if ("exchangeTileIndices" in turn.move) {
      const indicesOfTilesToExchange = checkIndicesForExchange(rackCopy.length, ...turn.move.exchangeTileIndices);
      indicesOfTilesToExchange.sort((a, b) => b - a);
      const tilesToExchange = [];
      for (const indexOfTileToExchange of indicesOfTilesToExchange) {
        tilesToExchange.push(...rackCopy.splice(indexOfTileToExchange, 1));
      }
      const newTiles = this.bag.exchange(tilesToExchange);
      for (const tile of tilesToExchange) {
        this.dispatchEvent(new BagEvent("tilereturn", { detail: { playerId: turn.playerId, tile } }));
      }
      for (const tile of newTiles) {
        this.dispatchEvent(new BagEvent("tiledraw", { detail: { playerId: turn.playerId, tile } }));
      }
      rackCopy.push(...newTiles);
    }
    rack.splice(0, rack.length, ...rackCopy);
    this.numberOfTurnsPlayed += 1;
  }
  getRack(playerId) {
    const rack = this.racks.get(playerId);
    if (rack === undefined) {
      throw new Error(`Unknown playerId: ${playerId}`);
    }
    return rack;
  }
  initRacks() {
    for (const [playerId, rack] of this.racks.entries()) {
      const drawnTiles = this.bag.draw(this.rackCapacity);
      for (const tile of drawnTiles) {
        this.dispatchEvent(new BagEvent("tiledraw", { detail: { playerId, tile } }));
      }
      rack.push(...drawnTiles);
    }
  }
  toJSON() {
    const racks = [...this.racks.entries().map(([playerId, rack]) => [playerId, rack.map((tile) => tile.toJSON())])];
    return {
      rackCapacity: this.rackCapacity,
      numberOfTurnsPlayed: this.numberOfTurnsPlayed,
      bag: this.bag.toJSON(),
      racks
    };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in HonorSystemTileState serialization: ${JSON.stringify(json)}`);
    }
    if (!(typeof json === "object"))
      fail("Not an object");
    if (typeof json.rackCapacity !== "number")
      fail("rackCapacity is not a number");
    if (typeof json.numberOfTurnsPlayed !== "number")
      fail("numberOfTurnsPlayed is not a number");
    if (!Array.isArray(json.racks))
      fail("Racks are not in an array.");
    const bag = HonorSystemBag.fromJSON(json.bag);
    const racks = new Map;
    let isGameOver = false;
    for (const racksEntry of json.racks) {
      if (!Array.isArray(racksEntry))
        fail("Rack list entry is not an array");
      if (racksEntry.length !== 2)
        fail("Rack list entry length is not 2");
      const [playerId, rackJson] = racksEntry;
      if (typeof playerId !== "string")
        fail("Rack list playerId is not a string");
      if (!Array.isArray(rackJson))
        fail("Rack is not an array");
      if (rackJson.length > json.rackCapacity)
        fail("Rack length is over capacity");
      if (rackJson.length === 0)
        isGameOver = true;
      racks.set(playerId, rackJson.map(Tile.fromJSON));
    }
    return new HonorSystemTilesState([], { seed: "" }, [], json.rackCapacity, json.numberOfTurnsPlayed, racks, bag, isGameOver, false);
  }
}

// game/board.ts
class Square {
  row;
  col;
  letterBonus;
  wordBonus;
  tile;
  assignedLetter;
  constructor({ row, col, letterBonus, wordBonus }) {
    this.row = row;
    this.col = col;
    this.letterBonus = letterBonus;
    this.wordBonus = wordBonus;
  }
  get letter() {
    return this.assignedLetter || this.tile?.letter;
  }
  get value() {
    return this.tile?.value;
  }
}
var CHAR_TO_BONUS = new Map([
  [".", [1, 1]],
  ["d", [2, 1]],
  ["t", [3, 1]],
  ["D", [1, 2]],
  ["T", [1, 3]]
]);

class InvalidBonusSquareLayout extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidBonusSquareLayout";
  }
}
function parseRowStrings(rowStrings) {
  const firstRowString = rowStrings[0];
  if (!firstRowString || !rowStrings.every((s) => s.length === firstRowString.length)) {
    throw new InvalidBonusSquareLayout(`Row strings do not form a rectangle: ${rowStrings.join(`
`)}.`);
  }
  return rowStrings.map((rowString, row) => rowString.split("").map((character, col) => {
    const bonus = CHAR_TO_BONUS.get(character);
    if (!bonus)
      throw new InvalidBonusSquareLayout(`Unrecognized square type: ${character}`);
    const [letterBonus, wordBonus] = bonus;
    return new Square({ row, col, letterBonus, wordBonus });
  }));
}
function generateRowStrings(squares) {
  return squares.map((row) => row.map((square) => {
    const pair = [square.letterBonus, square.wordBonus];
    const entry = CHAR_TO_BONUS.entries().find(([char, bonus]) => bonus[0] === pair[0] && bonus[1] === pair[1]);
    if (entry === undefined)
      throw new Error(`Unrecognized bonus multiplier pair: ${pair}`);
    return entry[0];
  }).join(""));
}

class WordPlacementError extends Error {
  constructor(message) {
    super(message);
    this.name = "WordPlacementError";
  }
}

class Board extends EventTarget {
  squares;
  scores = new Map;
  centerSquare;
  constructor(...rowStrings) {
    super();
    this.squares = parseRowStrings(rowStrings);
    const centerRow = this.squares[this.squares.length >> 1];
    const centerSquare = centerRow?.[centerRow.length >> 1];
    if (!centerSquare)
      throw new Error(`Board lacks a center square: ${rowStrings}`);
    this.centerSquare = centerSquare;
  }
  checkWordPlacement(...placements) {
    const anyPlacement = placements[0];
    if (!anyPlacement)
      throw new WordPlacementError("No tiles.");
    for (const placement of placements) {
      if (placement.tile.isBlank && !placement.assignedLetter) {
        throw new WordPlacementError("Blank tiles must be assigned letters.");
      }
      if (!placement.tile.isBlank && placement.assignedLetter) {
        throw new WordPlacementError("Non-blank tiles cannot be assigned letters.");
      }
    }
    const mainDir = { x: 0, y: 0 };
    const tilesInOneRow = placements.every((tile) => tile.row === anyPlacement.row);
    if (tilesInOneRow && (placements.length > 1 || this.squares[anyPlacement.row]?.[anyPlacement.col - 1]?.tile || this.squares[anyPlacement.row]?.[anyPlacement.col + 1]?.tile)) {
      mainDir.x = 1;
      placements.sort((a, b) => a.col - b.col);
    } else if (placements.every((tile) => tile.col === anyPlacement.col)) {
      mainDir.y = 1;
      placements.sort((a, b) => a.row - b.row);
    } else {
      throw new WordPlacementError("Tiles are not in a line.");
    }
    const crossDir = { x: mainDir.y, y: mainDir.x };
    const firstPlacement = placements[0];
    if (!firstPlacement)
      throw new Error("Lost a tile.");
    let { row: mainRow, col: mainCol } = firstPlacement;
    while (this.squares[mainRow - mainDir.y]?.[mainCol - mainDir.x]?.tile) {
      mainRow -= mainDir.y;
      mainCol -= mainDir.x;
    }
    const mainStartRow = mainRow;
    const mainStartCol = mainCol;
    let mainWord = "", crossWords = [], blanks = [];
    let placementIndex = 0;
    let mainWordMultiplier = 1, mainWordScore = 0, crossWordsScore = 0;
    while (true) {
      const mainSquare = this.squares[mainRow]?.[mainCol];
      if (!mainSquare)
        break;
      let mainLetter, mainValue, wordMultiplier;
      const placement = placements[placementIndex];
      if (placement && placement.row === mainRow && placement.col === mainCol) {
        if (mainSquare.tile) {
          throw new WordPlacementError(`Square ${mainRow},${mainCol} is occupied.`);
        }
        placementIndex += 1;
        if (placement.assignedLetter) {
          blanks.push(mainWord.length);
          mainLetter = placement.assignedLetter;
        } else {
          mainLetter = placement.tile.letter;
        }
        mainValue = mainSquare.letterBonus * placement.tile.value;
        wordMultiplier = mainSquare.wordBonus;
        mainWordMultiplier *= wordMultiplier;
        let crossRow = mainRow, crossCol = mainCol;
        while (this.squares[crossRow - crossDir.y]?.[crossCol - crossDir.x]?.tile) {
          crossRow -= crossDir.y;
          crossCol -= crossDir.x;
        }
        let crossWord = "", crossWordScore = 0;
        while (true) {
          const crossSquare = this.squares[crossRow]?.[crossCol];
          if (crossRow === mainRow && crossCol === mainCol) {
            crossWord += mainLetter;
            crossWordScore += mainValue;
          } else if (crossSquare?.tile) {
            crossWord += crossSquare.letter;
            crossWordScore += crossSquare.tile.value;
          } else {
            break;
          }
          crossRow += crossDir.y;
          crossCol += crossDir.x;
        }
        if (crossWord.length > 1) {
          crossWords.push(crossWord);
          crossWordsScore += crossWordScore * wordMultiplier;
        }
      } else if (mainSquare.tile) {
        mainLetter = mainSquare.assignedLetter || mainSquare.tile.letter;
        mainValue = mainSquare.tile.value;
        wordMultiplier = 1;
      } else {
        break;
      }
      mainWord += mainLetter;
      mainWordScore += mainValue;
      mainRow += mainDir.y;
      mainCol += mainDir.x;
    }
    mainWordScore *= mainWordMultiplier;
    if (placementIndex < placements.length) {
      throw new WordPlacementError("Tiles form a line with gaps between them.");
    }
    if (mainWord.length === 1) {
      throw new WordPlacementError("No single-letter words accepted.");
    }
    if (!crossWords.length && mainWord.length === placements.length) {
      if (!placements.some((tile) => tile.row === this.centerSquare.row && tile.col === this.centerSquare.col)) {
        throw new WordPlacementError("Tiles must connect to existing words or cover the center square.");
      }
    }
    return {
      wordsFormed: [mainWord, ...crossWords],
      score: mainWordScore + crossWordsScore,
      mainWord,
      row: mainStartRow,
      col: mainStartCol,
      vertical: Boolean(mainDir.y),
      blanks
    };
  }
  placeTiles(...tiles) {
    for (const tile of tiles) {
      const square = this.squares[tile.row]?.[tile.col];
      if (!square)
        throw new Error(`Invalid board coordinates: ${tile.row},${tile.col}.`);
      if (square.tile)
        throw new Error(`Square ${tile.row}, ${tile.col} is occupied.`);
    }
    for (const tile of tiles) {
      const square = this.squares[tile.row]?.[tile.col];
      if (square) {
        square.tile = tile.tile;
        square.assignedLetter = tile.assignedLetter;
        this.dispatchEvent(new BoardEvent("tileplaced", { detail: { placement: tile } }));
      }
    }
  }
  toJSON() {
    const rows = generateRowStrings(this.squares);
    const tiles = [];
    this.squares.forEach((row) => row.forEach((square) => {
      if (square.tile) {
        const result = [square.row, square.col, square.tile.toJSON()];
        if (square.assignedLetter)
          result.push(square.assignedLetter);
        tiles.push(result);
      }
    }));
    const scores = [...this.scores.entries()];
    return { rows, tiles, scores };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in Board serialization: ${JSON.stringify(json)}`);
    }
    if (!(typeof json === "object"))
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], ["rows", "tiles", "scores"]))
      fail("Wrong keys or key order");
    if (!Array.isArray(json.rows))
      fail("Rows are not an array");
    if (!json.rows.every((row) => typeof row === "string"))
      fail("Row element is not a string");
    if (!Array.isArray(json.tiles))
      fail("Tiles are not an array");
    if (!Array.isArray(json.scores))
      fail("Scores are not an array");
    try {
      const board = new Board(...json.rows);
      for (const tile of json.tiles) {
        if (!Array.isArray(tile))
          fail("Tile is not an array");
        if (tile.length > 4)
          fail("Wrong size array for tile");
        const [row, col, tileJson, assignedLetter] = tile;
        if (!(typeof row === "number"))
          fail("Tile row is not a number");
        if (!(typeof col === "number"))
          fail("Tile col is not a number");
        const square = board.squares[row]?.[col];
        if (!square)
          fail("Tile coordinates are off the board");
        square.tile = Tile.fromJSON(tileJson);
        if (assignedLetter)
          square.assignedLetter = assignedLetter;
      }
      for (const element of json.scores) {
        if (!Array.isArray(element))
          fail("Score is not an array");
        if (element.length !== 2)
          fail("Wrong size array for score");
        const [playerId, score] = element;
        if (!(typeof playerId === "string"))
          fail("Player ID is not a string");
        if (!(typeof score === "number"))
          fail("Score is not a number");
        if (board.scores.has(playerId))
          fail("Duplicate Player ID in scores array");
        board.scores.set(playerId, score);
      }
      return board;
    } catch (e) {
      if (e instanceof InvalidBonusSquareLayout)
        fail("Invalid board layout");
      throw e;
    }
  }
}

// game/dictionary.ts
var DICTIONARY_TYPES = ["permissive", "freeapi", "custom"];

class PlayRejectedError extends Error {
  constructor(message) {
    super(`${message} Play rejected.`);
    this.name = "PlayRejected";
  }
}
function makeDictionary(dictionaryType, dictionarySettings) {
  if (!DICTIONARY_TYPES.includes(dictionaryType)) {
    throw new Error(`dictionaryType ${dictionaryType} is not supported.`);
  }
  return async (...words) => {
    const promises = words.map((word) => {
      return checkWord(word, dictionaryType, dictionarySettings);
    });
    const results = await Promise.all(promises);
    const errors = results.filter((r) => r);
    if (errors.length === 0)
      return;
    if (errors.length === 1)
      throw errors[0];
    const invalidWords = errors.map((wnidError) => wnidError.word);
    throw new PlayRejectedError(`Not words in ${errors[0].dictionaryName}: ${invalidWords}.`);
  };
}

class WordNotInDictionaryError extends PlayRejectedError {
  word;
  dictionaryName;
  status;
  constructor(word, dictionaryName, status) {
    super(`Word "${word}" ${status} in ${dictionaryName}.`);
    this.word = word;
    this.dictionaryName = dictionaryName;
    this.status = status;
    this.name = "WordNotInDictionaryError";
  }
}

class WordNotFoundError extends WordNotInDictionaryError {
  constructor(word, dictionaryName) {
    super(word, dictionaryName, "not found");
    this.name = "WordNotFoundError";
  }
}

class NoDefinitionError extends WordNotInDictionaryError {
  constructor(word, dictionaryName) {
    super(word, dictionaryName, "has no definition");
    this.name = "NoDefinitionError";
  }
}
async function checkWord(wordToCheck, dictionaryType, dictionarySettings) {
  if (dictionaryType === "permissive")
    return null;
  let urlPrefix = "";
  let dictionaryNameForAlert = "";
  if (dictionaryType === "freeapi") {
    urlPrefix = "https://api.dictionaryapi.dev/api/v2/entries/en/";
    dictionaryNameForAlert = "Free Dictionary API";
  } else if (dictionaryType === "custom") {
    dictionaryNameForAlert = "Custom Dictionary";
  }
  if (typeof dictionarySettings === "string") {
    urlPrefix = dictionarySettings;
  }
  if (!urlPrefix) {
    throw new Error("Custom dictionary requires setting a URL prefix.");
  }
  const url = urlPrefix + wordToCheck.toLowerCase();
  try {
    const response = await fetch(url);
    if (!response.ok) {
      if (response.status === 404) {
        return new WordNotFoundError(wordToCheck, dictionaryNameForAlert);
      } else {
        throw new Error(`Error validating word "${wordToCheck}" with ${dictionaryNameForAlert} (Status: ${response.status} ${response.statusText}).`);
      }
    }
    if (dictionaryType === "freeapi") {
      const data = await response.json();
      if (!Array.isArray(data) || data.length === 0 || data[0] && data[0].title === "No Definitions Found") {
        return new NoDefinitionError(wordToCheck, dictionaryNameForAlert);
      }
    }
    console.log(`Word "${wordToCheck}" is valid according to ${dictionaryNameForAlert}.`);
    return null;
  } catch (error) {
    console.error(`Network or other error validating word "${wordToCheck}":`, error);
    throw new Error(`Could not reach ${dictionaryNameForAlert} to validate "${wordToCheck}". Check connection or API status.`);
  }
}

// game/shared_state.ts
class SharedState {
  settings;
  gameId;
  board;
  tilesState;
  nextTurnNumber;
  checkWords;
  constructor(settings, gameId = settings.gameId ?? makeGameId(), board = new Board(...settings.boardLayout), tilesState = makeTilesState(settings), nextTurnNumber2 = toTurnNumber(1), checkWords = makeDictionary(settings.dictionaryType, settings.dictionarySettings)) {
    this.settings = settings;
    this.gameId = gameId;
    this.board = board;
    this.tilesState = tilesState;
    this.nextTurnNumber = nextTurnNumber2;
    this.checkWords = checkWords;
    this.settings.players.forEach((player, index) => {
      const expected = String(index + 1);
      if (player.id !== expected) {
        throw new Error(`players[${index}] should have ID "${expected}", not "${player.id}".`);
      }
    });
  }
  get players() {
    return this.settings.players;
  }
  get isGameOver() {
    return this.tilesState.isGameOver;
  }
  async playTurns(...turns) {
    const seen = [];
    for (const turn of turns) {
      if (turn.turnNumber < this.nextTurnNumber) {
        console.log(`Ignoring old turn number ${turn.turnNumber}`);
      } else if (turn.turnNumber in seen) {
        throw new Error(`playTurns received duplicate turn number ${turn.turnNumber}.`);
      } else {
        seen[turn.turnNumber] = turn;
      }
    }
    const turnsToPlayNow = [];
    const boardChanges = [];
    const wordsToCheck = new Set;
    let turnNumber = this.nextTurnNumber;
    for (const turn of seen.filter((t) => t)) {
      if (turn.turnNumber !== turnNumber) {
        console.warn(`Ignoring out-of-order turn number ${turn.turnNumber}; expected ${turnNumber}.`);
        break;
      }
      const playerId = this.players[(fromTurnNumber(turnNumber) - 1) % this.players.length].id;
      if (turn.playerId !== playerId) {
        throw new Error(`Turn number ${turn.turnNumber} belongs to player "${playerId}", not "${turn.playerId}".`);
      }
      if ("playTiles" in turn.move) {
        const { score, wordsFormed, row, col, vertical, blanks } = this.board.checkWordPlacement(...turn.move.playTiles);
        wordsFormed.forEach((w) => wordsToCheck.add(w));
        const bingoBonus = turn.move.playTiles.length === this.tilesState.rackCapacity ? this.settings.bingoBonus : 0;
        boardChanges.push({ playerId, score: score + bingoBonus, placements: turn.move.playTiles });
        turn.mainWord = wordsFormed[0];
        turn.row = row;
        turn.col = col;
        turn.vertical = vertical;
        turn.blanks = blanks;
        console.log(`Player ${playerId} plays ${wordsFormed[0]} for ${score}`);
      } else if ("exchangeTileIndices" in turn.move) {
        checkIndicesForExchange(this.tilesState.countTiles(playerId), ...turn.move.exchangeTileIndices);
        const numAttempted = turn.move.exchangeTileIndices.length;
        const numInBag = this.tilesState.numberOfTilesInBag;
        if (numAttempted > numInBag) {
          throw new Error(`Player ${playerId} attempted to exchange ${numAttempted} but the bag holds only ${numInBag}.`);
        }
        if (numAttempted) {
          console.log(`Player ${playerId} exchanges ${numAttempted} tiles.`);
        } else {
          console.log(`Player ${playerId} passes.`);
        }
      } else {
        throw new Error(`Turn number ${turn.turnNumber} is not a play or exchange.`);
      }
      turnsToPlayNow.push(turn);
      turnNumber = nextTurnNumber(turnNumber);
    }
    if (wordsToCheck.size)
      await this.checkWords(...wordsToCheck);
    if (turnsToPlayNow.length === 0)
      return turnsToPlayNow;
    console.log(`Turn validation success.`);
    for (const { playerId, score, placements } of boardChanges) {
      this.board.placeTiles(...placements);
      this.board.scores.set(playerId, (this.board.scores.get(playerId) ?? 0) + score);
    }
    this.nextTurnNumber = turnNumber;
    return turnsToPlayNow;
  }
  toJSON() {
    return {
      gameId: this.gameId,
      nextTurnNumber: this.nextTurnNumber,
      settings: this.settings.toJSON(),
      board: this.board.toJSON(),
      tilesState: this.tilesState.toJSON()
    };
  }
  static fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in SharedState serialization: ${JSON.stringify(json)}`);
    }
    if (typeof json !== "object")
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], [
      "gameId",
      "nextTurnNumber",
      "settings",
      "board",
      "tilesState"
    ]))
      fail("Wrong keys or key order");
    if (typeof json.gameId !== "string")
      fail("Game ID is not a string");
    if (typeof json.nextTurnNumber !== "number")
      fail("Next turn number is not a number");
    const settings = Settings.fromJSON(json.settings);
    return new SharedState(settings, json.gameId, Board.fromJSON(json.board), rehydrateTilesState(settings.tileSystemType, json.tilesState), toTurnNumber(json.nextTurnNumber));
  }
}
function makeTilesState(settings) {
  if (settings.tileSystemType === "honor") {
    return new HonorSystemTilesState(settings.players, settings.tileSystemSettings, makeTiles(settings), settings.rackCapacity);
  }
  throw new Error(`Unsupported tileSystemType: ${settings.tileSystemType}`);
}
function rehydrateTilesState(tileSystemType, tilesStateJson) {
  if (tileSystemType === "honor")
    return HonorSystemTilesState.fromJSON(tilesStateJson);
  throw new TypeError(`Unknown tileSystemType: ${tileSystemType}`);
}

// game/game_state.ts
class GameState extends EventTarget {
  playerId;
  keepAllHistory;
  tilesHeld;
  history;
  shared;
  pendingExtraParams = new URLSearchParams;
  gameParams;
  constructor(playerId, settings, keepAllHistory = false, shared, tilesHeld = [], history = []) {
    super();
    this.playerId = playerId;
    this.keepAllHistory = keepAllHistory;
    this.tilesHeld = tilesHeld;
    this.history = history;
    if (!shared) {
      if (!settings) {
        throw new Error("New GameState requires either a Settings or a SharedState.");
      }
      shared = new SharedState(settings);
    }
    this.shared = shared;
    this.gameParams = this.getGameParams();
    if (!this.shared.settings.players.some((p) => p.id === playerId)) {
      throw new Error(`Player ID "${playerId}" is not listed in settings.`);
    }
    this.board.addEventListener("tileplaced", (evt) => {
      const { placement } = evt.detail;
      const myTile = this.tilesHeld.find((p) => p.row === placement.row && p.col === placement.col);
      if (myTile && myTile.tile !== placement.tile) {
        console.log(`My tile at ${placement.row},${placement.col} is displaced. Moving it to rack.`);
        this.moveTile(myTile.row, myTile.col, "rack", 0);
      }
    });
    this.tilesState.addEventListener("tiledraw", this.tiledraw.bind(this));
    this.tilesState.addEventListener("tilereturn", this.tilereturn.bind(this));
  }
  async init() {
    const tiles = await this.tilesState.getTiles(this.playerId);
    this.tilesHeld.splice(0, this.tilesHeld.length, ...tiles.map((tile, index) => {
      return {
        tile,
        row: "rack",
        col: index
      };
    }));
    this.tilesHeld.forEach((p) => {
      this.dispatchEvent(new TileEvent("tilemove", { detail: { placement: p } }));
    });
    return this;
  }
  get gameId() {
    return this.shared.gameId;
  }
  get settings() {
    return this.shared.settings;
  }
  get nextTurnNumber() {
    return this.shared.nextTurnNumber;
  }
  get players() {
    return this.shared.players;
  }
  get board() {
    return this.shared.board;
  }
  get tilesState() {
    return this.shared.tilesState;
  }
  get numberOfTilesInBag() {
    return this.tilesState.numberOfTilesInBag;
  }
  get isGameOver() {
    return this.tilesState.isGameOver;
  }
  get exchangeTilesCount() {
    return this.tilesHeld.filter((p) => p.row === "exchange").length;
  }
  async getTiles(playerId) {
    return await this.tilesState.getTiles(playerId);
  }
  get turnUrlParams() {
    const entries = [["gid", fromGameId(this.gameId)]];
    const turnHistory = this.history.slice(1 - this.players.length);
    const firstHistoryTurnNumber = turnHistory[0]?.turnNumber;
    if (firstHistoryTurnNumber === undefined || firstHistoryTurnNumber === toTurnNumber(1)) {
      entries.push(...this.gameParams);
    }
    if (turnHistory.length) {
      entries.push(["tn", String(firstHistoryTurnNumber)]);
      turnHistory.forEach((turnData) => {
        entries.push(...new URLSearchParams(turnData.paramsStr));
      });
    } else {
      entries.push(["tn", "1"]);
    }
    return new URLSearchParams(entries);
  }
  get playerWhoseTurnItIs() {
    if (this.isGameOver)
      return null;
    return this.getPlayerForTurnNumber(this.nextTurnNumber);
  }
  getPlayerForTurnNumber(turnNumber) {
    return this.players[(fromTurnNumber(turnNumber) - 1) % this.players.length];
  }
  tiledraw(evt) {
    if (evt.detail.playerId === this.playerId) {
      const occupiedIndices = new Set(this.tilesHeld.filter((p) => p.row === "rack").map((p) => p.col));
      for (let col = 0;col < this.settings.rackCapacity; ++col) {
        if (!occupiedIndices.has(col)) {
          this.tilesHeld.push({ row: "rack", col, tile: evt.detail.tile });
          return;
        }
      }
      throw new Error(`No room for drawn tile! ${JSON.stringify(this.tilesHeld)}`);
    }
  }
  tilereturn(evt) {
    if (evt.detail.playerId === this.playerId) {
      const index = this.tilesHeld.findIndex((p) => p.row === "exchange" && p.tile.equals(evt.detail.tile));
      if (index === -1) {
        console.error(`Tile not found for exchange: ${JSON.stringify(evt.detail.tile)}`);
      } else {
        this.tilesHeld.splice(index, 1);
      }
    }
  }
  moveTile(fromRow, fromCol, toRow, toCol, assignedLetter) {
    const preparation = this.prepareTileMove(fromRow, fromCol, toRow, toCol);
    if (!preparation.success)
      throw new RangeError(preparation.message);
    for (const pushed of preparation.toPush) {
      const pushedFromCol = pushed.col;
      pushed.col = pushedFromCol + preparation.pushDirection;
      this.dispatchEvent(new TileEvent("tilemove", { detail: { fromRow, fromCol: pushedFromCol, placement: pushed } }));
    }
    preparation.placement.row = preparation.toRow;
    preparation.placement.col = preparation.toCol;
    preparation.placement.assignedLetter = assignedLetter;
    if (!isBoardPlacementRow(preparation.toRow)) {
      delete preparation.placement.assignedLetter;
    }
    this.dispatchEvent(new TileEvent("tilemove", { detail: { fromRow, fromCol, placement: preparation.placement } }));
  }
  prepareTileMove(fromRow, fromCol, toRow, toCol) {
    const placement = this.tilesHeld.find((p) => p.row === fromRow && p.col === fromCol);
    if (placement === undefined)
      return { success: false, message: `No tile at ${fromRow},${fromCol}.` };
    let pushDirection = toRow !== fromRow || toCol < fromCol ? 1 : -1;
    let toPush = [];
    const occupant = fromRow === toRow && fromCol === toCol ? undefined : this.tilesHeld.find((p) => p.row === toRow && p.col === toCol);
    if (toRow === "rack" || toRow === "exchange") {
      const capacity = this.settings.rackCapacity;
      if (!indicesOk(capacity, toCol))
        return { success: false, message: `Invalid toCol: ${toCol}` };
      if (occupant) {
        let tryPush = function() {
          const newToPush2 = [];
          for (let col = toCol;; col += pushDirection) {
            if (col < 0 || col >= capacity)
              return null;
            const rowmate = newRowmates.get(col);
            if (rowmate)
              newToPush2.push(rowmate);
            else
              return newToPush2;
          }
        };
        const newRowmates = new Map(this.tilesHeld.filter((p) => p.row === toRow && !(p.row === fromRow && p.col === fromCol)).map((p) => [p.col, p]));
        if (toRow === fromRow && toCol > fromCol) {
          pushDirection = -1;
        } else {
          pushDirection = 1;
        }
        let newToPush = tryPush();
        if (!newToPush) {
          pushDirection = -pushDirection;
          newToPush = tryPush();
          if (!newToPush)
            return {
              success: false,
              message: `${toRow === "rack" ? "Rack" : "Exchange area"} is full.`
            };
        }
        toPush = newToPush;
      }
    } else {
      const square = this.board.squares[toRow]?.[toCol];
      if (!square)
        return { success: false, message: `Tile destination ${toRow},${toCol} is off the board.` };
      if (occupant || square.tile) {
        for (const [deltaRow, deltaCol] of [[0, 1], [1, 0], [-1, 0], [0, -1]]) {
          const [row, col] = [toRow + deltaRow, toCol + deltaCol];
          const nearbySquare = this.board.squares[row]?.[col];
          if (!nearbySquare)
            continue;
          if (nearbySquare.tile)
            continue;
          if (this.tilesHeld.some((p) => p.row === row && p.col === col))
            continue;
          return { success: true, placement, toRow: row, toCol: col, pushDirection, toPush };
        }
        return { success: false, message: `Square ${toRow},${toCol} is occupied` };
      }
    }
    return { success: true, placement, toRow, toCol, pushDirection, toPush };
  }
  async playWord() {
    const placements = this.tilesHeld.filter(isBoardPlacement);
    if (placements.length === 0) {
      throw new Error("Drag some tiles onto the board, and try again.");
    }
    const turn = new Turn(this.playerId, this.nextTurnNumber, { playTiles: placements });
    turn.extraParams = this.pendingExtraParams;
    this.pendingExtraParams = new URLSearchParams;
    await this.playTurns(turn);
  }
  async passOrExchange() {
    const placements = this.tilesHeld.map((p, index) => ({ p, index })).filter(({ p }) => p.row === "exchange");
    const exchangeTileIndices = placements.map(({ index }) => index);
    const turn = new Turn(this.playerId, this.nextTurnNumber, { exchangeTileIndices });
    turn.extraParams = this.pendingExtraParams;
    this.pendingExtraParams = new URLSearchParams;
    await this.playTurns(turn);
  }
  recallTiles() {
    const placedTiles = this.tilesHeld.filter((p) => p.row !== "rack");
    const occupiedRackSpots = new Set(this.tilesHeld.filter((p) => p.row === "rack").map((p) => p.col));
    let nextFreeSpot = 0;
    for (const placement of placedTiles) {
      while (occupiedRackSpots.has(nextFreeSpot)) {
        ++nextFreeSpot;
      }
      if (nextFreeSpot >= this.settings.rackCapacity) {
        console.error("No space in rack to recall tile.");
        break;
      }
      this.moveTile(placement.row, placement.col, "rack", nextFreeSpot);
      ++nextFreeSpot;
    }
  }
  async playTurns(...turns) {
    if (this.isGameOver) {
      throw new Error("Game Over.");
    }
    turns = await this.shared.playTurns(...turns);
    for (const turn of turns) {
      if (turn.playerId === this.playerId && "playTiles" in turn.move) {
        for (const placement of turn.move.playTiles) {
          const index = this.tilesHeld.findIndex((p) => p.row === placement.row && p.col === placement.col);
          if (index === -1)
            throw new Error(`Could not find tile to place: ${JSON.stringify(placement)}`);
          this.tilesHeld.splice(index, 1);
        }
      }
    }
    const finalTurnNumber = await this.tilesState.playTurns(...turns);
    const { wroteHistory } = updateTurnHistory({
      history: this.history,
      nextTurnNumber: this.nextTurnNumber,
      finalTurnNumber,
      turns
    });
    if (finalTurnNumber !== null) {
      const finalTurnPlayerId = this.getPlayerForTurnNumber(finalTurnNumber).id;
      console.log(`Player ${finalTurnPlayerId} ends game after turn ${finalTurnNumber}.`);
      let allTilesSum = 0;
      for (const player of this.players) {
        if (player.id !== finalTurnPlayerId) {
          const playerTiles = await this.getTiles(player.id);
          const tilesSum = playerTiles.reduce((sum, curr) => sum + curr.value, 0);
          this.board.scores.set(player.id, (this.board.scores.get(player.id) ?? 0) - tilesSum);
          console.log(`Transfering ${tilesSum} from Player ${player.id}.`);
          allTilesSum += tilesSum;
        }
      }
      console.log(`Transfering ${allTilesSum} to Player ${finalTurnPlayerId}.`);
      this.board.scores.set(finalTurnPlayerId, (this.board.scores.get(finalTurnPlayerId) ?? 0) + allTilesSum);
      this.dispatchEvent(new GameEvent("gameover"));
    }
    if (!this.keepAllHistory) {
      const turnsToKeep = this.players.length - 1;
      if (turnsToKeep > 0 && this.history.length > turnsToKeep) {
        this.history.splice(0, this.history.length - turnsToKeep);
      }
    }
    if (wroteHistory)
      this.dispatchEvent(new GameEvent("turnchange"));
  }
  changePlayerName(playerId, name) {
    const playerIndex = this.players.findIndex((p) => p.id === playerId);
    if (playerIndex === -1) {
      throw new Error(`Player with ID ${playerId} not found.`);
    }
    const player = this.players[playerIndex];
    if (player.name !== name) {
      player.name = name;
      this.pendingExtraParams.set(`p${playerIndex + 1}n`, name);
      this.dispatchEvent(new GameEvent("turnchange"));
    }
  }
  async applyTurnParams(params) {
    if (this.isGameOver)
      return;
    const iterator = params[Symbol.iterator]();
    let urlTurnNumberStr;
    for (const [key, value] of iterator) {
      if (key !== "tn")
        continue;
      urlTurnNumberStr = value;
      break;
    }
    if (!urlTurnNumberStr) {
      console.info("applyTurnParams: no turn number found.");
      return;
    }
    const turns = [];
    let urlTurnNumber = parseInt(urlTurnNumberStr);
    let wordLocationStr = null;
    let blankTileIndicesStr = null;
    let direction = null;
    let wordPlayed = null;
    let exchangeIndicesStr = null;
    const processPendingMoveIfAny = () => {
      const playerId = this.players[(urlTurnNumber - 1) % this.players.length].id;
      if (wordPlayed && direction && wordLocationStr) {
        if (exchangeIndicesStr) {
          throw new Error(`URL contains both word and exchange data for turn ${urlTurnNumber}`);
        }
        const blankTileAssignments = [];
        if (blankTileIndicesStr) {
          blankTileIndicesStr.split(".").forEach((s) => {
            const match2 = s.match(/^(\d+)$/);
            if (!match2) {
              throw new Error(`Invalid "bt" URL parameter component: ${s}`);
            }
            const index = parseInt(match2[1]);
            if (index in blankTileAssignments) {
              throw new Error(`Duplicate blank tile assignment index: bt=${blankTileIndicesStr}`);
            }
            const assignedLetter = wordPlayed[index];
            if (!assignedLetter) {
              throw new RangeError(`Blank tile assignment index ${index} out of range: no "${wordPlayed}"[${index}].`);
            }
            blankTileAssignments[index] = assignedLetter;
          });
        }
        const match = wordLocationStr.match(/^(\d+)\.(\d+)$/);
        if (!match) {
          throw new Error(`Invalid wl parameter in URL: ${wordLocationStr}`);
        }
        let row = parseInt(match[1]);
        let col = parseInt(match[2]);
        const placements = [];
        wordPlayed.split("").map((letter, letterIndex) => {
          const square = this.board.squares[row]?.[col];
          if (!square)
            throw new RangeError(`Attempted to play a word out of bounds: ${row},${col}.`);
          if (!square.tile) {
            const assignedLetter = blankTileAssignments[letterIndex] ?? "";
            if (assignedLetter) {
              placements.push({ tile: new Tile({ letter: "", value: 0 }), row, col, assignedLetter });
            } else {
              const value = this.settings.letterValues[letter];
              if (value === undefined)
                throw new Error(`Attempt to play an invalid letter: "${letter}"`);
              placements.push({ tile: new Tile({ letter, value }), row, col });
            }
          } else if (square.letter !== letter) {
            throw new Error(`Attempt word requires "${letter}" at ${row},${col}, but "${square.letter}" is there.`);
          }
          if (direction === "wv") {
            row += 1;
          } else {
            col += 1;
          }
        });
        if (blankTileAssignments.length > wordPlayed.length) {
          throw new RangeError(`"bt" URL parameter has index ${blankTileAssignments.length - 1} out of range 0-${wordPlayed.length - 1}`);
        }
        turns.push(new Turn(playerId, toTurnNumber(urlTurnNumber), { playTiles: placements }));
      } else if (exchangeIndicesStr != null) {
        if (wordPlayed || direction || wordLocationStr || blankTileIndicesStr) {
          throw new Error(`Incomplete URL data for turn ${urlTurnNumber}: wl=${wordLocationStr} ${direction}=${wordPlayed} bt=${blankTileIndicesStr}`);
        }
        const exchangeIndexStrs = exchangeIndicesStr ? exchangeIndicesStr.split(".") : [];
        const numberOfTilesInRack = this.tilesState.countTiles(playerId);
        const exchangeTileIndices = exchangeIndexStrs.map((s) => parseInt(s, 10));
        exchangeTileIndices.forEach((index) => {
          if (isNaN(index) || index < 0 || index >= numberOfTilesInRack) {
            throw new RangeError(`Exchange tile index ${index} in URL is out of range 0-${numberOfTilesInRack - 1}`);
          }
        });
        turns.push(new Turn(playerId, toTurnNumber(urlTurnNumber), { exchangeTileIndices }));
      } else {
        return;
      }
      urlTurnNumber++;
      wordLocationStr = null;
      blankTileIndicesStr = null;
      direction = null;
      wordPlayed = null;
      exchangeIndicesStr = null;
    };
    for (const [key, value] of iterator) {
      const pnMatch = key.match(/^p(\d+)n$/);
      if (pnMatch) {
        const playerIndex = parseInt(pnMatch[1]) - 1;
        const player = this.players[playerIndex];
        if (player) {
          player.name = value;
        } else {
          throw new Error(`Invalid turn URL: Player ID "${pnMatch[1]}" should be in 1-${this.players.length}.`);
        }
      } else if (key === "wl") {
        processPendingMoveIfAny();
        wordLocationStr = value;
      } else if (key === "ex") {
        processPendingMoveIfAny();
        exchangeIndicesStr = value;
      } else if (key === "bt") {
        if (blankTileIndicesStr) {
          throw new Error(`Duplicate "bt" parameter in URL data for turn ${urlTurnNumber}`);
        }
        blankTileIndicesStr = value;
      } else if (key === "wv" || key === "wh") {
        if (direction) {
          throw new Error(`Duplicate word parameters in URL data for turn ${urlTurnNumber}`);
        }
        direction = key;
        wordPlayed = value;
      } else {
        throw new Error(`Invalid turn URL: Unrecognized parameter name: "${key}"`);
      }
    }
    processPendingMoveIfAny();
    this.dispatchEvent(new GameEvent("turnchange"));
    await this.playTurns(...turns);
  }
  getGameParams() {
    const params = new URLSearchParams;
    const defaults = new Settings;
    params.set("v", this.settings.version);
    if (!playersEqual(this.settings.players, defaults.players)) {
      this.settings.players.forEach((p, index) => {
        params.set(`p${index + 1}n`, p.name);
      });
    }
    if (!arraysEqual(this.settings.boardLayout, defaults.boardLayout, false)) {
      params.set("board", this.settings.boardLayout.join("-"));
    }
    if (this.settings.bingoBonus !== defaults.bingoBonus) {
      params.set("bingo", String(this.settings.bingoBonus));
    }
    if (!(objectsEqual(this.settings.letterCounts, defaults.letterCounts) && objectsEqual(this.settings.letterValues, defaults.letterValues))) {
      const bagParam = Object.entries(this.settings.letterCounts).map(([letter, count]) => `${letter}-${count}-${this.settings.letterValues[letter] ?? 0}`).join(".");
      params.set("bag", bagParam);
    }
    if (this.settings.rackCapacity !== defaults.rackCapacity) {
      params.set("racksize", String(this.settings.rackCapacity));
    }
    if (this.settings.tileSystemType === "honor") {
      params.set("seed", this.settings.tileSystemSettings.seed);
    }
    if (this.settings.dictionaryType !== defaults.dictionaryType) {
      params.set("dt", this.settings.dictionaryType);
    }
    if (typeof this.settings.dictionarySettings === "string") {
      params.set("ds", this.settings.dictionarySettings);
    }
    return params;
  }
  static async fromParams(allParams, playerId) {
    const gameParams = new URLSearchParams;
    const turnParams = new URLSearchParams;
    for (const [name, value] of allParams) {
      if (turnParams.size || name === "tn") {
        turnParams.append(name, value);
      } else {
        gameParams.append(name, value);
      }
    }
    const settings = new Settings;
    const vParam = gameParams.get("v");
    if (vParam && vParam !== settings.version) {
      throw new Error(`Protocol version not supported: ${vParam}`);
    }
    const gidParam = gameParams.get("gid");
    if (gidParam)
      settings.gameId = toGameId(gidParam);
    const newPlayers = [];
    for (let playerNumber = 1;; ++playerNumber) {
      const pnParam = gameParams.get(`p${playerNumber}n`);
      if (!pnParam)
        break;
      newPlayers.push(new Player({ id: String(playerNumber), name: pnParam.slice(0, settings.maxPlayerNameLength) }));
    }
    if (newPlayers.length)
      settings.players = newPlayers;
    const bagParam = gameParams.get("bag");
    if (bagParam) {
      const letterCounts = {};
      const letterValues = {};
      const lettersCountsAndValues = bagParam.split(".").map((letterCountAndValue) => {
        if (!letterCountAndValue.match(/^(.*)-(\d+)-(\d+)$/)) {
          throw new Error(`Invalid letter configuration in URL: ${letterCountAndValue}`);
        }
        const parts = letterCountAndValue.split("-");
        letterCounts[parts[0]] = parseInt(parts[1]);
        letterValues[parts[0]] = parseInt(parts[2]);
      });
      settings.letterCounts = letterCounts;
      settings.letterValues = letterValues;
    }
    const boardParam = gameParams.get("board");
    if (boardParam)
      settings.boardLayout = boardParam.split("-");
    const bingoParam = gameParams.get("bingo");
    if (bingoParam)
      settings.bingoBonus = parseInt(bingoParam);
    const racksizeParam = gameParams.get("racksize");
    if (racksizeParam)
      settings.rackCapacity = parseInt(racksizeParam);
    const tileSystemType = settings.tileSystemType;
    const seedParam = gameParams.get("seed");
    if (!seedParam)
      throw new Error("No random seed in URL.");
    settings.tileSystemSettings = { seed: seedParam };
    const dtParam = gameParams.get("dt");
    if (dtParam === "permissive" || dtParam === "freeapi" || dtParam === "custom") {
      settings.dictionaryType = dtParam;
    } else if (dtParam) {
      throw new Error(`Unknown dictionary type: "${dtParam}".`);
    }
    const dsParam = gameParams.get("ds");
    if (dsParam)
      settings.dictionarySettings = dsParam;
    else if (settings.dictionaryType === "custom") {
      throw new Error("Custom dictionary requires a URL.");
    }
    if (!playerId) {
      const urlTurnNumber = parseInt(turnParams.get("tn")) || 1;
      const turnNumber = urlTurnNumber + turnParams.getAll("wl").length + turnParams.getAll("ex").length;
      playerId = settings.players[(turnNumber - 1) % settings.players.length].id;
      console.log(`Joining as Player ${playerId}.`);
    }
    const gameState = new GameState(playerId, settings);
    await gameState.init();
    await gameState.applyTurnParams(turnParams);
    return gameState;
  }
  toJSON() {
    return {
      shared: this.shared.toJSON(),
      playerId: this.playerId,
      keepAllHistory: this.keepAllHistory,
      tilesHeld: this.tilesHeld.map((placement) => {
        const json = {
          tile: placement.tile.toJSON(),
          row: placement.row,
          col: placement.col
        };
        if (placement.assignedLetter)
          json.assignedLetter = placement.assignedLetter;
        return json;
      }),
      history: this.history
    };
  }
  static async fromJSON(json) {
    function fail(msg) {
      throw new TypeError(`${msg} in GameState serialization: ${JSON.stringify(json)}`);
    }
    if (typeof json !== "object")
      fail("Not an object");
    if (!arraysEqual([...Object.keys(json)], ["shared", "playerId", "keepAllHistory", "tilesHeld", "history"])) {
      fail("Wrong keys or key order");
    }
    if (typeof json.playerId !== "string")
      fail("Player ID is not a string");
    if (typeof json.keepAllHistory !== "boolean")
      fail("keepAllHistory is not a boolean");
    if (!Array.isArray(json.tilesHeld))
      fail("tilesHeld is not an array");
    if (!Array.isArray(json.history))
      fail("History is not an array");
    const tilesHeld = json.tilesHeld.map((tileJson) => {
      if (typeof tileJson !== "object")
        fail("tilesHeld element is not an object");
      if (!arraysEqual([...Object.keys({ ...tileJson, assignedLetter: "x" })], ["tile", "row", "col", "assignedLetter"])) {
        fail("Wrong tilesHeld element keys or key order");
      }
      if (typeof tileJson.row !== "number" && tileJson.row !== "rack" && tileJson.row !== "exchange") {
        fail("Invalid tilesHeld[].row");
      }
      if (typeof tileJson.col !== "number")
        fail("Invalid tilesHeld[].col");
      if (tileJson.assignedLetter !== undefined && typeof tileJson.assignedLetter !== "string") {
        fail("Invalid tilesHeld[].assignedLetter");
      }
      const tile = Tile.fromJSON(tileJson.tile);
      if (tile.letter && tileJson.assignedLetter)
        fail("Non-blank tile with an assigned letter");
      const result = {
        tile,
        row: tileJson.row,
        col: tileJson.col
      };
      if (tileJson.assignedLetter)
        result.assignedLetter = tileJson.assignedLetter;
      return result;
    });
    const gameState = new GameState(json.playerId, undefined, json.keepAllHistory, SharedState.fromJSON(json.shared), tilesHeld, json.history);
    await gameState.init();
    return gameState;
  }
}
function playersEqual(ps1, ps2) {
  if (ps1.length !== ps2.length)
    return false;
  for (const index in ps1) {
    if (!ps1[index].equals(ps2[index]))
      return false;
  }
  return true;
}

// view/dialog.ts
class Dialog {
  title;
  content;
  buttons;
  dialogElement;
  contentElement;
  promiseResolve = () => {};
  doc;
  constructor(doc, title, content, buttons) {
    this.title = title;
    this.content = content;
    this.buttons = buttons;
    this.doc = doc;
    this.dialogElement = this.doc.createElement("dialog");
    this.dialogElement.innerHTML = `
      <form method="dialog">
        <h2>${this.title}</h2>
        <div class="content"></div>
        <div class="buttons"></div>
      </form>
    `;
    this.contentElement = this.dialogElement.querySelector(".content");
    this.contentElement.appendChild(this.content);
    const buttonsContainer = this.dialogElement.querySelector(".buttons");
    for (const label of this.buttons) {
      const button = this.doc.createElement("button");
      button.textContent = label;
      button.value = label;
      buttonsContainer.appendChild(button);
    }
    this.doc.body.appendChild(this.dialogElement);
    this.dialogElement.addEventListener("close", () => {
      this.promiseResolve(this.dialogElement.returnValue);
      this.dialogElement.remove();
    });
  }
  show() {
    this.dialogElement.showModal();
    return new Promise((resolve) => {
      this.promiseResolve = resolve;
    });
  }
  close() {
    this.dialogElement.close();
  }
}

// view/view.ts
class View {
  gameContainer;
  boardContainer;
  rackContainer;
  exchangeContainer;
  scorePanel;
  bagTileCountContainer;
  gameState;
  dropTarget = null;
  doc;
  browser;
  settingsDialog = null;
  constructor(gameState, browser) {
    this.gameState = gameState;
    this.browser = browser;
    this.doc = browser.getDocument();
    this.gameContainer = this.doc.getElementById("game-container");
    this.boardContainer = this.gameContainer.querySelector("#board-container");
    this.rackContainer = this.gameContainer.querySelector("#rack-container");
    this.exchangeContainer = this.gameContainer.querySelector("#exchange-container");
    this.scorePanel = this.gameContainer.querySelector("#score-panel");
    this.bagTileCountContainer = this.gameContainer.querySelector("#bag-tile-count-container");
    this.gameState.addEventListener("turnchange", () => this.renderScores());
  }
  addTileToElement(element, tile, assignedLetter) {
    element.textContent = "";
    const letterDiv = this.doc.createElement("div");
    letterDiv.className = "letter";
    letterDiv.textContent = assignedLetter || tile.letter;
    element.appendChild(letterDiv);
    if (!tile.isBlank) {
      const valueDiv = this.doc.createElement("div");
      valueDiv.className = "value";
      valueDiv.textContent = String(tile.value);
      element.appendChild(valueDiv);
    }
  }
  renderBoard() {
    this.boardContainer.innerHTML = "";
    const centerSquare = this.gameState.board.centerSquare;
    for (let r = 0;r < this.gameState.board.squares.length; r++) {
      const row = this.gameState.board.squares[r];
      if (!row)
        throw new Error(`Invalid board: Row ${r} is missing.`);
      for (let c = 0;c < row.length; c++) {
        const square = row[c];
        if (!square)
          throw new Error(`Invalid board: Square ${r},${c} is missing.`);
        const squareDiv = this.doc.createElement("div");
        squareDiv.className = "square";
        if (square.letterBonus === 2)
          squareDiv.classList.add("dl");
        if (square.letterBonus === 3)
          squareDiv.classList.add("tl");
        if (square.wordBonus === 2)
          squareDiv.classList.add("dw");
        if (square.wordBonus === 3)
          squareDiv.classList.add("tw");
        if (r === centerSquare.row && c === centerSquare.col)
          squareDiv.classList.add("center");
        squareDiv.dataset.row = String(r);
        squareDiv.dataset.col = String(c);
        if (square.tile) {
          this.addTileToElement(squareDiv, square.tile, square.assignedLetter);
        } else {
          const placedTile = this.gameState.tilesHeld.find((p) => p.row === r && p.col === c);
          if (placedTile) {
            this.addTileToElement(squareDiv, placedTile.tile, placedTile.assignedLetter);
            squareDiv.classList.add("placed");
            squareDiv.tabIndex = 0;
          } else {
            const bonusSpan = this.doc.createElement("span");
            bonusSpan.className = "bonus-text";
            if (square.letterBonus === 2)
              bonusSpan.textContent = "2L";
            if (square.letterBonus === 3)
              bonusSpan.textContent = "3L";
            if (square.wordBonus === 2)
              bonusSpan.textContent = "2W";
            if (square.wordBonus === 3)
              bonusSpan.textContent = "3W";
            if (bonusSpan.textContent)
              squareDiv.appendChild(bonusSpan);
          }
        }
        this.boardContainer.appendChild(squareDiv);
      }
    }
  }
  renderScores() {
    this.scorePanel.innerHTML = "";
    const currentPlayer = this.gameState.playerWhoseTurnItIs;
    let maxScore = -Infinity;
    if (this.gameState.isGameOver) {
      const scores = [...this.gameState.board.scores.values()];
      if (scores.length > 0) {
        maxScore = Math.max(...scores);
      }
    }
    for (const player of this.gameState.players) {
      const score = this.gameState.board.scores.get(player.id) ?? 0;
      const scoreDiv = this.doc.createElement("div");
      scoreDiv.className = "player-score";
      if (player.id === currentPlayer?.id) {
        scoreDiv.classList.add("current-player");
      }
      const nameSpan = this.doc.createElement("span");
      nameSpan.textContent = player.name;
      const scoreSpan = this.doc.createElement("span");
      scoreSpan.textContent = `: ${score}`;
      if (this.gameState.isGameOver && score === maxScore) {
        scoreSpan.textContent += " \uD83C\uDF89";
      }
      const editButton = this.doc.createElement("span");
      editButton.textContent = " ✏️";
      editButton.className = "edit-button";
      editButton.style.cursor = "pointer";
      editButton.addEventListener("click", () => {
        const input = this.doc.createElement("input");
        input.type = "text";
        input.value = player.name;
        scoreDiv.replaceChild(input, nameSpan);
        input.focus();
        const save = () => {
          if (input.value && input.value !== player.name) {
            this.gameState.changePlayerName(player.id, input.value);
          }
        };
        const cancel = () => {
          scoreDiv.replaceChild(nameSpan, input);
        };
        input.addEventListener("blur", save);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            save();
          } else if (e.key === "Escape") {
            cancel();
          }
        });
      });
      scoreDiv.appendChild(nameSpan);
      scoreDiv.appendChild(scoreSpan);
      if (player.id === this.gameState.playerId) {
        scoreDiv.appendChild(editButton);
      }
      this.scorePanel.appendChild(scoreDiv);
    }
  }
  renderRacklike(container, name) {
    container.innerHTML = "";
    const tiles = this.gameState.tilesHeld.filter((p) => p.row === name);
    const tileElements = [];
    for (const tilePlacement of tiles) {
      const tileDiv = this.doc.createElement("div");
      tileDiv.className = "tile";
      this.addTileToElement(tileDiv, tilePlacement.tile, tilePlacement.assignedLetter);
      tileDiv.dataset.row = String(tilePlacement.row);
      tileDiv.dataset.col = String(tilePlacement.col);
      tileDiv.tabIndex = 0;
      tileElements[tilePlacement.col] = tileDiv;
    }
    for (let i = 0;i < this.gameState.settings.rackCapacity; i++) {
      const tileDiv = tileElements[i];
      if (tileDiv) {
        container.appendChild(tileDiv);
      } else {
        const emptySpot = this.doc.createElement("div");
        emptySpot.className = "tile-spot";
        emptySpot.dataset.row = name;
        emptySpot.dataset.col = String(i);
        container.appendChild(emptySpot);
      }
    }
  }
  renderRack() {
    this.renderRacklike(this.rackContainer, "rack");
    this.renderRacklike(this.exchangeContainer, "exchange");
  }
  renderBagTileCount() {
    this.bagTileCountContainer.textContent = `Tiles in bag: ${this.gameState.numberOfTilesInBag}`;
  }
  renderPassExchangeButton() {
    const button = this.doc.getElementById("pass-exchange");
    const count = this.gameState.exchangeTilesCount;
    if (count === 0) {
      button.textContent = "Pass Turn";
    } else {
      button.textContent = `Exchange ${count}`;
    }
  }
  getElementByLocation(row, col) {
    return this.doc.querySelector(`[data-row="${row}"][data-col="${col}"]`);
  }
  clearDropTarget() {
    if (this.dropTarget) {
      const el = this.getElementByLocation(this.dropTarget.row, this.dropTarget.col);
      el?.classList.remove("drop-target");
    }
    this.dropTarget = null;
  }
  setDropTarget(row, col) {
    this.clearDropTarget();
    const el = this.getElementByLocation(row, col);
    if (el) {
      el.classList.add("drop-target");
      this.dropTarget = { row, col };
    }
  }
  getDropTarget() {
    return this.dropTarget;
  }
  deselect(selectedTile) {
    const prevSelected = this.getElementByLocation(selectedTile.row, selectedTile.col);
    prevSelected?.classList.remove("selected");
    this.clearDropTarget();
  }
  select(row, col) {
    const element = this.getElementByLocation(row, col);
    element?.classList.add("selected");
  }
  createGhostTile(originalTileElement) {
    const ghostTile = originalTileElement.cloneNode(true);
    ghostTile.classList.remove("selected");
    ghostTile.classList.add("ghost-tile");
    this.doc.body.appendChild(ghostTile);
    return ghostTile;
  }
  removeGhostTile(ghostTileElement) {
    if (ghostTileElement && ghostTileElement.parentNode) {
      ghostTileElement.parentNode.removeChild(ghostTileElement);
    }
  }
  async showConfirmationDialog(title, showCopyCheckbox) {
    const content = this.doc.createElement("div");
    let copyUrlCheckbox;
    if (showCopyCheckbox) {
      const copyUrlContainer = this.doc.createElement("div");
      copyUrlContainer.innerHTML = `
        <label>
          <input type="checkbox" id="copy-url-checkbox" checked>
          Copy Turn URL?
        </label>
      `;
      copyUrlCheckbox = copyUrlContainer.querySelector("#copy-url-checkbox");
      content.appendChild(copyUrlContainer);
    }
    const dialog = new Dialog(this.doc, title, content, ["OK", "Cancel"]);
    const result = await dialog.show();
    return {
      confirmed: result === "OK",
      copyUrl: result === "OK" && (copyUrlCheckbox?.checked ?? false)
    };
  }
  showSettingsDialog() {
    if (this.settingsDialog) {
      this.settingsDialog.remove();
      this.settingsDialog = null;
      return;
    }
    const dialog = this.doc.createElement("div");
    dialog.id = "settings-dialog";
    const content = this.doc.createElement("div");
    content.className = "content";
    const playersContainer = this.doc.createElement("div");
    playersContainer.className = "settings-group";
    const playersHeader = this.doc.createElement("h3");
    playersHeader.textContent = "Players";
    playersContainer.appendChild(playersHeader);
    const playerList = this.doc.createElement("div");
    playerList.id = "player-list";
    const updatePlayerList = (players) => {
      playerList.innerHTML = "";
      players.forEach((player, index) => {
        const playerEntry = this.doc.createElement("div");
        playerEntry.className = "player-entry";
        const input = this.doc.createElement("input");
        input.type = "text";
        input.value = player.name;
        input.placeholder = `Player ${index + 1}`;
        playerEntry.appendChild(input);
        const removeButton = this.doc.createElement("button");
        removeButton.textContent = "-";
        removeButton.onclick = () => {
          const currentPlayers = Array.from(playerList.querySelectorAll("input")).map((i) => ({ name: i.value }));
          currentPlayers.splice(index, 1);
          updatePlayerList(currentPlayers);
        };
        playerEntry.appendChild(removeButton);
        playerList.appendChild(playerEntry);
      });
    };
    updatePlayerList(this.gameState.players.map((p) => ({ name: p.name })));
    const addButton = this.doc.createElement("button");
    addButton.textContent = "+";
    addButton.onclick = () => {
      const currentPlayers = Array.from(playerList.querySelectorAll("input")).map((i) => ({ name: i.value }));
      currentPlayers.push({ name: "" });
      updatePlayerList(currentPlayers);
    };
    playersContainer.appendChild(playerList);
    playersContainer.appendChild(addButton);
    content.appendChild(playersContainer);
    const dictionaryContainer = this.doc.createElement("div");
    dictionaryContainer.className = "settings-group";
    const dictionaryHeader = this.doc.createElement("h3");
    dictionaryHeader.textContent = "Dictionary";
    dictionaryContainer.appendChild(dictionaryHeader);
    const dictOptions = [
      { value: "permissive", text: "Anything is a word" },
      { value: "freeapi", text: "freeapi" },
      { value: "custom", text: "custom" }
    ];
    const urlInputContainer = this.doc.createElement("div");
    urlInputContainer.style.display = "none";
    const urlInput = this.doc.createElement("input");
    urlInput.type = "text";
    urlInput.id = "dictionary-url";
    urlInput.placeholder = "URL";
    const urlLabel = this.doc.createElement("label");
    urlLabel.textContent = "URL: ";
    urlInputContainer.appendChild(urlLabel);
    urlInputContainer.appendChild(urlInput);
    const dictSelect = this.doc.createElement("select");
    dictSelect.id = "dictionary-type";
    dictOptions.forEach((opt) => {
      const option = this.doc.createElement("option");
      option.value = opt.value;
      option.textContent = opt.text;
      if (this.gameState.settings.dictionaryType === opt.value) {
        option.selected = true;
      }
      dictSelect.appendChild(option);
    });
    dictionaryContainer.appendChild(dictSelect);
    const handleDictChange = () => {
      const selectedValue = dictSelect.value;
      if (selectedValue === "freeapi" || selectedValue === "custom") {
        urlInputContainer.style.display = "block";
        urlInput.required = selectedValue === "custom";
      } else {
        urlInputContainer.style.display = "none";
      }
    };
    dictSelect.addEventListener("change", handleDictChange);
    dictionaryContainer.appendChild(urlInputContainer);
    content.appendChild(dictionaryContainer);
    handleDictChange();
    if (this.gameState.settings.dictionarySettings && typeof this.gameState.settings.dictionarySettings === "object" && "url" in this.gameState.settings.dictionarySettings && typeof this.gameState.settings.dictionarySettings.url === "string") {
      urlInput.value = this.gameState.settings.dictionarySettings.url;
    }
    const bingoContainer = this.doc.createElement("div");
    bingoContainer.className = "settings-group";
    const bingoHeader = this.doc.createElement("h3");
    bingoHeader.textContent = "Bingo Bonus";
    bingoContainer.appendChild(bingoHeader);
    const bingoInput = this.doc.createElement("input");
    bingoInput.type = "number";
    bingoInput.id = "bingo-bonus";
    bingoInput.value = String(this.gameState.settings.bingoBonus);
    bingoContainer.appendChild(bingoInput);
    content.appendChild(bingoContainer);
    const seedContainer = this.doc.createElement("div");
    seedContainer.className = "settings-group";
    const seedHeader = this.doc.createElement("h3");
    seedHeader.textContent = "Random Seed";
    seedContainer.appendChild(seedHeader);
    const seedInput = this.doc.createElement("input");
    seedInput.type = "text";
    seedInput.id = "random-seed";
    seedInput.value = this.gameState.settings.tileSystemSettings.seed;
    seedContainer.appendChild(seedInput);
    content.appendChild(seedContainer);
    dialog.appendChild(content);
    const buttonsContainer = this.doc.createElement("div");
    buttonsContainer.className = "buttons";
    const startButton = this.doc.createElement("button");
    startButton.id = "start-game-with-settings";
    startButton.textContent = "Start Game with Settings";
    startButton.addEventListener("click", () => {
      const params = new URLSearchParams;
      const playerInputs = Array.from(playerList.querySelectorAll("input"));
      const playerNames = playerInputs.map((input) => input.value).filter((name) => name.trim() !== "");
      if (playerNames.length > 0) {
        params.set("p", playerNames.join(","));
      }
      const dictionaryType = this.doc.getElementById("dictionary-type").value;
      params.set("dt", dictionaryType);
      if (dictionaryType === "freeapi" || dictionaryType === "custom") {
        const url = this.doc.getElementById("dictionary-url").value;
        if (url) {
          params.set("ds", url);
        }
      }
      const bingoBonus = this.doc.getElementById("bingo-bonus").value;
      params.set("bingo", bingoBonus);
      const seed = this.doc.getElementById("random-seed").value;
      params.set("seed", seed || String(Math.floor(1e6 * this.browser.getRandom())));
      this.browser.setHash(params.toString());
      this.showSettingsDialog();
    });
    buttonsContainer.appendChild(startButton);
    dialog.appendChild(buttonsContainer);
    this.settingsDialog = dialog;
    this.gameContainer.querySelector("#controls-container").appendChild(dialog);
  }
}

// controller/key_handler.ts
class KeyHandler {
  gameState;
  view;
  selectedTile = null;
  constructor(gameState, view) {
    this.gameState = gameState;
    this.view = view;
  }
  select(row, col) {
    this.deselect();
    this.selectedTile = { row, col };
    this.view.select(row, col);
    this.view.setDropTarget(row, col);
  }
  deselect() {
    if (!this.selectedTile)
      return;
    this.view.deselect(this.selectedTile);
    this.selectedTile = null;
  }
  keydown(evt) {
    const target = evt.target;
    if (!target.dataset.col || !target.dataset.row)
      return;
    const col = parseInt(target.dataset.col, 10);
    const rowStr = target.dataset.row;
    const row = rowStr === "rack" ? "rack" : rowStr === "exchange" ? "exchange" : parseInt(rowStr, 10);
    switch (evt.key) {
      case " ":
      case "Enter": {
        evt.preventDefault();
        if (this.selectedTile) {
          const dropTarget = this.view.getDropTarget();
          if (!dropTarget)
            return;
          const { row: toRow, col: toCol } = dropTarget;
          if (isBoardPlacementRow(toRow)) {
            if (this.gameState.board.squares[toRow]?.[toCol]?.tile)
              return;
            if (this.gameState.tilesHeld.find((p) => p.row === toRow && p.col === toCol))
              return;
          }
          try {
            const selectedPlacement = this.gameState.tilesHeld.find((p) => p.row === this.selectedTile.row && p.col === this.selectedTile.col);
            let assignedLetter;
            if (selectedPlacement?.tile.isBlank && isBoardPlacementRow(toRow)) {
              const letter = prompt("Enter a letter for the blank tile:");
              if (!letter || letter.length !== 1 || !/^[a-zA-Z]$/.test(letter)) {
                alert("Invalid letter. Please enter a single letter.");
                return;
              }
              assignedLetter = letter.toUpperCase();
            }
            this.gameState.moveTile(this.selectedTile.row, this.selectedTile.col, toRow, toCol, assignedLetter);
            this.deselect();
          } catch (e) {
            alert(e);
          }
        } else {
          this.select(row, col);
          this.view.setDropTarget(row, col);
        }
        break;
      }
      case "Escape": {
        evt.preventDefault();
        if (this.selectedTile) {
          const previouslySelected = this.view.getElementByLocation(this.selectedTile.row, this.selectedTile.col);
          this.deselect();
          previouslySelected?.focus();
        }
        break;
      }
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight": {
        evt.preventDefault();
        this.moveDropTarget(evt.key);
        break;
      }
    }
  }
  moveDropTarget(key) {
    const dropTarget = this.view.getDropTarget();
    if (!this.selectedTile || !dropTarget)
      return;
    let { row: r, col: c } = dropTarget;
    const rackCapacity = this.gameState.settings.rackCapacity;
    const boardCenterCol = this.gameState.board.centerSquare.col;
    const rackCenter = Math.ceil((rackCapacity - 1) / 2);
    const boardCenterRow = this.gameState.board.centerSquare.row;
    const boardWidth = this.gameState.board.squares[boardCenterRow].length;
    const boardHeight = this.gameState.board.squares.length;
    switch (key) {
      case "ArrowUp":
        if (r === "exchange") {
          r = "rack";
        } else if (r === "rack") {
          const offset = c - rackCenter;
          c = boardCenterCol + offset;
          c = Math.max(0, Math.min(boardWidth - 1, c));
          r = boardHeight - 1;
        } else if (r > 0) {
          r--;
        }
        break;
      case "ArrowDown":
        if (r === "rack") {
          r = "exchange";
        } else if (r !== "exchange") {
          if (r === boardHeight - 1) {
            const offset = c - boardCenterCol;
            c = rackCenter + offset;
            c = Math.max(0, Math.min(rackCapacity - 1, c));
            r = "rack";
          } else if (r < boardHeight - 1) {
            r++;
          }
        }
        break;
      case "ArrowLeft":
        if (r === "rack" && c === 0 && boardWidth > 0) {
          r = boardCenterRow;
          c = boardWidth - 1;
        } else if (c > 0) {
          c--;
        }
        break;
      case "ArrowRight":
        if (r === "rack" || r === "exchange") {
          if (c < rackCapacity - 1) {
            c++;
          }
        } else {
          if (c === boardWidth - 1) {
            r = "rack";
            c = 0;
          } else {
            c++;
          }
        }
        break;
    }
    this.view.setDropTarget(r, c);
  }
}

// controller/pointer_handler.ts
class PointerHandler {
  gameState;
  view;
  draggingTile = null;
  ghostTile = null;
  constructor(gameState, view) {
    this.gameState = gameState;
    this.view = view;
  }
  pointerDown(evt) {
    const tileTarget = evt.target.closest(".tile, .placed");
    if (!(tileTarget instanceof HTMLElement))
      return;
    if (evt.button !== 0)
      return;
    evt.preventDefault();
    evt.stopPropagation();
    const col = parseInt(tileTarget.dataset.col, 10);
    const rowStr = tileTarget.dataset.row;
    const row = rowStr === "rack" ? "rack" : rowStr === "exchange" ? "exchange" : parseInt(rowStr, 10);
    this.draggingTile = { row, col, element: tileTarget };
    this.ghostTile = this.view.createGhostTile(this.draggingTile.element);
    this.draggingTile.element.classList.add("dragging");
    this.ghostTile.style.left = `${evt.clientX}px`;
    this.ghostTile.style.top = `${evt.clientY}px`;
  }
  pointerMove(evt) {
    if (!this.draggingTile)
      return;
    evt.preventDefault();
    evt.stopPropagation();
    this.ghostTile.style.left = `${evt.clientX}px`;
    this.ghostTile.style.top = `${evt.clientY}px`;
    this.ghostTile.style.display = "none";
    const targetElement = document.elementFromPoint(evt.clientX, evt.clientY);
    this.ghostTile.style.display = "";
    if (targetElement) {
      const dropTarget = targetElement.closest(".square, .tile-spot, .tile, .placed");
      if (dropTarget instanceof HTMLElement && dropTarget.dataset.row && dropTarget.dataset.col) {
        const toRowStr = dropTarget.dataset.row;
        const toRow = toRowStr === "rack" ? "rack" : toRowStr === "exchange" ? "exchange" : parseInt(toRowStr, 10);
        const toCol = parseInt(dropTarget.dataset.col, 10);
        this.view.setDropTarget(toRow, toCol);
      } else {
        this.view.clearDropTarget();
      }
    }
  }
  pointerUp(evt) {
    if (this.ghostTile) {
      const dropTarget = this.view.getDropTarget();
      if (dropTarget) {
        try {
          const fromRow = this.draggingTile.row;
          const fromCol = this.draggingTile.col;
          const toRow = dropTarget.row;
          const toCol = dropTarget.col;
          const selectedPlacement = this.gameState.tilesHeld.find((p) => p.row === fromRow && p.col === fromCol);
          let assignedLetter;
          if (selectedPlacement?.tile.isBlank && isBoardPlacementRow(toRow)) {
            const letter = prompt("Enter a letter for the blank tile:");
            if (!letter || letter.length !== 1 || !/^[a-zA-Z]$/.test(letter)) {
              alert("Invalid letter. Please enter a single letter.");
            } else {
              assignedLetter = letter.toUpperCase();
              this.gameState.moveTile(fromRow, fromCol, toRow, toCol, assignedLetter);
            }
          } else {
            this.gameState.moveTile(fromRow, fromCol, toRow, toCol);
          }
        } catch (e) {
          alert(e);
        }
      }
      this.view.removeGhostTile(this.ghostTile);
      this.draggingTile.element.classList.remove("dragging");
    }
    this.draggingTile = null;
    this.ghostTile = null;
    this.view.clearDropTarget();
  }
}

// controller/controller.ts
class Controller {
  gameState;
  view;
  browser;
  keyHandler;
  pointerHandler;
  constructor(gameState, view, browser) {
    this.gameState = gameState;
    this.view = view;
    this.browser = browser;
    this.keyHandler = new KeyHandler(gameState, view);
    this.pointerHandler = new PointerHandler(gameState, view);
    this.attachEventListeners();
  }
  async playWordClick() {
    const { confirmed, copyUrl } = await this.view.showConfirmationDialog("Play Word?", this.browser.hasClipboard());
    if (!confirmed)
      return;
    try {
      await this.gameState.playWord();
      if (copyUrl) {
        const url = new URL(this.browser.getHref());
        url.hash = this.gameState.turnUrlParams.toString();
        await this.browser.writeToClipboard(url.toString());
      }
    } catch (e) {
      alert(e instanceof PlayRejectedError ? e.message : e);
    }
  }
  async passOrExchangeClick() {
    const tileCount = this.gameState.exchangeTilesCount;
    const { confirmed, copyUrl } = await this.view.showConfirmationDialog(tileCount ? `Exchange ${tileCount}?` : "Pass Turn?", this.browser.hasClipboard());
    if (!confirmed)
      return;
    try {
      await this.gameState.passOrExchange();
      if (copyUrl) {
        const url = new URL(this.browser.getHref());
        url.hash = this.gameState.turnUrlParams.toString();
        await this.browser.writeToClipboard(url.toString());
      }
    } catch (e) {
      alert(e);
    }
  }
  attachEventListeners() {
    const doc = this.browser.getDocument();
    const gameContainer = doc.getElementById("game-container");
    gameContainer.addEventListener("pointerdown", this.pointerHandler.pointerDown.bind(this.pointerHandler));
    doc.addEventListener("pointermove", this.pointerHandler.pointerMove.bind(this.pointerHandler));
    doc.addEventListener("pointerup", this.pointerHandler.pointerUp.bind(this.pointerHandler));
    gameContainer.addEventListener("keydown", this.keyHandler.keydown.bind(this.keyHandler));
    doc.getElementById("play-word").addEventListener("click", this.playWordClick.bind(this));
    doc.getElementById("pass-exchange").addEventListener("click", this.passOrExchangeClick.bind(this));
    doc.getElementById("recall-tiles").addEventListener("click", this.recallTilesClick.bind(this));
    doc.getElementById("game-setup").addEventListener("click", this.gameSetupClick.bind(this));
  }
  gameSetupClick() {
    this.view.showSettingsDialog();
  }
  recallTilesClick() {
    this.gameState.recallTiles();
  }
}

// browser.ts
class DomBrowser {
  getHash() {
    return window.location.hash;
  }
  setHash(hash) {
    window.location.hash = hash;
  }
  addHashChangeListener(listener) {
    window.addEventListener("hashchange", listener);
  }
  getLocalStorageItem(key) {
    return localStorage.getItem(key);
  }
  setLocalStorageItem(key, value) {
    localStorage.setItem(key, value);
  }
  getDocument() {
    return document;
  }
  getURLSearchParams(query) {
    return new URLSearchParams(query);
  }
  getRandom() {
    return Math.random();
  }
  getHref() {
    return location.href;
  }
  writeToClipboard(text) {
    return navigator.clipboard.writeText(text);
  }
  hasClipboard() {
    return "clipboard" in navigator;
  }
  addPasteListener(listener) {
    window.addEventListener("paste", (event) => {
      const text = event.clipboardData?.getData("text/plain");
      if (text) {
        listener(text);
      }
    });
  }
}

// app.ts
class App {
  browser;
  gameState;
  view;
  controller;
  constructor(browser) {
    this.browser = browser;
  }
  updateUrl() {
    const paramsStr = this.gameState.turnUrlParams.toString();
    if (this.browser.getHash().substr(1) !== paramsStr) {
      this.browser.setHash(paramsStr);
    }
  }
  saveGameState() {
    const gid = this.gameState.gameId;
    if (gid) {
      this.browser.setLocalStorageItem(`sharewords_${gid}`, JSON.stringify(this.gameState.toJSON()));
    }
  }
  async init() {
    const handleGameChange = async () => {
      const params = this.browser.getURLSearchParams(this.browser.getHash()?.substring(1) || "");
      const gidParam = params.get("gid");
      const gameId = gidParam ? toGameId(gidParam) : makeGameId();
      if (this.gameState?.gameId === gameId) {
        await this.gameState.applyTurnParams(params);
        return;
      }
      const savedGame = gidParam && this.browser.getLocalStorageItem(`sharewords_${gidParam}`);
      if (savedGame) {
        console.log(`Loaded ${gameId} from local storage${this.gameState ? " and switched from " + this.gameState.gameId + " to it" : ""}.`);
        this.gameState = await GameState.fromJSON(JSON.parse(savedGame));
      } else {
        if (!params.get("seed"))
          params.set("seed", String(Math.floor(1e6 * this.browser.getRandom())));
        this.gameState = await GameState.fromParams(params);
      }
      this.saveGameState();
      this.updateUrl();
      this.view = new View(this.gameState, this.browser);
      this.controller = new Controller(this.gameState, this.view, this.browser);
      this.view.renderBoard();
      this.view.renderRack();
      this.view.renderScores();
      this.view.renderBagTileCount();
      this.view.renderPassExchangeButton();
      this.gameState.addEventListener("tilemove", (evt) => {
        if (!isBoardPlacementRow(evt.detail.fromRow) || !isBoardPlacementRow(evt.detail.placement.row)) {
          this.view.renderRack();
        }
        if (evt.detail.fromRow === "exchange" !== (evt.detail.placement.row === "exchange")) {
          this.view.renderPassExchangeButton();
        }
        if (isBoardPlacementRow(evt.detail.fromRow) || isBoardPlacementRow(evt.detail.placement.row)) {
          this.view.renderBoard();
        }
        this.saveGameState();
      });
      this.gameState.addEventListener("turnchange", () => {
        this.view.renderBoard();
        this.view.renderRack();
        this.view.renderScores();
        this.view.renderBagTileCount();
        this.updateUrl();
        this.saveGameState();
      });
      this.gameState.addEventListener("gameover", () => {
        this.saveGameState();
      });
    };
    this.browser.addHashChangeListener(handleGameChange);
    this.browser.addPasteListener(this.handlePaste.bind(this));
    await handleGameChange();
  }
  async handlePaste(pastedText) {
    try {
      const url = new URL(pastedText);
      const Href = this.browser.getHref();
      if (url.origin !== new URL(Href).origin || url.pathname !== new URL(Href).pathname) {
        return;
      }
      const params = this.browser.getURLSearchParams(url.hash.substring(1));
      if (!(this.gameState && fromGameId(this.gameState.gameId) === params.get("gid"))) {
        return;
      }
      await this.gameState.applyTurnParams(params);
    } catch (e) {}
  }
}
if (typeof window !== "undefined") {
  const app = new App(new DomBrowser);
  app.init();
}
</script></head>
  <body>
    <h1>Crossword Builder</h1>
    <div id="game-container">
      <div id="center-panel">
        <div id="score-panel"></div>
        <div id="board-container"></div>
      </div>
      <div id="controls-container">
        <div id="bag-tile-count-container"></div>
        <div id="rack-container"></div>
        <div id="exchange-container"></div>
        <div id="buttons-container">
          <button id="play-word">Play Word</button>
          <button id="pass-exchange">Pass/Exchange</button>
          <button id="recall-tiles">Recall Tiles</button>
          <button id="game-setup">Game Setup</button>
        </div>
      </div>
    </div>
  </body>
</html>

